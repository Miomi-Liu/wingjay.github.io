{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/myNext/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0},{"_id":"themes/myNext/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0},{"_id":"themes/myNext/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0},{"_id":"themes/myNext/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0},{"_id":"themes/myNext/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0},{"_id":"themes/myNext/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0},{"_id":"themes/myNext/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0},{"_id":"themes/myNext/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0},{"_id":"themes/myNext/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0},{"_id":"themes/myNext/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0},{"_id":"themes/myNext/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0},{"_id":"themes/myNext/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0},{"_id":"themes/myNext/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0},{"_id":"themes/myNext/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0},{"_id":"themes/myNext/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0},{"_id":"themes/myNext/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0},{"_id":"themes/myNext/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0},{"_id":"themes/myNext/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0},{"_id":"themes/myNext/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0},{"_id":"themes/myNext/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0},{"_id":"themes/myNext/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0},{"_id":"themes/myNext/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0},{"_id":"themes/myNext/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0},{"_id":"themes/myNext/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0},{"_id":"themes/myNext/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0},{"_id":"themes/myNext/source/js/ua-parser.min.js","path":"js/ua-parser.min.js","modified":0},{"_id":"themes/myNext/source/js/motion.js","path":"js/motion.js","modified":0},{"_id":"themes/myNext/source/js/hook-duoshuo.js","path":"js/hook-duoshuo.js","modified":0},{"_id":"themes/myNext/source/js/helpers.js","path":"js/helpers.js","modified":0},{"_id":"themes/myNext/source/js/fancy-box.js","path":"js/fancy-box.js","modified":0},{"_id":"themes/myNext/source/js/bootstrap.scrollspy.js","path":"js/bootstrap.scrollspy.js","modified":0},{"_id":"themes/myNext/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0},{"_id":"themes/myNext/source/images/searchicon.png","path":"images/searchicon.png","modified":0},{"_id":"themes/myNext/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0},{"_id":"themes/myNext/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0},{"_id":"themes/myNext/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0},{"_id":"themes/myNext/source/images/loading.gif","path":"images/loading.gif","modified":0},{"_id":"themes/myNext/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0},{"_id":"themes/myNext/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0},{"_id":"themes/myNext/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0},{"_id":"themes/myNext/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0},{"_id":"themes/myNext/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0},{"_id":"themes/myNext/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0},{"_id":"themes/myNext/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0},{"_id":"themes/myNext/source/css/main.styl","path":"css/main.styl","modified":0},{"_id":"themes/myNext/source/404.html","path":"404.html","modified":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0},{"_id":"source/img/打赏.JPG","path":"img/打赏.JPG","modified":0},{"_id":"source/img/walk_in_sh/9.JPG","path":"img/walk_in_sh/9.JPG","modified":0},{"_id":"source/img/walk_in_sh/8.JPG","path":"img/walk_in_sh/8.JPG","modified":0},{"_id":"source/img/walk_in_sh/7.JPG","path":"img/walk_in_sh/7.JPG","modified":0},{"_id":"source/img/walk_in_sh/6.JPG","path":"img/walk_in_sh/6.JPG","modified":0},{"_id":"source/img/walk_in_sh/5.JPG","path":"img/walk_in_sh/5.JPG","modified":0},{"_id":"source/img/walk_in_sh/4.JPG","path":"img/walk_in_sh/4.JPG","modified":0},{"_id":"source/img/walk_in_sh/3.JPG","path":"img/walk_in_sh/3.JPG","modified":0},{"_id":"source/img/walk_in_sh/2.JPG","path":"img/walk_in_sh/2.JPG","modified":0},{"_id":"source/img/walk_in_sh/18.JPG","path":"img/walk_in_sh/18.JPG","modified":0},{"_id":"source/img/walk_in_sh/17.JPG","path":"img/walk_in_sh/17.JPG","modified":0},{"_id":"source/img/walk_in_sh/16.JPG","path":"img/walk_in_sh/16.JPG","modified":0},{"_id":"source/img/walk_in_sh/15.JPG","path":"img/walk_in_sh/15.JPG","modified":0},{"_id":"source/img/walk_in_sh/14.JPG","path":"img/walk_in_sh/14.JPG","modified":0},{"_id":"source/img/walk_in_sh/13.JPG","path":"img/walk_in_sh/13.JPG","modified":0},{"_id":"source/img/walk_in_sh/12.JPG","path":"img/walk_in_sh/12.JPG","modified":0},{"_id":"source/img/walk_in_sh/11.JPG","path":"img/walk_in_sh/11.JPG","modified":0},{"_id":"source/img/walk_in_sh/10.JPG","path":"img/walk_in_sh/10.JPG","modified":0},{"_id":"source/img/walk_in_sh/1.JPG","path":"img/walk_in_sh/1.JPG","modified":0},{"_id":"source/img/sjtu/tuya.jpg","path":"img/sjtu/tuya.jpg","modified":0},{"_id":"source/img/sjtu/love.jpg","path":"img/sjtu/love.jpg","modified":0},{"_id":"source/img/sjtu/library_outside.jpg","path":"img/sjtu/library_outside.jpg","modified":0},{"_id":"source/img/sjtu/library.jpg","path":"img/sjtu/library.jpg","modified":0},{"_id":"source/img/sjtu/laker.jpg","path":"img/sjtu/laker.jpg","modified":0},{"_id":"source/img/sjtu/huxiaohe.jpg","path":"img/sjtu/huxiaohe.jpg","modified":0},{"_id":"source/img/sjtu/hehua.jpg","path":"img/sjtu/hehua.jpg","modified":0},{"_id":"source/img/sjtu/dom.jpg","path":"img/sjtu/dom.jpg","modified":0},{"_id":"source/img/react-native.png","path":"img/react-native.png","modified":0},{"_id":"source/img/myblog.png","path":"img/myblog.png","modified":0},{"_id":"source/img/me-and-blog.jpg","path":"img/me-and-blog.jpg","modified":0},{"_id":"source/img/leakcanary/project.png","path":"img/leakcanary/project.png","modified":0},{"_id":"source/img/interesting-curve/ring.gif","path":"img/interesting-curve/ring.gif","modified":0},{"_id":"source/img/interesting-curve/box.gif","path":"img/interesting-curve/box.gif","modified":0},{"_id":"source/img/interesting-curve/9.jpg","path":"img/interesting-curve/9.jpg","modified":0},{"_id":"source/img/interesting-curve/8.png","path":"img/interesting-curve/8.png","modified":0},{"_id":"source/img/interesting-curve/7.png","path":"img/interesting-curve/7.png","modified":0},{"_id":"source/img/interesting-curve/6.png","path":"img/interesting-curve/6.png","modified":0},{"_id":"source/img/interesting-curve/5.png","path":"img/interesting-curve/5.png","modified":0},{"_id":"source/img/interesting-curve/4.png","path":"img/interesting-curve/4.png","modified":0},{"_id":"source/img/interesting-curve/3.png","path":"img/interesting-curve/3.png","modified":0},{"_id":"source/img/interesting-curve/2.png","path":"img/interesting-curve/2.png","modified":0},{"_id":"source/img/interesting-curve/11.png","path":"img/interesting-curve/11.png","modified":0},{"_id":"source/img/interesting-curve/10.png","path":"img/interesting-curve/10.png","modified":0},{"_id":"source/img/interesting-curve/1.png","path":"img/interesting-curve/1.png","modified":0},{"_id":"source/img/host.png","path":"img/host.png","modified":0},{"_id":"source/img/hey_folks.jpg","path":"img/hey_folks.jpg","modified":0},{"_id":"source/img/hexo-directory.png","path":"img/hexo-directory.png","modified":0},{"_id":"source/img/gc/young_3.png","path":"img/gc/young_3.png","modified":0},{"_id":"source/img/gc/young_2.png","path":"img/gc/young_2.png","modified":0},{"_id":"source/img/gc/young_1.png","path":"img/gc/young_1.png","modified":0},{"_id":"source/img/gc/reachable.JPG","path":"img/gc/reachable.JPG","modified":0},{"_id":"source/img/gc/mark-sweep.png","path":"img/gc/mark-sweep.png","modified":0},{"_id":"source/img/gc/mark-compact.png","path":"img/gc/mark-compact.png","modified":0},{"_id":"source/img/gc/garbage.png","path":"img/gc/garbage.png","modified":0},{"_id":"source/img/gc/copying.png","path":"img/gc/copying.png","modified":0},{"_id":"source/img/fastblur/timeconsume_statisic.png","path":"img/fastblur/timeconsume_statisic.png","modified":0},{"_id":"source/img/fastblur/test_pic.jpeg","path":"img/fastblur/test_pic.jpeg","modified":0},{"_id":"source/img/fastblur/memory_50.png","path":"img/fastblur/memory_50.png","modified":0},{"_id":"source/img/fastblur/memory_300.png","path":"img/fastblur/memory_300.png","modified":0},{"_id":"source/img/fastblur/memory_200.png","path":"img/fastblur/memory_200.png","modified":0},{"_id":"source/img/fastblur/memory_20.png","path":"img/fastblur/memory_20.png","modified":0},{"_id":"source/img/fastblur/memory_100.png","path":"img/fastblur/memory_100.png","modified":0},{"_id":"source/img/fastblur/memory_10.png","path":"img/fastblur/memory_10.png","modified":0},{"_id":"source/img/fastblur/memory_1.png","path":"img/fastblur/memory_1.png","modified":0},{"_id":"source/img/fastblur/iosblur.jpg","path":"img/fastblur/iosblur.jpg","modified":0},{"_id":"source/img/fastblur/fastblur_50.png","path":"img/fastblur/fastblur_50.png","modified":0},{"_id":"source/img/fastblur/fastblur_35.png","path":"img/fastblur/fastblur_35.png","modified":0},{"_id":"source/img/fastblur/fastblur_20.png","path":"img/fastblur/fastblur_20.png","modified":0},{"_id":"source/img/fastblur/fastblur_100.png","path":"img/fastblur/fastblur_100.png","modified":0},{"_id":"source/img/fastblur/fastblur_10.png","path":"img/fastblur/fastblur_10.png","modified":0},{"_id":"source/img/fastblur/androidblur_2.png","path":"img/fastblur/androidblur_2.png","modified":0},{"_id":"source/img/fastblur/androidblur_1.png","path":"img/fastblur/androidblur_1.png","modified":0},{"_id":"source/img/dream.jpg","path":"img/dream.jpg","modified":0},{"_id":"source/img/classloader/order.png","path":"img/classloader/order.png","modified":0},{"_id":"source/img/annotation/warning.png","path":"img/annotation/warning.png","modified":0},{"_id":"source/img/annotation/no-warning.png","path":"img/annotation/no-warning.png","modified":0},{"_id":"source/img/Disqus评论系统.png","path":"img/Disqus评论系统.png","modified":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0}],"Cache":[{"_id":"source/_posts/30条Android开发建议.md","shasum":"ddaeb9456aa4310996ec887a501dd6d90924ff38","modified":1498191010000},{"_id":"source/_drafts/test-draft.md","shasum":"645b8b6fa6d3c339e688bbccd5648e2c4b0b2250","modified":1498100206000},{"_id":"source/_drafts/梦想升起的地方.md","shasum":"002bb2e4e78b680e316992ce7d5a7e107dd54151","modified":1498100206000},{"_id":"source/_posts/Hey folks.md","shasum":"6f66763ffdde3337e7b053a1c7935e319601fefe","modified":1498100206000},{"_id":"source/_posts/Java-技术之反射.md","shasum":"5bf2afc466895e77ec05c2632ac432b20cfb0a2f","modified":1498190632000},{"_id":"source/_posts/Java-技术之垃圾回收机制.md","shasum":"99448b5b9058a5fb7e9b33e7a53926f5a7e7b238","modified":1498100206000},{"_id":"source/_posts/Java的equals与hashcode对比分析.md","shasum":"48abdcdf9e0a8728ea8a7356c2f9d1fe1d29e617","modified":1498190648000},{"_id":"source/_posts/Java-技术之类加载机制.md","shasum":"e81178875538c09aaef3adafba45e8f5b363d60f","modified":1498100206000},{"_id":"source/_posts/Java-技术之注解-Annotation.md","shasum":"6018bc27f4339bb22d2b053cb1098b050dedfeb3","modified":1498100206000},{"_id":"source/_posts/一种快速毛玻璃虚化效果实现.md","shasum":"c527fd44a634648b69dd14418064008620386365","modified":1498191047000},{"_id":"source/_posts/Java里如何实现线程间通信？.md","shasum":"9a8c7b4dd40d1f276459dc996e3247a909af4024","modified":1498190641000},{"_id":"source/_posts/Walk-in-ShangHai.md","shasum":"d2dd0a8602c582aab2e3bbc3582f7a11bf170a18","modified":1498100206000},{"_id":"source/_posts/RxLifecycle源码解析－当Activity被destory时自动暂停网络请求.md","shasum":"c86aff136eea218b2d960b2d7c1d28a8c549058d","modified":1498190933000},{"_id":"source/_posts/交大－影.md","shasum":"addd3653f36080ed43338e74b6e9b1018849f522","modified":1498100206000},{"_id":"source/_posts/如何在一天之内搭建以你自己名字为域名的很cool的个人博客.md","shasum":"9c57b50613cd4a4eb0d47bc5b955c9f8f4c334ff","modified":1498191120000},{"_id":"source/_posts/今年之计.md","shasum":"8e34e5da97f8ffd3f0ae1d6611132c9e465278bd","modified":1498100206000},{"_id":"source/_posts/今年之计－2017.md","shasum":"c3ecd5e5280edf8e0b947b903b950063185334c8","modified":1498100206000},{"_id":"source/_posts/对未来个人技术博客的一些思考.md","shasum":"1bb96d249fcc7d7511cae97896c45c4d2d2f8e55","modified":1498190701000},{"_id":"source/_posts/带你学开源项目：Meizhi-Android之RxJava-Retrofit最佳实践.md","shasum":"18c20fc3d25e890a716a98a013d12c5eccc6c99e","modified":1498190972000},{"_id":"source/_posts/写给移动开发者的-React-Native-指南.md","shasum":"2721451b2ce569a61b86a8c9ee6df0db3db69c6e","modified":1498190740000},{"_id":"source/_posts/带你学开源项目：LeakCanary-如何检测-Activity-发生泄漏.md","shasum":"9c7a55ae273a2f04615b68b51087f94cd35c7572","modified":1498100206000},{"_id":"source/_posts/有趣的曲线在Android上的实现.md","shasum":"861234a5d77b918b52bcb9b6ba7161f9b80bcc8b","modified":1498191085000},{"_id":"source/_posts/梦想升起的地方.md","shasum":"b882947e37fa4652a1f21b8d9814853522524431","modified":1498100206000},{"_id":"source/_posts/我与代码的相知相遇.md","shasum":"4b12b5f6d2fe7cecbb2f69f025861072a69140ca","modified":1498100206000},{"_id":"source/_posts/带你学开源项目：OkHttp-自己动手实现okhttp.md","shasum":"7ad6531db09fd6c1ff38892271dde4bf8d6f3381","modified":1498190893000},{"_id":"source/_posts/干货-Glow-Android-优化实践.md","shasum":"262f9fc7d96bf9c9cc6276660368ea752aa7729e","modified":1498190823000},{"_id":"source/_posts/说一说博客.md","shasum":"20ecd5cd59cc340a72c98de692a02b230bd0640b","modified":1498100206000},{"_id":"source/_posts/计划清单.md","shasum":"02b446a7d7d71b77f8ae7019b55d50bfe40dcae7","modified":1498100206000},{"_id":"source/_posts/自己动手改造个人博客.md","shasum":"2bcf81ad69b3367eb029959f3ecd817a62bf0e9b","modified":1498100206000},{"_id":"source/_posts/独立全端开发的开源小作：简诗2-0.md","shasum":"8490a4b5ffe8ce1540c35284f0bceb99112e89e3","modified":1498190783000},{"_id":"source/guestbook/index.md","shasum":"a367851e76c80c3e94afb026f9f22ba373b054c6","modified":1498100206000},{"_id":"source/favicon.ico","shasum":"bb38565775f52af7d2f1f0187ed9972a7b4f09a1","modified":1498100206000},{"_id":"source/_posts/谈谈移动应用的安全性实践.md","shasum":"95a6aba51202c5740c68db0b96e643ce9c0a0a02","modified":1498190859000},{"_id":"source/img/classloader/order.png","shasum":"72db27f2434eb2336be54ce4f1bb6b56b868e514","modified":1498100206000},{"_id":"source/img/fastblur/memory_1.png","shasum":"14e397afa644bcf3dac11daabd988cca961ad5d8","modified":1498100206000},{"_id":"source/img/fastblur/memory_10.png","shasum":"935d56271c8d9304161cbcf5405b8a1ee0e87062","modified":1498100206000},{"_id":"source/img/fastblur/iosblur.jpg","shasum":"b7aad38c394a049c45cc60ddee04f916479d9ddc","modified":1498100206000},{"_id":"source/img/fastblur/memory_100.png","shasum":"3232f11fdac327635a82e22f009b776030c3bc89","modified":1498100206000},{"_id":"source/img/fastblur/memory_300.png","shasum":"89d3356a32b32962d364f83d5d82f6a8d7d83333","modified":1498100206000},{"_id":"source/img/fastblur/memory_20.png","shasum":"db301fb4b555e31a64a77f4b1286310ea267ca58","modified":1498100206000},{"_id":"source/img/fastblur/memory_200.png","shasum":"2a07afd6a2443e17461839dded0c279e8822d86b","modified":1498100206000},{"_id":"source/img/fastblur/memory_50.png","shasum":"62b94351e2d50d256e83ec7ec3a854e084bceade","modified":1498100206000},{"_id":"source/img/gc/garbage.png","shasum":"a872b666d4e1f0dc79f87c94489348acd17105d9","modified":1498100206000},{"_id":"source/img/gc/mark-compact.png","shasum":"3ac4b53d222ae7e53397e540d3b0e156d8c40933","modified":1498100206000},{"_id":"source/img/gc/reachable.JPG","shasum":"73f228750a79d0f7237126e7d279542e7b98b9f4","modified":1498100206000},{"_id":"source/img/gc/young_1.png","shasum":"019bd491d81551b3e7d5c20d854867b398385799","modified":1498100206000},{"_id":"source/img/gc/young_2.png","shasum":"ef5664777c4a15903db46bf86517782ba7e9f9fe","modified":1498100206000},{"_id":"source/img/gc/young_3.png","shasum":"dec153f322058693bb3aae00d55c47b850becdfe","modified":1498100206000},{"_id":"source/img/host.png","shasum":"e3cd6594465e22ed3b2a872e1b63212862097011","modified":1498100206000},{"_id":"source/img/interesting-curve/9.jpg","shasum":"02f5f09e3607c7421b0e3c35fb644cc1b32986a6","modified":1498100206000},{"_id":"source/img/leakcanary/project.png","shasum":"2fd900e5946d97c1be88e7e6d29d4ccdbffdde5f","modified":1498100207000},{"_id":"source/img/react-native.png","shasum":"6525ad1cf78d893dc9e55fe34d3ef6e95f524d3f","modified":1498100207000},{"_id":"source/resume/index.md","shasum":"12d2a667068089b3f76a7f63bedc282790a65297","modified":1498100208000},{"_id":"source/robots.txt","shasum":"6123a9417ecb039cb56a5b45c3e0450e30196e35","modified":1498100208000},{"_id":"source/tags/index.md","shasum":"c60250d4ddd679b6841a052c754d7756a2f0be52","modified":1498100208000},{"_id":"source/img/Disqus评论系统.png","shasum":"e313d38101a7a49f717ff8964c9d125eef3b284d","modified":1498100206000},{"_id":"source/img/annotation/no-warning.png","shasum":"1a92f328e0aa6a9a040859de0537dc1965ab7d7a","modified":1498100206000},{"_id":"source/img/annotation/warning.png","shasum":"7759b40d59373b8b5eb89ef83d20b8d9323a6af3","modified":1498100206000},{"_id":"source/img/fastblur/androidblur_2.png","shasum":"6ea9cc7a4ce5338c9de262e064b129829d2d877a","modified":1498100206000},{"_id":"source/img/fastblur/timeconsume_statisic.png","shasum":"bbff7161a608a488990613a9df5de6dcbf9162f9","modified":1498100206000},{"_id":"source/img/gc/copying.png","shasum":"d9b1e7e76d79d84971f842c294dc8124054e6472","modified":1498100206000},{"_id":"source/img/gc/mark-sweep.png","shasum":"5e352e55715e058db8ccd1012b4193f46c5fc378","modified":1498100206000},{"_id":"source/img/hexo-directory.png","shasum":"826cebfed96a6407234bf963baf6921c398195e1","modified":1498100206000},{"_id":"source/img/hey_folks.jpg","shasum":"b0a05bc1ed1669615ead2c5c9b7947f2b0d3968c","modified":1498100206000},{"_id":"source/img/interesting-curve/10.png","shasum":"901a86dc68fdb1e8c8d7e2c2ed30c03b73d565f8","modified":1498100206000},{"_id":"source/img/打赏.JPG","shasum":"42c50223599a722587c7fafa9ce0f6c7140e1405","modified":1498100208000},{"_id":"source/img/interesting-curve/3.png","shasum":"03d2eb9ef532d6b5606d89cf6c21748c317087ca","modified":1498100206000},{"_id":"source/img/fastblur/androidblur_1.png","shasum":"dfc1003232f2bc079ad507ad9fd29e37aba3dc5e","modified":1498100206000},{"_id":"source/img/fastblur/test_pic.jpeg","shasum":"19ca9f388ab26da2c071841baab3868bfba15569","modified":1498100206000},{"_id":"source/img/interesting-curve/4.png","shasum":"a54df53b47e84f7b452f8393b6b93ccb32721d08","modified":1498100206000},{"_id":"source/img/interesting-curve/8.png","shasum":"8556f52be9972440d4460018133ccb3a4dfbcf5e","modified":1498100206000},{"_id":"source/img/interesting-curve/5.png","shasum":"b3b915d72a8c9611c39b0bb12015f2757df2046f","modified":1498100206000},{"_id":"source/img/me-and-blog.jpg","shasum":"0dee97f7d6615ad884b262e82982db52b2a29358","modified":1498100207000},{"_id":"source/img/fastblur/fastblur_100.png","shasum":"04082f0c83d266bc4a9c5051632fefb46d5b6c34","modified":1498100206000},{"_id":"source/img/fastblur/fastblur_20.png","shasum":"0516ef3fc7dd353991431d0ce06e574a170a7b43","modified":1498100206000},{"_id":"source/img/fastblur/fastblur_35.png","shasum":"8ed56cf4cb45e436f3c79d3d2d70763cd81febae","modified":1498100206000},{"_id":"source/img/fastblur/fastblur_50.png","shasum":"db1b1ecd90c506c2fe3cb44e3bdac1167821cb0d","modified":1498100206000},{"_id":"themes/myNext/source/css/_common/_page/home.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498100208000},{"_id":"themes/myNext/source/css/_mixins/Mist.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498100208000},{"_id":"themes/myNext/source/css/_mixins/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498100208000},{"_id":"themes/myNext/source/css/_mixins/default.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498100208000},{"_id":"themes/myNext/source/css/_variables/custom.styl","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1498100208000},{"_id":"source/img/fastblur/fastblur_10.png","shasum":"8df2d8d76e47bed7600511197b4287bbd864946e","modified":1498100206000},{"_id":"source/img/interesting-curve/1.png","shasum":"6863d44d483aa141f977fb9d5a38af702b2cf231","modified":1498100206000},{"_id":"source/img/interesting-curve/2.png","shasum":"7fff0d4bfe989d410640542f73597c50288bf23a","modified":1498100206000},{"_id":"source/img/interesting-curve/11.png","shasum":"fd0038404392434605fb02142aa6a319f97351bd","modified":1498100206000},{"_id":"themes/myNext/bower.json","shasum":"4a53cab758c7d69be2ce773b2afff7dd962b7cb0","modified":1498100208000},{"_id":"themes/myNext/README.md","shasum":"e170117386e13c5296748f20e4d07f6db46776cc","modified":1498100217000},{"_id":"themes/myNext/README.en.md","shasum":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1498100208000},{"_id":"themes/myNext/_config.yml","shasum":"234abf6de60b41bc7a7d009d2f805770e2912229","modified":1498100208000},{"_id":"themes/myNext/languages/en.yml","shasum":"f57623e47f533c8d53d859628fa6a368a5298a00","modified":1498100208000},{"_id":"themes/myNext/languages/fr-FR.yml","shasum":"2cec663601ac8d178e97aee91d967fa99a95ad4e","modified":1498100208000},{"_id":"themes/myNext/languages/de.yml","shasum":"7a8de0e5665c52a1bf168c1e7dd222c8a74fb0ab","modified":1498100208000},{"_id":"themes/myNext/languages/default.yml","shasum":"f57623e47f533c8d53d859628fa6a368a5298a00","modified":1498100208000},{"_id":"themes/myNext/languages/pt.yml","shasum":"8e38fdf3a5232b428d2e4a641666dbabab87c3d1","modified":1498100208000},{"_id":"themes/myNext/languages/ru.yml","shasum":"1d1b158f9cff1b38978086043f299b3fc590e007","modified":1498100208000},{"_id":"themes/myNext/languages/zh-Hans.yml","shasum":"134d3bc29dd472db32838947aab9f0f51846df82","modified":1498100208000},{"_id":"themes/myNext/languages/zh-hk.yml","shasum":"248b88c825fde8e35839f3954d38df4e72a0537c","modified":1498100208000},{"_id":"themes/myNext/layout/_layout.swig","shasum":"d9e4b92f35ee3e99c4f626b88ccf6d4c371dd0de","modified":1498100208000},{"_id":"themes/myNext/languages/zh-tw.yml","shasum":"42ba1d0c6b6026ba1e613ad11efb75432a8132ac","modified":1498100208000},{"_id":"themes/myNext/layout/_macro/post-collapse.swig","shasum":"9032ae9056cb19b4c2d069d66ead7abf828f9922","modified":1498100208000},{"_id":"themes/myNext/layout/_partials/duoshuo-hot-articles.swig","shasum":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1498100208000},{"_id":"themes/myNext/layout/_macro/post.swig","shasum":"a4f810300f839529979905f9a504f42e8da46bb3","modified":1498100208000},{"_id":"themes/myNext/layout/_macro/sidebar.swig","shasum":"88e179ff660874135b17d0febc91d04749053a73","modified":1498100208000},{"_id":"themes/myNext/layout/_partials/comments.swig","shasum":"a612a4eca51ffc87b53a5470b451071a7ad6a031","modified":1498100208000},{"_id":"themes/myNext/layout/_partials/head.swig","shasum":"359729ac487afc50b7697831493a54f27f848105","modified":1498100208000},{"_id":"themes/myNext/layout/_partials/footer.swig","shasum":"807a6317e23b2f2d4b1a09f42f89456a3c00071b","modified":1498100208000},{"_id":"themes/myNext/layout/_partials/header.swig","shasum":"476333c49a1e7e0402a68a826f67527ac258969d","modified":1498100208000},{"_id":"themes/myNext/layout/_partials/github-comments.swig","shasum":"957e5701d024c3efcb8cddef3dcc61ae15428f9b","modified":1498100208000},{"_id":"themes/myNext/layout/_partials/old-browsers.swig","shasum":"dbbfea810bf3a2ed9c83b9a6683037175aacfc67","modified":1498100208000},{"_id":"themes/myNext/layout/_partials/pagination.swig","shasum":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1498100208000},{"_id":"themes/myNext/layout/_partials/search/tinysou.swig","shasum":"eefe2388ff3d424694045eda21346989b123977c","modified":1498100208000},{"_id":"themes/myNext/layout/_partials/share/duoshuo_share.swig","shasum":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1498100208000},{"_id":"themes/myNext/layout/_partials/search/swiftype.swig","shasum":"00c2b49f6289198b0b2b4e157e4ee783277f32a7","modified":1498100208000},{"_id":"themes/myNext/layout/_partials/share/jiathis.swig","shasum":"63315fcf210799f894208c9f512737096df84962","modified":1498100208000},{"_id":"themes/myNext/layout/_scripts/analytics/baidu-analytics.swig","shasum":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1498100208000},{"_id":"themes/myNext/layout/_scripts/analytics/facebook-sdk.swig","shasum":"334176d838ee528e58468d8bc74ff3a6d3f25b2b","modified":1498100208000},{"_id":"themes/myNext/layout/_partials/search.swig","shasum":"64f14da26792a17bc27836c4e9d83190175f36e6","modified":1498100208000},{"_id":"themes/myNext/layout/_scripts/analytics/google-analytics.swig","shasum":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1498100208000},{"_id":"themes/myNext/layout/_scripts/baidushare.swig","shasum":"d726361945437cf6e48067b3dd041b7e36e98d85","modified":1498100208000},{"_id":"themes/myNext/layout/_scripts/comments/disqus.swig","shasum":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1498100208000},{"_id":"themes/myNext/layout/_scripts/bootstrap.scrollspy.swig","shasum":"85295f126836b95f0837d03e58228bb3cf8c4490","modified":1498100208000},{"_id":"themes/myNext/layout/_scripts/analytics.swig","shasum":"33ca06b9bd9a15a19432d5396b85bd319f017319","modified":1498100208000},{"_id":"themes/myNext/layout/_scripts/fancy-box.swig","shasum":"41b4ff1446060c88c33bf666a32277dcf12129f0","modified":1498100208000},{"_id":"themes/myNext/layout/_scripts/comments/duoshuo.swig","shasum":"44e3d567fd49c2a093f4a0a8af9f00542c935a58","modified":1498100208000},{"_id":"themes/myNext/layout/_scripts/mathjax.swig","shasum":"df03220eb8526e17dc9c9f17780c2d6699367181","modified":1498100208000},{"_id":"themes/myNext/layout/_scripts/helpers.swig","shasum":"0c7c65454e236c294be78291449bbb608c7c09f1","modified":1498100208000},{"_id":"themes/myNext/layout/_scripts/motion.swig","shasum":"0d9761e3b1bb9e666ccc71bad59f035deb5a88c6","modified":1498100208000},{"_id":"themes/myNext/layout/_scripts/tinysou.swig","shasum":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1498100208000},{"_id":"themes/myNext/layout/archive.swig","shasum":"0c3ce594759f347ea90a4ce592a7a18e2ae4cc5c","modified":1498100208000},{"_id":"themes/myNext/layout/index.swig","shasum":"9224ad59d0f0d7d658b384d181100da742d6d097","modified":1498100208000},{"_id":"themes/myNext/layout/category.swig","shasum":"d6b3e1dc5e0b8deade9a084c463126e70188ee9b","modified":1498100208000},{"_id":"themes/myNext/layout/page.swig","shasum":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1498100208000},{"_id":"themes/myNext/layout/_scripts/pages/post-details.swig","shasum":"7a34b02808f144ee4a11032ae3a149eb634a7e82","modified":1498100208000},{"_id":"themes/myNext/layout/post.swig","shasum":"a84457e8ced46e63bc7a8a9e0541a6ba53122a92","modified":1498100208000},{"_id":"themes/myNext/scripts/filters/sticky.js","shasum":"6b1ea0c09105352813357d0fff4e1d3f4c821fa3","modified":1498100208000},{"_id":"themes/myNext/scripts/merge-configs.js","shasum":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1498100208000},{"_id":"themes/myNext/scripts/related_posts.js","shasum":"3cfae2098027d1dd7db0ff511d5cb2a9c7299b7e","modified":1498100208000},{"_id":"themes/myNext/layout/tag.swig","shasum":"aab44af54fcbc66fea4ad12b2767ffca3eadd451","modified":1498100208000},{"_id":"themes/myNext/scripts/tags/center-quote.js","shasum":"535fc542781021c4326dec24d8495cbb1387634a","modified":1498100208000},{"_id":"themes/myNext/scripts/tags/full-image.js","shasum":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1498100208000},{"_id":"themes/myNext/scripts/tags/group-pictures.js","shasum":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1498100208000},{"_id":"themes/myNext/source/404.html","shasum":"92155185adcc84a9f4e7035a514cd622c379ae89","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_component/blockquote-center.styl","shasum":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_component/back-to-top.styl","shasum":"88cd66910260006aa8e9e795df4948d4b67bfa11","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_component/buttons.styl","shasum":"81063e0979f04a0f9af37f321d7321dda9abf593","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_component/comments.styl","shasum":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_component/group-pictures.styl","shasum":"1ee40743000173495728855f734081eb2b6167cc","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_component/gallery.styl","shasum":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_component/jiathis.styl","shasum":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_component/pagination.styl","shasum":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_component/duoshuo.styl","shasum":"2d2da815ab0981b219ea1973a4aedede48801411","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_component/posts-collapse.styl","shasum":"6750b61236eb359028da8f2c4765f7c89b03dc9a","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_component/posts-type.styl","shasum":"40b593134bf96d1d6095b3439d47820659d7f10b","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_component/posts-expand.styl","shasum":"672d5fa7e5b7642d86a4bda176b501508b54860f","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_component/posts.styl","shasum":"b05ac51dd266d27f12e39e59a94383fe6474b7b3","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_component/tag-cloud.styl","shasum":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_core/helpers.styl","shasum":"d339d114e52a9abbc797ec236a8a770c29e288a6","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_core/base.styl","shasum":"388aa7c69c97728c64941db01e0f29a88837120c","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_core/normalize.styl","shasum":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_core/scaffolding.styl","shasum":"1f8acb3331300eec696a09e7859e11f191e16d7f","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_core/tables.styl","shasum":"5f766cf26f966dbf9dcfe681f40ab9032e3e8a08","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_fonts/icon-feather.styl","shasum":"80413afacfa656322100ce1900fed1ebcd8f8f44","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_fonts/icon-default.styl","shasum":"8b809aef383bebaeb3f282b47675f3a364ce3569","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_fonts/icon-fifty-shades.styl","shasum":"249f75bafa26b99d272352c0646e7497ea680b39","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_fonts/icon-font.styl","shasum":"ec3f86739bede393cafcd3e31052c01115ae20d6","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_fonts/icon-linecons.styl","shasum":"9cdbedb3627ac941cfb063b152abe5a75c3c699a","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_page/archive.styl","shasum":"dff879f55ca65fa79c07e9098719e53eeea7ac88","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_page/categories.styl","shasum":"4f696a2eaeee2f214adcf273eab25c62a398077a","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_page/post-detail.styl","shasum":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_section/footer.styl","shasum":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_section/body.styl","shasum":"ca1a4766cbe25baac757c6b47a4858d221afdc40","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_section/header.styl","shasum":"a6aa8a56f9f645ae5a76a1034f79adf73b053aa0","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_section/media.styl","shasum":"fa9809d2ecc753cf32f70803c1d0821c405211f4","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_section/layout.styl","shasum":"03ae7b808dde9065412968aa69916162e790455d","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_vendor/highlight/highlight.styl","shasum":"6242be4307a3b3dafc14e556f51c8875c41a1ddd","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_section/sidebar.styl","shasum":"bc106c3e759cd752c2b4c53ac27bc5ef5e3b18ea","modified":1498100208000},{"_id":"themes/myNext/source/css/_common/_vendor/highlight/theme.styl","shasum":"ae19721ceee5ba460e131cb2427dae3c1ff39d6f","modified":1498100208000},{"_id":"themes/myNext/source/css/_custom/custom.styl","shasum":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1498100208000},{"_id":"themes/myNext/source/css/_schemes/Mist/_base.styl","shasum":"d50c2a9ae363d26ed2e9bc226a9dc7abeb9ace1b","modified":1498100208000},{"_id":"themes/myNext/source/css/_mixins/base.styl","shasum":"4e49707c99c8bbcfa0a607dfdaff0fbb7dffd2a3","modified":1498100208000},{"_id":"themes/myNext/source/css/_schemes/Mist/_logo.styl","shasum":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1498100208000},{"_id":"themes/myNext/source/css/_schemes/Mist/_header.styl","shasum":"1631a430655eadb485574d1a9bedd49460988b11","modified":1498100208000},{"_id":"themes/myNext/source/css/_schemes/Mist/_posts-expanded.styl","shasum":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1498100208000},{"_id":"themes/myNext/source/css/_schemes/Mist/_menu.styl","shasum":"5a8036fc61207ca0fe38c9782ed2f686fbf764be","modified":1498100208000},{"_id":"themes/myNext/source/css/_schemes/default/_logo.styl","shasum":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1498100208000},{"_id":"themes/myNext/source/css/_schemes/Mist/index.styl","shasum":"fc7d96b897290dbd93bc8c515a2058fc4c374ea7","modified":1498100208000},{"_id":"themes/myNext/source/css/_schemes/default/_menu.styl","shasum":"4bba29cece65ffc5122f4e052063dea4439fe4ae","modified":1498100208000},{"_id":"themes/myNext/source/css/_variables/Mist.styl","shasum":"9f8791860cc1ca724d2dfe609e8cd6abc44d6926","modified":1498100208000},{"_id":"themes/myNext/source/css/_schemes/default/index.styl","shasum":"159464cb8a7e01e32db9ec70dec391ec70a72f9c","modified":1498100208000},{"_id":"themes/myNext/source/css/_variables/base.styl","shasum":"f532d6b0f961a8f3867c06e132233286f110180d","modified":1498100208000},{"_id":"themes/myNext/source/css/_schemes/default/_search.styl","shasum":"c524bccdc554349106d1c8be9c3f275d4c0d4281","modified":1498100208000},{"_id":"themes/myNext/source/css/main.styl","shasum":"56dacee56c5eaa4b2676d196452314fb50f758aa","modified":1498100208000},{"_id":"themes/myNext/source/css/_variables/default.styl","shasum":"8ec3307fe42d738b1bbda4b6419d0995f5560222","modified":1498100208000},{"_id":"themes/myNext/source/images/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1498100208000},{"_id":"themes/myNext/source/images/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1498100208000},{"_id":"themes/myNext/source/images/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1498100208000},{"_id":"themes/myNext/source/images/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1498100208000},{"_id":"themes/myNext/source/images/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1498100208000},{"_id":"themes/myNext/source/images/loading.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1498100208000},{"_id":"themes/myNext/source/images/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1498100208000},{"_id":"themes/myNext/source/images/placeholder.gif","shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1498100208000},{"_id":"themes/myNext/source/images/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1498100208000},{"_id":"themes/myNext/source/js/bootstrap.js","shasum":"f9b637b6d064f728d7dc2b6b5058a006a4454299","modified":1498100208000},{"_id":"themes/myNext/source/images/quote-r.svg","shasum":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1498100208000},{"_id":"themes/myNext/source/js/bootstrap.scrollspy.js","shasum":"ae7bdce88b515aade4eea8bf7407eec458bcd625","modified":1498100208000},{"_id":"themes/myNext/source/images/searchicon.png","shasum":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1498100208000},{"_id":"themes/myNext/source/images/quote-l.svg","shasum":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1498100208000},{"_id":"themes/myNext/source/js/fancy-box.js","shasum":"b5fa638ed371b5f658b0826ec4afee25d9986ef2","modified":1498100208000},{"_id":"themes/myNext/source/js/hook-duoshuo.js","shasum":"ccb32e0a1acf798337c9697e1aab5484b52f9df4","modified":1498100208000},{"_id":"themes/myNext/source/js/motion.js","shasum":"b4132517fe499538ad725094593fb7ead8c04bf7","modified":1498100208000},{"_id":"themes/myNext/source/js/ua-parser.min.js","shasum":"1148fa2bcb8b2e40c31e5f597bf794a57369a2e6","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fancybox/source/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1498100208000},{"_id":"themes/myNext/source/js/helpers.js","shasum":"c15216ef897334362789ba37464298948b2eef95","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fancybox/source/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","shasum":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","shasum":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","shasum":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fancybox/source/jquery.fancybox.css","shasum":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fastclick/README.md","shasum":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fastclick/LICENSE","shasum":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fancybox/source/jquery.fancybox.pack.js","shasum":"53360764b429c212f424399384417ccc233bb3be","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fastclick/bower.json","shasum":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fancybox/source/jquery.fancybox.js","shasum":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fastclick/lib/fastclick.min.js","shasum":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1498100208000},{"_id":"themes/myNext/source/vendors/fastclick/lib/fastclick.js","shasum":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1498100208000},{"_id":"themes/myNext/source/vendors/font-awesome/HELP-US-OUT.txt","shasum":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1498100208000},{"_id":"themes/myNext/source/vendors/font-awesome/bower.json","shasum":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1498100208000},{"_id":"themes/myNext/source/vendors/font-awesome/css/font-awesome.css.map","shasum":"0189d278706509412bac4745f96c83984e1d59f4","modified":1498100208000},{"_id":"themes/myNext/source/vendors/font-awesome/css/font-awesome.min.css","shasum":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1498100208000},{"_id":"themes/myNext/source/vendors/font-awesome/css/font-awesome.css","shasum":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1498100208000},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","shasum":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1498100208000},{"_id":"themes/myNext/source/vendors/jquery_lazyload/CONTRIBUTING.md","shasum":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1498100208000},{"_id":"themes/myNext/source/vendors/jquery_lazyload/README.md","shasum":"895d50fa29759af7835256522e9dd7dac597765c","modified":1498100208000},{"_id":"themes/myNext/source/vendors/jquery_lazyload/bower.json","shasum":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1498100208000},{"_id":"themes/myNext/source/vendors/jquery_lazyload/jquery.scrollstop.js","shasum":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1498100208000},{"_id":"themes/myNext/source/vendors/jquery_lazyload/jquery.lazyload.js","shasum":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1498100208000},{"_id":"themes/myNext/source/vendors/velocity/bower.json","shasum":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1498100208000},{"_id":"themes/myNext/source/vendors/velocity/velocity.min.js","shasum":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1498100208000},{"_id":"themes/myNext/source/vendors/velocity/velocity.ui.min.js","shasum":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1498100208000},{"_id":"themes/myNext/source/vendors/velocity/velocity.ui.js","shasum":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1498100208000},{"_id":"source/img/interesting-curve/6.png","shasum":"4f4156cb8c4c0199120511ff407218b20affb020","modified":1498100206000},{"_id":"themes/myNext/test/helpers.js","shasum":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1498100208000},{"_id":"themes/myNext/test/intern.js","shasum":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1498100208000},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","shasum":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1498100208000},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/FontAwesome.otf","shasum":"0112e96f327d413938d37c1693806f468ffdbace","modified":1498100208000},{"_id":"themes/myNext/source/vendors/jquery/index.js","shasum":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1498100208000},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","shasum":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1498100208000},{"_id":"source/img/interesting-curve/7.png","shasum":"c71371378f0f51e3259ab849216fca60b1d466cf","modified":1498100206000},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","shasum":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1498100208000},{"_id":"source/img/myblog.png","shasum":"9239c9f1baa1d5073c98d07186fc791b2b466203","modified":1498100207000},{"_id":"themes/myNext/source/vendors/velocity/velocity.js","shasum":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1498100208000},{"_id":"themes/myNext/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","shasum":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1498100208000},{"_id":"source/img/interesting-curve/box.gif","shasum":"bea87ba30f13bc86cf3f141cf4d9dc7bb81dd002","modified":1498100206000},{"_id":"source/img/interesting-curve/ring.gif","shasum":"b64e0003275db78257ed4e4df5f4898786fea760","modified":1498100206000},{"_id":"source/img/sjtu/library.jpg","shasum":"1f34b819a61c47596df0bbf5ba3c8fdb3c6edeb6","modified":1498100207000},{"_id":"source/img/sjtu/dom.jpg","shasum":"1414a03d5f7485b0627753581c611b84fa517729","modified":1498100207000},{"_id":"source/img/sjtu/laker.jpg","shasum":"ad8fe5ecb4c54a6a021c6c791c5db95185f8774b","modified":1498100207000},{"_id":"source/img/sjtu/tuya.jpg","shasum":"7c0ebc7343b8b67cb236cdaa3b04500b786f8648","modified":1498100207000},{"_id":"source/img/sjtu/huxiaohe.jpg","shasum":"a98b2882bdbff529ac1ed52cab05b954839c1eff","modified":1498100207000},{"_id":"source/img/dream.jpg","shasum":"d208197b8979b1737c532fb70ff02b6213aa2679","modified":1498100206000},{"_id":"source/img/sjtu/library_outside.jpg","shasum":"0accbf6acb3d34c9c1fd85ba06638c7cef9c6a39","modified":1498100207000},{"_id":"source/img/sjtu/love.jpg","shasum":"0f6157c87ed87542d84f35270f15d45cfd3483cb","modified":1498100207000},{"_id":"source/img/walk_in_sh/18.JPG","shasum":"2303528eedd3f5e6e496cf746763d8a190fe63e3","modified":1498100207000},{"_id":"source/img/walk_in_sh/1.JPG","shasum":"d4511cba8d8f43d7e56e6d70d8d31a1a8a0403c2","modified":1498100207000},{"_id":"source/img/walk_in_sh/15.JPG","shasum":"1764912039c38d842a4fcd1ac78ed5d30700476d","modified":1498100207000},{"_id":"source/img/walk_in_sh/2.JPG","shasum":"80918b9291f2878fa61acec82b18ff7843c1bfbc","modified":1498100207000},{"_id":"source/img/walk_in_sh/4.JPG","shasum":"1cb83df4a9e279460c587d63ed7fdfb0d1cfc2fd","modified":1498100207000},{"_id":"source/img/walk_in_sh/16.JPG","shasum":"0b25b734a0123f14ecce4e297d05b7be4be208eb","modified":1498100207000},{"_id":"source/img/walk_in_sh/17.JPG","shasum":"2881964ef4f8819c1bfa8d9295c4da5e4d06ef3e","modified":1498100207000},{"_id":"source/img/walk_in_sh/11.JPG","shasum":"f9c70fbb51fc368ec4f73b33a2e8183aa9f42cc9","modified":1498100207000},{"_id":"source/img/sjtu/hehua.jpg","shasum":"22559174b84cad1734e19b4765ade413ee13e438","modified":1498100207000},{"_id":"source/img/walk_in_sh/14.JPG","shasum":"908aa369c07dd2400753f9965c071a25737f6fcd","modified":1498100207000},{"_id":"source/img/walk_in_sh/7.JPG","shasum":"2c2ca93821bf5d6b9745db4bedae8897a947e199","modified":1498100207000},{"_id":"source/img/walk_in_sh/6.JPG","shasum":"9c519bc65f8109c33211b55676cc316e31c4cbfd","modified":1498100207000},{"_id":"source/img/walk_in_sh/10.JPG","shasum":"c3e4831bfecdb530810d1ff9be63d5463a6032ba","modified":1498100207000},{"_id":"source/img/walk_in_sh/3.JPG","shasum":"ace3a8905bc963f0a832b614703c9d3394be1388","modified":1498100207000},{"_id":"source/img/walk_in_sh/5.JPG","shasum":"2df1179b56171b441705c5a47223f86a55921a47","modified":1498100207000},{"_id":"source/img/walk_in_sh/9.JPG","shasum":"a190ede0354851f8ea38debf9ed2a59a464bc9ac","modified":1498100208000},{"_id":"source/img/walk_in_sh/13.JPG","shasum":"7fac8bf1b882bfb14222a2932a066bd282f7bd5f","modified":1498100207000},{"_id":"source/img/walk_in_sh/12.JPG","shasum":"863952f7a1fe8bd95039fd8670e1653fec284554","modified":1498100207000},{"_id":"source/img/walk_in_sh/8.JPG","shasum":"0de6904c8ee70e390459aa7f1f412778fedfe92b","modified":1498100207000},{"_id":"public/vendors/velocity/velocity.ui.min.js","modified":1498191143353,"shasum":"ed5e534cd680a25d8d14429af824f38a2c7d9908"},{"_id":"public/vendors/velocity/velocity.ui.js","modified":1498191143359,"shasum":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df"},{"_id":"public/vendors/velocity/velocity.min.js","modified":1498191143361,"shasum":"2f1afadc12e4cf59ef3b405308d21baa97e739c6"},{"_id":"public/vendors/velocity/velocity.js","modified":1498191143363,"shasum":"9f08181baea0cc0e906703b7e5df9111b9ef3373"},{"_id":"public/vendors/velocity/bower.json","modified":1498191143366,"shasum":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409"},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","modified":1498191143367,"shasum":"0e9a81785a011c98be5ea821a8ed7d411818cfd1"},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","modified":1498191143369,"shasum":"481fd478650e12b67c201a0ea41e92743f8b45a3"},{"_id":"public/vendors/jquery_lazyload/bower.json","modified":1498191143370,"shasum":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53"},{"_id":"public/vendors/jquery_lazyload/README.html","modified":1498191143390,"shasum":"c593e16f0d63d24b5d3933f3b9297884867ce4a0"},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","modified":1498191143396,"shasum":"bf8e477ee2d81833cff12572a8a5f61abffc187c"},{"_id":"public/vendors/jquery/index.js","modified":1498191143399,"shasum":"41b4bfbaa96be6d1440db6e78004ade1c134e276"},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1498191143404,"shasum":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea"},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1498191143407,"shasum":"507970402e328b2baeb05bde73bf9ded4e2c3a2d"},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1498191143410,"shasum":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9"},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1498191143414,"shasum":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824"},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1498191143416,"shasum":"b3c2f08e73320135b69c23a3908b87a12053a2f6"},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","modified":1498191143418,"shasum":"0112e96f327d413938d37c1693806f468ffdbace"},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","modified":1498191143421,"shasum":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22"},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","modified":1498191143422,"shasum":"0189d278706509412bac4745f96c83984e1d59f4"},{"_id":"public/vendors/font-awesome/css/font-awesome.css","modified":1498191143424,"shasum":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7"},{"_id":"public/vendors/font-awesome/bower.json","modified":1498191143425,"shasum":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad"},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","modified":1498191143427,"shasum":"69a4c537d167b68a0ccf1c6febd138aeffca60d6"},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","modified":1498191143429,"shasum":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18"},{"_id":"public/vendors/fastclick/lib/fastclick.js","modified":1498191143430,"shasum":"06cef196733a710e77ad7e386ced6963f092dc55"},{"_id":"public/vendors/fastclick/bower.json","modified":1498191143431,"shasum":"4dcecf83afddba148464d5339c93f6d0aa9f42e9"},{"_id":"public/vendors/fastclick/README.html","modified":1498191143437,"shasum":"5bef8b8758435bc08129f6d374740527a6a9b942"},{"_id":"public/vendors/fastclick/LICENSE","modified":1498191143445,"shasum":"dcd5b6b43095d9e90353a28b09cb269de8d4838e"},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","modified":1498191143448,"shasum":"53360764b429c212f424399384417ccc233bb3be"},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","modified":1498191143451,"shasum":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4"},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","modified":1498191143452,"shasum":"5f163444617b6cf267342f06ac166a237bb62df9"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1498191143454,"shasum":"53e194f4a72e649c04fb586dd57762b8c022800b"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1498191143456,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1498191143457,"shasum":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1498191143458,"shasum":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876"},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1498191143460,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1498191143462,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","modified":1498191143463,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","modified":1498191143466,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","modified":1498191143470,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","modified":1498191143472,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","modified":1498191143474,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/vendors/fancybox/source/blank.gif","modified":1498191143476,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/js/ua-parser.min.js","modified":1498191143477,"shasum":"1148fa2bcb8b2e40c31e5f597bf794a57369a2e6"},{"_id":"public/js/motion.js","modified":1498191143478,"shasum":"b4132517fe499538ad725094593fb7ead8c04bf7"},{"_id":"public/js/hook-duoshuo.js","modified":1498191143479,"shasum":"eedaf52377991728f1e3e94f2bc4bf23ec41ecea"},{"_id":"public/js/helpers.js","modified":1498191143480,"shasum":"c15216ef897334362789ba37464298948b2eef95"},{"_id":"public/js/fancy-box.js","modified":1498191143482,"shasum":"b5fa638ed371b5f658b0826ec4afee25d9986ef2"},{"_id":"public/js/bootstrap.scrollspy.js","modified":1498191143483,"shasum":"ae7bdce88b515aade4eea8bf7407eec458bcd625"},{"_id":"public/js/bootstrap.js","modified":1498191143485,"shasum":"f9b637b6d064f728d7dc2b6b5058a006a4454299"},{"_id":"public/images/searchicon.png","modified":1498191143486,"shasum":"67727a6a969be0b2659b908518fa6706eed307b8"},{"_id":"public/images/quote-r.svg","modified":1498191143487,"shasum":"e60ae504f9d99b712c793c3740c6b100d057d4ec"},{"_id":"public/images/quote-l.svg","modified":1498191143488,"shasum":"94e870b4c8c48da61d09522196d4dd40e277a98f"},{"_id":"public/images/placeholder.gif","modified":1498191143491,"shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b"},{"_id":"public/images/loading.gif","modified":1498191143493,"shasum":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b"},{"_id":"public/images/cc-zero.svg","modified":1498191143496,"shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030"},{"_id":"public/images/cc-by.svg","modified":1498191143498,"shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e"},{"_id":"public/images/cc-by-sa.svg","modified":1498191143500,"shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e"},{"_id":"public/images/cc-by-nd.svg","modified":1498191143502,"shasum":"c563508ce9ced1e66948024ba1153400ac0e0621"},{"_id":"public/images/cc-by-nc.svg","modified":1498191143504,"shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7"},{"_id":"public/images/cc-by-nc-sa.svg","modified":1498191143505,"shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e"},{"_id":"public/images/cc-by-nc-nd.svg","modified":1498191143507,"shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564"},{"_id":"public/css/main.css","modified":1498191143934,"shasum":"ec93b977d87358d061079806f2fb3180f31e0148"},{"_id":"public/404.html","modified":1498191144029,"shasum":"92155185adcc84a9f4e7035a514cd622c379ae89"},{"_id":"public/robots.txt","modified":1498191144030,"shasum":"6123a9417ecb039cb56a5b45c3e0450e30196e35"},{"_id":"public/img/打赏.JPG","modified":1498191144032,"shasum":"42c50223599a722587c7fafa9ce0f6c7140e1405"},{"_id":"public/img/walk_in_sh/9.JPG","modified":1498191144047,"shasum":"a190ede0354851f8ea38debf9ed2a59a464bc9ac"},{"_id":"public/img/walk_in_sh/8.JPG","modified":1498191144088,"shasum":"0de6904c8ee70e390459aa7f1f412778fedfe92b"},{"_id":"public/img/walk_in_sh/7.JPG","modified":1498191144110,"shasum":"2c2ca93821bf5d6b9745db4bedae8897a947e199"},{"_id":"public/img/walk_in_sh/6.JPG","modified":1498191144128,"shasum":"9c519bc65f8109c33211b55676cc316e31c4cbfd"},{"_id":"public/img/walk_in_sh/5.JPG","modified":1498191144147,"shasum":"2df1179b56171b441705c5a47223f86a55921a47"},{"_id":"public/img/walk_in_sh/4.JPG","modified":1498191144170,"shasum":"1cb83df4a9e279460c587d63ed7fdfb0d1cfc2fd"},{"_id":"public/img/walk_in_sh/3.JPG","modified":1498191144188,"shasum":"ace3a8905bc963f0a832b614703c9d3394be1388"},{"_id":"public/img/walk_in_sh/2.JPG","modified":1498191144205,"shasum":"80918b9291f2878fa61acec82b18ff7843c1bfbc"},{"_id":"public/img/walk_in_sh/18.JPG","modified":1498191144220,"shasum":"2303528eedd3f5e6e496cf746763d8a190fe63e3"},{"_id":"public/img/walk_in_sh/17.JPG","modified":1498191144239,"shasum":"2881964ef4f8819c1bfa8d9295c4da5e4d06ef3e"},{"_id":"public/img/walk_in_sh/16.JPG","modified":1498191144264,"shasum":"0b25b734a0123f14ecce4e297d05b7be4be208eb"},{"_id":"public/img/walk_in_sh/15.JPG","modified":1498191144280,"shasum":"1764912039c38d842a4fcd1ac78ed5d30700476d"},{"_id":"public/img/walk_in_sh/14.JPG","modified":1498191144295,"shasum":"908aa369c07dd2400753f9965c071a25737f6fcd"},{"_id":"public/img/walk_in_sh/13.JPG","modified":1498191144320,"shasum":"7fac8bf1b882bfb14222a2932a066bd282f7bd5f"},{"_id":"public/img/walk_in_sh/12.JPG","modified":1498191144337,"shasum":"863952f7a1fe8bd95039fd8670e1653fec284554"},{"_id":"public/img/walk_in_sh/11.JPG","modified":1498191144356,"shasum":"f9c70fbb51fc368ec4f73b33a2e8183aa9f42cc9"},{"_id":"public/img/walk_in_sh/10.JPG","modified":1498191144374,"shasum":"c3e4831bfecdb530810d1ff9be63d5463a6032ba"},{"_id":"public/img/walk_in_sh/1.JPG","modified":1498191144488,"shasum":"d4511cba8d8f43d7e56e6d70d8d31a1a8a0403c2"},{"_id":"public/img/sjtu/tuya.jpg","modified":1498191144508,"shasum":"7c0ebc7343b8b67cb236cdaa3b04500b786f8648"},{"_id":"public/img/sjtu/love.jpg","modified":1498191144527,"shasum":"0f6157c87ed87542d84f35270f15d45cfd3483cb"},{"_id":"public/img/sjtu/library_outside.jpg","modified":1498191144554,"shasum":"0accbf6acb3d34c9c1fd85ba06638c7cef9c6a39"},{"_id":"public/img/sjtu/library.jpg","modified":1498191144574,"shasum":"1f34b819a61c47596df0bbf5ba3c8fdb3c6edeb6"},{"_id":"public/img/sjtu/laker.jpg","modified":1498191144592,"shasum":"ad8fe5ecb4c54a6a021c6c791c5db95185f8774b"},{"_id":"public/img/sjtu/huxiaohe.jpg","modified":1498191144619,"shasum":"a98b2882bdbff529ac1ed52cab05b954839c1eff"},{"_id":"public/img/sjtu/hehua.jpg","modified":1498191144638,"shasum":"22559174b84cad1734e19b4765ade413ee13e438"},{"_id":"public/img/sjtu/dom.jpg","modified":1498191144658,"shasum":"1414a03d5f7485b0627753581c611b84fa517729"},{"_id":"public/img/react-native.png","modified":1498191144664,"shasum":"6525ad1cf78d893dc9e55fe34d3ef6e95f524d3f"},{"_id":"public/img/myblog.png","modified":1498191144670,"shasum":"9239c9f1baa1d5073c98d07186fc791b2b466203"},{"_id":"public/img/me-and-blog.jpg","modified":1498191144676,"shasum":"0dee97f7d6615ad884b262e82982db52b2a29358"},{"_id":"public/img/leakcanary/project.png","modified":1498191144677,"shasum":"2fd900e5946d97c1be88e7e6d29d4ccdbffdde5f"},{"_id":"public/img/interesting-curve/ring.gif","modified":1498191144682,"shasum":"b64e0003275db78257ed4e4df5f4898786fea760"},{"_id":"public/img/interesting-curve/box.gif","modified":1498191144690,"shasum":"bea87ba30f13bc86cf3f141cf4d9dc7bb81dd002"},{"_id":"public/img/interesting-curve/9.jpg","modified":1498191144694,"shasum":"02f5f09e3607c7421b0e3c35fb644cc1b32986a6"},{"_id":"public/img/interesting-curve/8.png","modified":1498191144697,"shasum":"8556f52be9972440d4460018133ccb3a4dfbcf5e"},{"_id":"public/img/interesting-curve/7.png","modified":1498191144701,"shasum":"c71371378f0f51e3259ab849216fca60b1d466cf"},{"_id":"public/img/interesting-curve/6.png","modified":1498191144705,"shasum":"4f4156cb8c4c0199120511ff407218b20affb020"},{"_id":"public/img/interesting-curve/5.png","modified":1498191144714,"shasum":"b3b915d72a8c9611c39b0bb12015f2757df2046f"},{"_id":"public/img/interesting-curve/4.png","modified":1498191144719,"shasum":"a54df53b47e84f7b452f8393b6b93ccb32721d08"},{"_id":"public/img/interesting-curve/3.png","modified":1498191144728,"shasum":"03d2eb9ef532d6b5606d89cf6c21748c317087ca"},{"_id":"public/img/interesting-curve/2.png","modified":1498191144740,"shasum":"7fff0d4bfe989d410640542f73597c50288bf23a"},{"_id":"public/img/interesting-curve/11.png","modified":1498191144757,"shasum":"fd0038404392434605fb02142aa6a319f97351bd"},{"_id":"public/img/interesting-curve/10.png","modified":1498191144763,"shasum":"901a86dc68fdb1e8c8d7e2c2ed30c03b73d565f8"},{"_id":"public/img/interesting-curve/1.png","modified":1498191144769,"shasum":"6863d44d483aa141f977fb9d5a38af702b2cf231"},{"_id":"public/img/host.png","modified":1498191144774,"shasum":"e3cd6594465e22ed3b2a872e1b63212862097011"},{"_id":"public/img/hey_folks.jpg","modified":1498191144779,"shasum":"b0a05bc1ed1669615ead2c5c9b7947f2b0d3968c"},{"_id":"public/img/hexo-directory.png","modified":1498191144782,"shasum":"826cebfed96a6407234bf963baf6921c398195e1"},{"_id":"public/img/gc/young_3.png","modified":1498191144786,"shasum":"dec153f322058693bb3aae00d55c47b850becdfe"},{"_id":"public/img/gc/young_2.png","modified":1498191144788,"shasum":"ef5664777c4a15903db46bf86517782ba7e9f9fe"},{"_id":"public/img/gc/young_1.png","modified":1498191144790,"shasum":"019bd491d81551b3e7d5c20d854867b398385799"},{"_id":"public/img/gc/reachable.JPG","modified":1498191144791,"shasum":"73f228750a79d0f7237126e7d279542e7b98b9f4"},{"_id":"public/img/gc/mark-sweep.png","modified":1498191144793,"shasum":"5e352e55715e058db8ccd1012b4193f46c5fc378"},{"_id":"public/img/gc/mark-compact.png","modified":1498191144795,"shasum":"3ac4b53d222ae7e53397e540d3b0e156d8c40933"},{"_id":"public/img/gc/garbage.png","modified":1498191144796,"shasum":"a872b666d4e1f0dc79f87c94489348acd17105d9"},{"_id":"public/img/gc/copying.png","modified":1498191144800,"shasum":"d9b1e7e76d79d84971f842c294dc8124054e6472"},{"_id":"public/img/fastblur/timeconsume_statisic.png","modified":1498191144805,"shasum":"bbff7161a608a488990613a9df5de6dcbf9162f9"},{"_id":"public/img/fastblur/test_pic.jpeg","modified":1498191144808,"shasum":"19ca9f388ab26da2c071841baab3868bfba15569"},{"_id":"public/img/fastblur/memory_50.png","modified":1498191144810,"shasum":"62b94351e2d50d256e83ec7ec3a854e084bceade"},{"_id":"public/img/fastblur/memory_300.png","modified":1498191144812,"shasum":"89d3356a32b32962d364f83d5d82f6a8d7d83333"},{"_id":"public/img/fastblur/memory_200.png","modified":1498191144813,"shasum":"2a07afd6a2443e17461839dded0c279e8822d86b"},{"_id":"public/img/fastblur/memory_20.png","modified":1498191144815,"shasum":"db301fb4b555e31a64a77f4b1286310ea267ca58"},{"_id":"public/img/fastblur/memory_100.png","modified":1498191144817,"shasum":"3232f11fdac327635a82e22f009b776030c3bc89"},{"_id":"public/img/fastblur/memory_10.png","modified":1498191144820,"shasum":"935d56271c8d9304161cbcf5405b8a1ee0e87062"},{"_id":"public/img/fastblur/memory_1.png","modified":1498191144822,"shasum":"14e397afa644bcf3dac11daabd988cca961ad5d8"},{"_id":"public/img/fastblur/iosblur.jpg","modified":1498191144825,"shasum":"b7aad38c394a049c45cc60ddee04f916479d9ddc"},{"_id":"public/img/fastblur/fastblur_50.png","modified":1498191144829,"shasum":"db1b1ecd90c506c2fe3cb44e3bdac1167821cb0d"},{"_id":"public/img/fastblur/fastblur_35.png","modified":1498191144832,"shasum":"8ed56cf4cb45e436f3c79d3d2d70763cd81febae"},{"_id":"public/img/fastblur/fastblur_20.png","modified":1498191144838,"shasum":"0516ef3fc7dd353991431d0ce06e574a170a7b43"},{"_id":"public/img/fastblur/fastblur_100.png","modified":1498191144845,"shasum":"04082f0c83d266bc4a9c5051632fefb46d5b6c34"},{"_id":"public/img/fastblur/fastblur_10.png","modified":1498191144849,"shasum":"8df2d8d76e47bed7600511197b4287bbd864946e"},{"_id":"public/img/fastblur/androidblur_2.png","modified":1498191144853,"shasum":"6ea9cc7a4ce5338c9de262e064b129829d2d877a"},{"_id":"public/img/fastblur/androidblur_1.png","modified":1498191144857,"shasum":"dfc1003232f2bc079ad507ad9fd29e37aba3dc5e"},{"_id":"public/img/dream.jpg","modified":1498191144872,"shasum":"d208197b8979b1737c532fb70ff02b6213aa2679"},{"_id":"public/img/classloader/order.png","modified":1498191144882,"shasum":"72db27f2434eb2336be54ce4f1bb6b56b868e514"},{"_id":"public/img/annotation/warning.png","modified":1498191144887,"shasum":"7759b40d59373b8b5eb89ef83d20b8d9323a6af3"},{"_id":"public/img/annotation/no-warning.png","modified":1498191144890,"shasum":"1a92f328e0aa6a9a040859de0537dc1965ab7d7a"},{"_id":"public/img/Disqus评论系统.png","modified":1498191144893,"shasum":"e313d38101a7a49f717ff8964c9d125eef3b284d"},{"_id":"public/favicon.ico","modified":1498191144895,"shasum":"bb38565775f52af7d2f1f0187ed9972a7b4f09a1"},{"_id":"public/tags/index.html","modified":1498191144975,"shasum":"d74612cf1a6c736d703f711d3cccfe736fc7d299"},{"_id":"public/resume/index.html","modified":1498191145070,"shasum":"a282a0943a2279c91092f8b92778e988ebba8280"},{"_id":"public/guestbook/index.html","modified":1498191145096,"shasum":"4ee573f0087d7f955dcdeded494bd36978f6b1bc"},{"_id":"public/2017/06/08/rebuild-personal-blog/index.html","modified":1498191145220,"shasum":"cab93ef2092d1a22dcd5468aa8364086209ace91"},{"_id":"public/2017/05/24/Java-技术之垃圾回收机制/index.html","modified":1498191145282,"shasum":"4b089abac5c6a30713d2d6186bd440bd07c93253"},{"_id":"public/2017/05/14/dig_into_leakcanary/index.html","modified":1498191145362,"shasum":"7414c2689049f443bfcd2ac52d051719fa81dae9"},{"_id":"public/2017/05/08/java_classloader/index.html","modified":1498191145435,"shasum":"031ac8c7382a940aef5bfe1dba0f562a42015a46"},{"_id":"public/2017/05/03/Java-技术之注解-Annotation/index.html","modified":1498191145510,"shasum":"9280c723b094d2b5caaffdc726f9a5ebd22e8ae9"},{"_id":"public/2017/04/26/Java-技术之反射/index.html","modified":1498191145571,"shasum":"9f89ac158fc86198653197b1ace17b41c259181e"},{"_id":"public/2017/04/09/Java里如何实现线程间通信？/index.html","modified":1498191145653,"shasum":"4a0329f77536afda28e0e8286cff4e1847be1b57"},{"_id":"public/2017/03/29/Java的equals与hashcode对比分析/index.html","modified":1498191211962,"shasum":"a7cbefaf129274bbcb1ee6d10b3977e6f6045ab0"},{"_id":"public/2017/03/29/对未来个人技术博客的一些思考/index.html","modified":1498191145779,"shasum":"acbc0a4f9730df81e069adc720b620b3acf1b7e5"},{"_id":"public/2017/03/14/写给移动开发者的-React-Native-指南/index.html","modified":1498191212119,"shasum":"bf59591161af9f1113a77c599ea6c0cc3ed9603e"},{"_id":"public/2017/02/05/今年之计－2017/index.html","modified":1498191145897,"shasum":"6b46906e83dd4b7ac2bc43733937740b8c077eb4"},{"_id":"public/2016/11/26/独立全端开发的开源小作：简诗2-0/index.html","modified":1498191145947,"shasum":"4e5583b3993de40eca0a8347cc7ec1210c84f35b"},{"_id":"public/2016/11/02/干货-Glow-Android-优化实践/index.html","modified":1498191212372,"shasum":"9afe9617c3d96d82cc4ad667a45824aac3fe17d6"},{"_id":"public/2016/08/30/谈谈移动应用的安全性实践/index.html","modified":1498191146126,"shasum":"c6029a4b59ed064bfd7d09c42a75855a4ae88268"},{"_id":"public/2016/07/21/带你学开源项目：OkHttp-自己动手实现okhttp/index.html","modified":1498191212553,"shasum":"743f2fa6a0e618c0846aa74fb7039dcae6999de4"},{"_id":"public/2016/07/14/RxLifecycle源码解析－当Activity被destory时自动暂停网络请求/index.html","modified":1498191212643,"shasum":"2f741049b6e0985a8e29578a1f152c1c639b7e04"},{"_id":"public/2016/07/10/Walk-in-ShangHai/index.html","modified":1498191146315,"shasum":"39b1850632de502db1cec0a6cb2313f9edca7de3"},{"_id":"public/2016/06/06/梦想升起的地方/index.html","modified":1498191146367,"shasum":"cc2f0f1243f8bdfdcef01a9becaef0bb63fe70f8"},{"_id":"public/2016/04/13/带你学开源项目：Meizhi-Android之RxJava-Retrofit最佳实践/index.html","modified":1498191212835,"shasum":"3f80690cf24406c79a8efe08114231cfea6bcf38"},{"_id":"public/2016/03/15/30条Android开发建议/index.html","modified":1498191212897,"shasum":"117c702f69d2075b65a4c592ef45270a9d14aac8"},{"_id":"public/2016/03/12/一种快速毛玻璃虚化效果实现/index.html","modified":1498191212957,"shasum":"321b250fc13fa93cf9f164e6a25e6982d5a6fdff"},{"_id":"public/2016/02/20/计划清单/index.html","modified":1498191146579,"shasum":"8f8ecb0d2ba19e8a504498bc667b3d7c4aba1f3d"},{"_id":"public/2016/02/19/今年之计/index.html","modified":1498191146628,"shasum":"d3c560ad18d9346de42bb0de6b762c8feaefba80"},{"_id":"public/2016/01/25/有趣的曲线在Android上的实现/index.html","modified":1498191146684,"shasum":"dbd0b66eb0dd98a277f9dc0377e53ebc2bdb5ca2"},{"_id":"public/2016/01/02/交大－影/index.html","modified":1498191146735,"shasum":"92bdd139816b53f9e2e4adddabee44222363ceac"},{"_id":"public/2015/12/29/我与代码的相知相遇/index.html","modified":1498191146784,"shasum":"4ea6df88bf85958c342903c8e7db3ff3d8382d82"},{"_id":"public/2015/12/07/如何在一天之内搭建以你自己名字为域名的很cool的个人博客/index.html","modified":1498191213309,"shasum":"166576e6fa737648e7227fafd2b7d09a55e4d140"},{"_id":"public/2015/12/06/说一说博客/index.html","modified":1498191146893,"shasum":"931cda52e446130d66a964fc197d25b6cab08792"},{"_id":"public/2015/12/05/Hey folks/index.html","modified":1498191146946,"shasum":"0e360fd680192833129c5fb7ea3b85e2ff62f62c"},{"_id":"public/baidusitemap.xml","modified":1498191146948,"shasum":"16aafe87c8f142a7fdd41241e935c95d2d99c20d"},{"_id":"public/categories/Android/index.html","modified":1498191146985,"shasum":"5542c1631a591e912c591999acbec844c08379c8"},{"_id":"public/categories/Android/安全/index.html","modified":1498191147023,"shasum":"fe53ef9d02e5332a395aa1f769a85cb7f44064d3"},{"_id":"public/categories/Blog/index.html","modified":1498191147055,"shasum":"e667e96334e40fee97de4df05924b002d243f1d0"},{"_id":"public/categories/年度计划/index.html","modified":1498191147093,"shasum":"1afb22ae614a5f017b6889ba4bbd1563864ccfc9"},{"_id":"public/categories/个人博客/index.html","modified":1498191147125,"shasum":"d7c90ebd3a30ebe593a6132b27a9c612ada77147"},{"_id":"public/categories/个人博客/一天变cool/index.html","modified":1498191147158,"shasum":"08c5b88cb6b5e24f3df1b9ffce39ae54e345f3da"},{"_id":"public/categories/全栈/index.html","modified":1498191147196,"shasum":"3dd9fe73482c526df44ba0cc5c253deded6d7d45"},{"_id":"public/categories/全栈/Android/index.html","modified":1498191147236,"shasum":"340996706904bd34d93a65756817f72cc210090a"},{"_id":"public/categories/全栈/Android/Server/index.html","modified":1498191147271,"shasum":"f01b3a4f65cae416ca9ab6bf495ed9d4c31f8f54"},{"_id":"public/categories/随感/index.html","modified":1498191147309,"shasum":"85847c24febcda4100d69ec9cb9d2980d4b15a35"},{"_id":"public/categories/Android/Performance/index.html","modified":1498191147339,"shasum":"b0ca9290c18aac2a6174e28bc99546c27ae7161a"},{"_id":"public/categories/Android/带你学开源项目/index.html","modified":1498191147380,"shasum":"a05d9cab87ef32d2a476c2aea9579601fb74bc8a"},{"_id":"public/categories/React-Native/index.html","modified":1498191147412,"shasum":"457b5fd0fef773fed611bc5d5da57fa525cbe87e"},{"_id":"public/categories/摄影/index.html","modified":1498191147445,"shasum":"aea4f2af1d79e1f82c0e6e78c863d9d39b4ffafc"},{"_id":"public/categories/深入理解Java技术/index.html","modified":1498191147485,"shasum":"2cdb3063a68813a68d09492590de8098ecc3b4d2"},{"_id":"public/CNAME","modified":1498191147487,"shasum":"b6e903c363301141338985b51e3d46181253afe6"},{"_id":"public/index.html","modified":1498191215139,"shasum":"7d2275031f8e6e7e70277e93f541be3ea23fc072"},{"_id":"public/page/2/index.html","modified":1498191215256,"shasum":"50c57580dfa4499237a451f209ae6ecb5725dc8d"},{"_id":"public/page/3/index.html","modified":1498191215326,"shasum":"1944d4218250c6c9544ce96c7aa466b704869f7e"},{"_id":"public/atom.xml","modified":1498191147824,"shasum":"3403bda8286f2f54dd35282e9ebb4f75da5813e8"},{"_id":"public/archives/index.html","modified":1498191147875,"shasum":"87fd0a643101caac7a239083a1ef2fe92125d032"},{"_id":"public/archives/page/2/index.html","modified":1498191147916,"shasum":"8450e3f4b77f739747d062840c9fc4f6a8f30887"},{"_id":"public/archives/page/3/index.html","modified":1498191147959,"shasum":"152f88f160f211ee8f170fe6201e945e84c53fb6"},{"_id":"public/archives/2015/index.html","modified":1498191147994,"shasum":"214c328f3384ce6049f468c75efa816447701288"},{"_id":"public/archives/2015/12/index.html","modified":1498191148037,"shasum":"06ef8c2a15a93db4c8557c5ae4cbab844e9361ab"},{"_id":"public/archives/2016/index.html","modified":1498191148080,"shasum":"7b1da62d53e2905fe02e2260f8a4f99e4699bb2a"},{"_id":"public/archives/2016/page/2/index.html","modified":1498191148115,"shasum":"4e1fd062ec109839f506aa8cfc593036c65cfcd4"},{"_id":"public/archives/2016/01/index.html","modified":1498191148156,"shasum":"de553d8ff4bde77107f2bf4ee11f160cdaa4a82a"},{"_id":"public/archives/2016/02/index.html","modified":1498191148190,"shasum":"167f25ef637f065548dada61d3893250d7f07cb2"},{"_id":"public/archives/2016/03/index.html","modified":1498191148229,"shasum":"69f505a0fdcc0af94554d0c58a5188eef1168cb3"},{"_id":"public/archives/2016/04/index.html","modified":1498191148262,"shasum":"ea6a1fb34c5de61b7da96c4c532c9eecfd05a330"},{"_id":"public/archives/2016/06/index.html","modified":1498191148296,"shasum":"be3eedf46db90dd0c416bb86f2ae1a2c1158018d"},{"_id":"public/archives/2016/07/index.html","modified":1498191148338,"shasum":"dbb44dfc7fa8235aecace5159f9f49f9dbca60fb"},{"_id":"public/archives/2016/08/index.html","modified":1498191148370,"shasum":"2d84062f40f3a953f0405fa3b972d9a9479db187"},{"_id":"public/archives/2016/11/index.html","modified":1498191148412,"shasum":"ed1c174d49d846bf03a399b8200af0a0485f1ec3"},{"_id":"public/archives/2017/index.html","modified":1498191148454,"shasum":"4920883d72f62b9cd515a9725a1fe99e38f6c0f8"},{"_id":"public/archives/2017/page/2/index.html","modified":1498191148504,"shasum":"be4ce02838edc5be3e4bbddc56e8d2d5adb677fc"},{"_id":"public/archives/2017/02/index.html","modified":1498191148547,"shasum":"157a46aa45728c19d4f293d2e32d89e9c7765be7"},{"_id":"public/archives/2017/03/index.html","modified":1498191148583,"shasum":"2d57cf7f736627ff3afe9e6ba811fa648887abd1"},{"_id":"public/archives/2017/04/index.html","modified":1498191148625,"shasum":"05c9fd24c212512358943f1a676b2cd8af105649"},{"_id":"public/archives/2017/05/index.html","modified":1498191148659,"shasum":"968f1cfd396f8f4196d8f365dfb21fd9172a9e85"},{"_id":"public/archives/2017/06/index.html","modified":1498191148691,"shasum":"e3566f68787a9eb5eb60b92e7c2ba8e107b685c0"},{"_id":"public/post-sitemap.xml","modified":1498191148692,"shasum":"d5082078c576e7999d04b399e915b88fb7b27118"},{"_id":"public/page-sitemap.xml","modified":1498191148693,"shasum":"701451084078f2c9c9591e08babc782f358b1c11"},{"_id":"public/category-sitemap.xml","modified":1498191148693,"shasum":"a70489be37ff9b3574f6cf4ff1c8d6bb3d1e8da1"},{"_id":"public/tag-sitemap.xml","modified":1498191148694,"shasum":"e962afbf456fac204fa00d4471dbf5a1d9245071"},{"_id":"public/sitemap.xsl","modified":1498191148695,"shasum":"4321fa69dc1b8811d32b7a1478e5603e038cea1a"},{"_id":"public/sitemap.xml","modified":1498191148696,"shasum":"11ead93f16c1fd2950be3e31c631259b56487c15"},{"_id":"public/tags/Android/index.html","modified":1498191148741,"shasum":"0359289c0ee5703ba59f0e683f2e1a62e4d5cfde"},{"_id":"public/tags/随笔/index.html","modified":1498191148774,"shasum":"fc6183a77014d701a075f9bcb2a190a65a4839d7"},{"_id":"public/tags/GitHub/index.html","modified":1498191148811,"shasum":"d5f12460988d2ef4c672556096daf7ee11ab9414"},{"_id":"public/tags/Blog/index.html","modified":1498191148840,"shasum":"dccddfda896d19a263df8068ee8ee633b0e53bed"},{"_id":"public/tags/Hexo/index.html","modified":1498191148874,"shasum":"c381243b72bcd6d01aeeae88ee3856ba870943d1"},{"_id":"public/tags/个人博客/index.html","modified":1498191148910,"shasum":"508b75005bf7336e4ce9075d52b73f7f14255e67"},{"_id":"public/tags/一天变cool/index.html","modified":1498191148938,"shasum":"de88274a0351c7ccae5a2193c620ed18bf574ea7"},{"_id":"public/tags/cool/index.html","modified":1498191148965,"shasum":"a0eebfe3b9185abbf30eb80f77abe7c321d41931"},{"_id":"public/tags/动效/index.html","modified":1498191149005,"shasum":"2aa02c6cdfcbb9438e199adebaa1d121703717dd"},{"_id":"public/tags/Goodbye2015-Hi-2016/index.html","modified":1498191149033,"shasum":"65b9d8c4af4673f588cd7c1ef2df53a6c9b6b56f"},{"_id":"public/tags/带你学开源项目/index.html","modified":1498191149072,"shasum":"668beda48faaac0cef34959cb0d64301d516d470"},{"_id":"public/tags/内存泄漏/index.html","modified":1498191149101,"shasum":"0eaf4056be815ffbbbb0148935aabf1175738869"},{"_id":"public/tags/性能优化/index.html","modified":1498191149131,"shasum":"8e38018cc4ece97dec0a4af3b08d1101042d86e8"},{"_id":"public/tags/React-Native/index.html","modified":1498191149167,"shasum":"c831ff2b6017462a5a71453461886070b289b1d1"},{"_id":"public/tags/学习计划/index.html","modified":1498191149197,"shasum":"65b1cdc120b2beaa28b18016a3e66c5de7c5e402"},{"_id":"public/tags/摄影/index.html","modified":1498191149229,"shasum":"f4471758b284fd798c7d85405a038f5009b5e9af"},{"_id":"public/tags/RxJava/index.html","modified":1498191149265,"shasum":"31559eeb8f3b2e5d7065533776486fedc170826d"},{"_id":"public/tags/Java/index.html","modified":1498191149298,"shasum":"caa8157ebf60c3d05e2bc0436687f65c552bedba"},{"_id":"public/tags/多线程/index.html","modified":1498191149330,"shasum":"d6a6bad22288af2659609fde78578545442097d4"},{"_id":"public/tags/Annotation/index.html","modified":1498191149367,"shasum":"156c08e9ef607d268e65ab50759336f8ea3a573c"},{"_id":"public/tags/welcome/index.html","modified":1498191149396,"shasum":"7e45a334acb69e2a46f82c670748c5c6be8282e2"}],"Category":[{"name":"Android","_id":"cj49cbm0k0005moyxi0xt4q1e"},{"name":"安全","parent":"cj49cbm0k0005moyxi0xt4q1e","_id":"cj49cbm0m0007moyx3z56h5sq"},{"name":"Blog","_id":"cj49cbm0q000cmoyxztom1tg7"},{"name":"年度计划","_id":"cj49cbm0t000hmoyx6sydop4r"},{"name":"个人博客","_id":"cj49cbm0w000kmoyx4b5ddjrm"},{"name":"一天变cool","parent":"cj49cbm0w000kmoyx4b5ddjrm","_id":"cj49cbm0w000nmoyxo3yhvugo"},{"name":"全栈","_id":"cj49cbm0z000zmoyxq8qmc85r"},{"name":"Android","parent":"cj49cbm0z000zmoyxq8qmc85r","_id":"cj49cbm0z0010moyxgfs1xsm1"},{"name":"Server","parent":"cj49cbm0z0010moyxgfs1xsm1","_id":"cj49cbm100011moyxj9dsdh2l"},{"name":"随感","_id":"cj49cbm120016moyxidmnm6fj"},{"name":"Performance","parent":"cj49cbm0k0005moyxi0xt4q1e","_id":"cj49cbm17001amoyx6wezraqr"},{"name":"带你学开源项目","parent":"cj49cbm0k0005moyxi0xt4q1e","_id":"cj49cbm1g001qmoyxm4iu89i6"},{"name":"React Native","_id":"cj49cbm1y002jmoyxm2qqm922"},{"name":"摄影","_id":"cj49cbm28002umoyx1v8hctcy"},{"name":"深入理解Java技术","_id":"cj49cbm2n003dmoyxmssjv7kg"}],"Data":[],"Page":[{"title":"tags","date":"2015-12-05T11:50:21.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"title: tags\ndate: 2015-12-05 19:50:21\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-06-22T02:56:48.000Z","path":"tags/index.html","layout":"page","_id":"cj49cbm010001moyx0beikcfk"},{"title":"resume","date":"2017-06-18T06:29:03.000Z","_content":"> Those who expect to reap the blessings of freedom must, like men, undergo the fatigue of supporting it.\n> 想要收获自由之果的人，必须承受维护自由的劳苦。\n>\n> Thomas Paine\n\n____________________________________\n\nHere is wingjay, living in ShangHai.\n\n**Who am I**\nSoftware Engineer in Android, React Native, Python backend, Javascript, Web Fronted, PHP.\n\n**Award**\n[Best Apps of 2016 in Play Store - Eve Android](https://play.google.com/store/info/topic?id=merch_topic_b0000b2_apps_TopicPage_bestof2016&hl=en). \nSecond place of IBM Mobile Application Development Competition, 2014.\n\n\n**Experience**\n3 years experience in Android & Java;\nServeral months in React Native;\n1.5 years in Python backend + Flask + Nginx + Redis + MySQL + AliYun;\nHalf year in Web fronted.\n\n**Background**\n2015/06 - Now | Android-Server engineer | Glow | Shanghai\n2013/09 - 2016/06  | Master | Shanghai Jiao Tong University | Shanghai\n2009/09 - 2013/06  | Bachelor | Beijing Institute of Technology | Beijing\n\n**What I did**\nI write Android & Java [tech blogs](http://wingjay.com/).\nI open-source Android projects [jianshi + BlurImage](https://github.com/wingjay) etc.\nI read source code: OkHttp, LeakCanary, AOSP, RxLifecycle etc. (I love [Square](https://github.com/square), don't you?).\nI developed one personal Full-Stack project [jianshi 简诗](https://github.com/wingjay/jianshi) by myself. and Yeah, it's still alive, 25000 users, running on AliYun.\n\n**Links**\nGithub: https://github.com/wingjay\nBlog: http://wingjay.com/\nEmail: [yinjiesh AT 126.com](mailto:yinjiesh@126.com)\n\n**Languages**\nChinese native\nCET-6, I also write, speak, understand English\n\n\n____________________________________\n\nThanks, here is wingjay, always open to exciting opportunity.\n\n\n","source":"resume/index.md","raw":"title: resume\ndate: 2017-06-18 14:29:03\n---\n> Those who expect to reap the blessings of freedom must, like men, undergo the fatigue of supporting it.\n> 想要收获自由之果的人，必须承受维护自由的劳苦。\n>\n> Thomas Paine\n\n____________________________________\n\nHere is wingjay, living in ShangHai.\n\n**Who am I**\nSoftware Engineer in Android, React Native, Python backend, Javascript, Web Fronted, PHP.\n\n**Award**\n[Best Apps of 2016 in Play Store - Eve Android](https://play.google.com/store/info/topic?id=merch_topic_b0000b2_apps_TopicPage_bestof2016&hl=en). \nSecond place of IBM Mobile Application Development Competition, 2014.\n\n\n**Experience**\n3 years experience in Android & Java;\nServeral months in React Native;\n1.5 years in Python backend + Flask + Nginx + Redis + MySQL + AliYun;\nHalf year in Web fronted.\n\n**Background**\n2015/06 - Now | Android-Server engineer | Glow | Shanghai\n2013/09 - 2016/06  | Master | Shanghai Jiao Tong University | Shanghai\n2009/09 - 2013/06  | Bachelor | Beijing Institute of Technology | Beijing\n\n**What I did**\nI write Android & Java [tech blogs](http://wingjay.com/).\nI open-source Android projects [jianshi + BlurImage](https://github.com/wingjay) etc.\nI read source code: OkHttp, LeakCanary, AOSP, RxLifecycle etc. (I love [Square](https://github.com/square), don't you?).\nI developed one personal Full-Stack project [jianshi 简诗](https://github.com/wingjay/jianshi) by myself. and Yeah, it's still alive, 25000 users, running on AliYun.\n\n**Links**\nGithub: https://github.com/wingjay\nBlog: http://wingjay.com/\nEmail: [yinjiesh AT 126.com](mailto:yinjiesh@126.com)\n\n**Languages**\nChinese native\nCET-6, I also write, speak, understand English\n\n\n____________________________________\n\nThanks, here is wingjay, always open to exciting opportunity.\n\n\n","updated":"2017-06-22T02:56:48.000Z","path":"resume/index.html","comments":1,"layout":"page","_id":"cj49cbm020002moyxh0cbugs0"},{"title":"guestbook","date":"2015-12-05T11:21:08.000Z","_content":"","source":"guestbook/index.md","raw":"title: guestbook\ndate: 2015-12-05 19:21:08\n---\n","updated":"2017-06-22T02:56:46.000Z","path":"guestbook/index.html","comments":1,"layout":"page","_id":"cj49cbm0g0003moyxc491ah7m"}],"Post":[{"title":"test draft","_content":"Test Auto-Spacing Plugin: https://github.com/hexojs/hexo-filter-auto-spacing\n测试Auto Spacing插件，自动在CJK和western之间加入空格","source":"_drafts/test-draft.md","raw":"title: test draft\ntags:\n---\nTest Auto-Spacing Plugin: https://github.com/hexojs/hexo-filter-auto-spacing\n测试Auto Spacing插件，自动在CJK和western之间加入空格","slug":"test-draft","published":0,"date":"2017-06-22T02:56:46.000Z","updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cblzs0000moyxilnvcv9i","sticky":0},{"title":"谈谈移动应用的安全性实践","date":"2016-08-30T13:39:01.000Z","commentIssueId":13,"_content":">虽然没有完美的安全性，但我们所做的每一步都能加大被攻击的难度。\n\n<!-- more -->\n\n本文将从用户注册流程出发，介绍下个人实践中在提高数据安全性方面采用的一些策略方法，供读者参考。下文将从 `Android` 和 `服务端` 两部分来进行讲解。\n\n![](http://upload-images.jianshu.io/upload_images/281665-29572b7461c3d279.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 从注册说起\n\n用户第一次打开app时便会进入注册页面。然后客户端会要求用户输入用户名、密码并传递给服务端去创建一个新的user。此时通过明文传递用户名密码便是一个安全性隐患。或者说，如果有人监听注册API，那么很快就可以窃取到很多用户的账户信息，而且可以偷偷利用这些账户信息随时获取甚至更改用户数据。\n\n这对于任何一家企业而言都是非常可怕的。\n\n\n\n### 全站Https\n\n因此，为了应对数据明文传输隐患这个问题，我们可以<u>采用[Https](https://en.wikipedia.org/wiki/HTTPS)方式通信</u>。在Android端推荐[Square](http://square.github.io/)家的[OkHttp3](https://github.com/square/okhttp)作为网络层，为应用层提供Https服务。\n\n下面先对Https的基本工作原理进行下介绍。\n\n1. 首先，客户端去请求服务端的数字证书，这个证书包含了一个公钥。该证书购买后存储于我们自己服务器上。\n2. 当服务端收到客户端请求后，会把这个数字证书回传给客户端，由于是公钥，所以不害怕被窃取。\n3. 客户端收到数字证书后，先去`验证`证书的真实性。如果验证通过，就会从里面取出一个`公钥`。\n4. 客户端本地生成一个`随机数`，作为未来的`会话私钥`，利用前面的公钥进行`加密`。\n5. 客户端把`加密后会话私钥`回传给服务端，在这个过程中，即使`加密后的会话私钥`被窃取也不用担心，因为中间人并没有`解密私钥`，所以读不出里面的`会话私钥`。\n6. 服务端接收到`加密会话私钥`后，利用从CA购买证书时获得的`解密私钥`进行解密读出`真实会话私钥`。至此，客户端与服务端同时拥有了一个只有它们二者知道的`会话私钥`，非对称加密连接建立完成。\n7. 一旦客户端和服务端连接建立起来后，未来的数据通信都利用这个`会话私钥`进行对称加密传输数据。\n\n采用了https后，我们所有网络传输的数据都由明文变成了密文，即使中间有人能够监听到数据包，也不能轻易获取user的帐户密码信息。\n\n听起来，安全性问题基本解决了。\n\n然而实际上，在步骤3用户需要去验证数字证书时，如果<u>这个验证过程被欺骗了呢</u>？\n\n试想这样一种场景，如果在最开始，攻击者就拦截掉客户端与服务端的通信。当客户端在请求证书时，攻击者回传一个他自己的`假证书`，而且攻击者已经通过其他手段欺骗用户在手机上`信任`了这个`假证书`，那么当客户端接收到证书并去验证时，是**<u>可以通过的</u>**。\n\n这也就意味着，一旦客户端遭受这样的攻击，未来客户端都会与一个`虚假的中间人`通信，而且中间人也可以拿着客户端传来的信息去与我们的服务端通信，而这个过程`客户端和我们服务端完全不知道中间人的存在`，这是很大的安全隐患。\n\n\n\n### SSL Pinning\n\n为了防止客户端被虚假证书欺骗，我们采取的方式是<u>把我们自己的公钥直接绑定给每个客户端</u>，当客户端收到证书后，<u>与绑定的公钥进行验证</u>，从而防止`虚假证书`的入侵。\n\n在Android端，我们利用`OkHttp3`提供的`CertificatePinner`实现`证书绑定`\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n  .certificatePinner(\n        new CertificatePinner.Builder().add(\"your_host\", \"your_public_key\").build())\n        .build();\n```\n\n至此，我们可以利用更为安全的https协议来传输用户名和密码来继续上面的注册流程。\n\n\n\n### Token机制\n\n回到注册流程，当服务端拿到用户名密码后，会去创建一个新的user，同时我们会<u>基于用户相关信息</u>生成一个`Token`并回传给客户端。客户端在接收到`Token`后需要在本地进行存储。另外，由于每个http请求都是无状态的，因此未来客户端如果想把`user_id`等信息传递给服务端时，就必须通过`Token`来传递，才能识别出某个请求的来源。\n\n那么，我们应该如何在Android和服务端的代码里具体实现Token的`传递`、`解析`及`有效性验证机制`呢？\n\n**1. 首先在Android端，为了把`Token`信息存入到所有请求的header里供服务端使用，我们采用了`okhttp3`提供的`interceptor接口`来。**\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n       .addInterceptor(new Interceptor() {\n         @Override\n         public Response intercept(Chain chain) throws IOException {\n           Request request = chain.request();\n           Request.Builder newRequestBuilder = request.newBuilder();\n           String token = getAuthToken();\n           if (!TextUtils.isEmpty(token)) {\n             newRequestBuilder.addHeader(\"Authorization\", token);\n           }\n\n           Request newRequest = newRequestBuilder.build();\n           return chain.proceed(newRequest);\n         }\n       })\n       .build();\n```\n\n**2. 然后在服务端，我们需要`解析`客户端传递过来的Token信息并进行`校验`。这里可以创建一个`python`的`decorator`方法：**\n\n```python\ndef mobile_request(func):\n   @functools.wraps(func)\n   def wrapped(*args, **kwargs):\n       kwargs = kwargs if kwargs or {}\n   \tif request.headers.get('Authorization'):\n   \t\tencrypted_token = request.headers.get('Authorization')\n   \t\tisValid, user_id = check_token(encrypted_token) //解析并验证token有效性\n   \t\tif not isValid:\n   \t\t\tabort(498) //token无效，返回498状态码\n   \t\tuser = get_user_by_id(user_id)\n   \t\tif not user:\n   \t\t\tabort(1001) //找不到user，自定义601状态码\n\t\t\tkwargs['user_id'] = user_id //成功解析出user_id\n   \treturn func(**kwargs)\n   return wrapped\t\n```\n\n```py\n@app.route(\"/www/index\")\n@mobile_request // 使用decorator包装方法\ndef get_user(**kwargs):\n\tuser_id = kwargs['user_id'] // 取出decorator中封装好的user_id\n\treturn db.get_user(user_id) // 利用user_id进行逻辑处理\n```\n\n**3. 最后，请求结果返回到客户端，如果通过监测状态码发现返回结果是与Token相关的`error/异常`，则表示`Token失效`，此时我们让用户强制重新登录，生成新Token。这一步仍然可以在上面的`interceptor`里进行。**\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n       .addInterceptor(new Interceptor() {\n         @Override\n         public Response intercept(Chain chain) throws IOException {\n           ... //put token into newRequest\n           Response response = chain.proceed(newRequest); // 获取服务端返回结果\n           switch(response.code()) {\n             case ResponseCode.USER_NOT_FOUND: // 自定义状态码: 1001 找不到user\n             \teventBus.post(new UserNotFoundEvent()); // 强制logout\n             \tbreak;\n             case ResponseCode.TOKEN_EXPIRED: // 498 token失效\n             \teventBus.post(new TokenExpiredEvent()); // 强制logout\n             \tbreak;\n             default:\n             \tbreak;\n           }\n           return response;\n         }\n       })\n       .build();\n```\n\n至此，我们完成了Android端和服务端的Token传递、解析和失效处理。\n\n因此，在完善了Token的管理机制后，我们未来的http请求中只要带上这个Token，就可以畅通无阻地去服务端做与自身user相关的各种操作了。\n\n那么，既然Token像家里门禁卡一样，<u>只要拥有就能进入我们服务端并获取这个特定user的所有数据</u>。那也就意味着，<u>一旦攻击者窃取了某个user的Token</u>，那在Token失效前，攻击者随时可以利用这个Token获取这个user的一切信息。\n\n遇到Token被盗，该怎么办呢？\n\n\n\n### 调整Token过期时间\n\n针对Token被盗这种威胁，我们可以缩短Token的过期时间的方法。这样即使一个Token泄漏了，在一段时间后，这个Token也会自动失效。当然这也做会需要用户频繁登录获取新Token；而且失效前的这段时间内，攻击者仍然是可以直接连上服务端随意获取数据的。\n\n\n\n### Request签名\n\n这种方法也是OAuth推荐的[一种方法](https://oauth.net/core/1.0/#signing_process)，其原理是<u>在客户端和服务端统一好某种加密方法和一个密钥</u>，这个密钥同时存储在客户端和服务端。每次客户端准备发起一个请求时，利用这种加密算法和密钥，针对<u>该请求的API和参数</u>进行计算得到一个数，称之为这个`Request的签名`，然后我们把这个`签名`放入到Request中。当服务端接收到Request后，就可以利用相同的加密算法和密钥来验证其中签名的真实性。\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(new Interceptor() {\n          @Override\n          public Response intercept(Chain chain) throws IOException {\n            Request request = chain.request();\n            String sign = RequestSignUtil.sign(request);\n            HttpUrl url = request.url().newBuilder()\n        \t\t.addQueryParameter(\"request_sign\", sign)\n        \t\t.build();\n            Request newRequest = request.newBuilder().url(url).build();\n            return chain.proceed(newRequest);\n          }\n        })\n        .build();\n```\n\n通过对每一个Request签名，可以确保服务端接收到的所有Request都来自我们自己的客户端。即使有人得到了Token想伪造Request，他也不知道如何计算Request签名，从而减小了Token被盗的危害。\n\n当然，每种安全方法都有漏洞，Request签名的方法意味着我们必须在客户端保存好加密算法和密钥，可以通过代码混淆、密钥存储到.so文件等方法来提高破解难度，这里就不再细述了。\n\n\n\n### 小结\n\n上文中，从注册流程开始，介绍了我们在数据安全性方面采取的一些策略和相关实现代码，希望能对读者有帮助。\n\n最后，笔者认为虽然没有完美的安全性，但我们所做的每一步都能加大被攻击的难度。\n\n","source":"_posts/谈谈移动应用的安全性实践.md","raw":"title: 谈谈移动应用的安全性实践\ndate: 2016-08-30 21:39:01\ncategories:\n  - Android\n  - 安全\ntags: Android\ncommentIssueId: 13\n---\n>虽然没有完美的安全性，但我们所做的每一步都能加大被攻击的难度。\n\n<!-- more -->\n\n本文将从用户注册流程出发，介绍下个人实践中在提高数据安全性方面采用的一些策略方法，供读者参考。下文将从 `Android` 和 `服务端` 两部分来进行讲解。\n\n![](http://upload-images.jianshu.io/upload_images/281665-29572b7461c3d279.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 从注册说起\n\n用户第一次打开app时便会进入注册页面。然后客户端会要求用户输入用户名、密码并传递给服务端去创建一个新的user。此时通过明文传递用户名密码便是一个安全性隐患。或者说，如果有人监听注册API，那么很快就可以窃取到很多用户的账户信息，而且可以偷偷利用这些账户信息随时获取甚至更改用户数据。\n\n这对于任何一家企业而言都是非常可怕的。\n\n\n\n### 全站Https\n\n因此，为了应对数据明文传输隐患这个问题，我们可以<u>采用[Https](https://en.wikipedia.org/wiki/HTTPS)方式通信</u>。在Android端推荐[Square](http://square.github.io/)家的[OkHttp3](https://github.com/square/okhttp)作为网络层，为应用层提供Https服务。\n\n下面先对Https的基本工作原理进行下介绍。\n\n1. 首先，客户端去请求服务端的数字证书，这个证书包含了一个公钥。该证书购买后存储于我们自己服务器上。\n2. 当服务端收到客户端请求后，会把这个数字证书回传给客户端，由于是公钥，所以不害怕被窃取。\n3. 客户端收到数字证书后，先去`验证`证书的真实性。如果验证通过，就会从里面取出一个`公钥`。\n4. 客户端本地生成一个`随机数`，作为未来的`会话私钥`，利用前面的公钥进行`加密`。\n5. 客户端把`加密后会话私钥`回传给服务端，在这个过程中，即使`加密后的会话私钥`被窃取也不用担心，因为中间人并没有`解密私钥`，所以读不出里面的`会话私钥`。\n6. 服务端接收到`加密会话私钥`后，利用从CA购买证书时获得的`解密私钥`进行解密读出`真实会话私钥`。至此，客户端与服务端同时拥有了一个只有它们二者知道的`会话私钥`，非对称加密连接建立完成。\n7. 一旦客户端和服务端连接建立起来后，未来的数据通信都利用这个`会话私钥`进行对称加密传输数据。\n\n采用了https后，我们所有网络传输的数据都由明文变成了密文，即使中间有人能够监听到数据包，也不能轻易获取user的帐户密码信息。\n\n听起来，安全性问题基本解决了。\n\n然而实际上，在步骤3用户需要去验证数字证书时，如果<u>这个验证过程被欺骗了呢</u>？\n\n试想这样一种场景，如果在最开始，攻击者就拦截掉客户端与服务端的通信。当客户端在请求证书时，攻击者回传一个他自己的`假证书`，而且攻击者已经通过其他手段欺骗用户在手机上`信任`了这个`假证书`，那么当客户端接收到证书并去验证时，是**<u>可以通过的</u>**。\n\n这也就意味着，一旦客户端遭受这样的攻击，未来客户端都会与一个`虚假的中间人`通信，而且中间人也可以拿着客户端传来的信息去与我们的服务端通信，而这个过程`客户端和我们服务端完全不知道中间人的存在`，这是很大的安全隐患。\n\n\n\n### SSL Pinning\n\n为了防止客户端被虚假证书欺骗，我们采取的方式是<u>把我们自己的公钥直接绑定给每个客户端</u>，当客户端收到证书后，<u>与绑定的公钥进行验证</u>，从而防止`虚假证书`的入侵。\n\n在Android端，我们利用`OkHttp3`提供的`CertificatePinner`实现`证书绑定`\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n  .certificatePinner(\n        new CertificatePinner.Builder().add(\"your_host\", \"your_public_key\").build())\n        .build();\n```\n\n至此，我们可以利用更为安全的https协议来传输用户名和密码来继续上面的注册流程。\n\n\n\n### Token机制\n\n回到注册流程，当服务端拿到用户名密码后，会去创建一个新的user，同时我们会<u>基于用户相关信息</u>生成一个`Token`并回传给客户端。客户端在接收到`Token`后需要在本地进行存储。另外，由于每个http请求都是无状态的，因此未来客户端如果想把`user_id`等信息传递给服务端时，就必须通过`Token`来传递，才能识别出某个请求的来源。\n\n那么，我们应该如何在Android和服务端的代码里具体实现Token的`传递`、`解析`及`有效性验证机制`呢？\n\n**1. 首先在Android端，为了把`Token`信息存入到所有请求的header里供服务端使用，我们采用了`okhttp3`提供的`interceptor接口`来。**\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n       .addInterceptor(new Interceptor() {\n         @Override\n         public Response intercept(Chain chain) throws IOException {\n           Request request = chain.request();\n           Request.Builder newRequestBuilder = request.newBuilder();\n           String token = getAuthToken();\n           if (!TextUtils.isEmpty(token)) {\n             newRequestBuilder.addHeader(\"Authorization\", token);\n           }\n\n           Request newRequest = newRequestBuilder.build();\n           return chain.proceed(newRequest);\n         }\n       })\n       .build();\n```\n\n**2. 然后在服务端，我们需要`解析`客户端传递过来的Token信息并进行`校验`。这里可以创建一个`python`的`decorator`方法：**\n\n```python\ndef mobile_request(func):\n   @functools.wraps(func)\n   def wrapped(*args, **kwargs):\n       kwargs = kwargs if kwargs or {}\n   \tif request.headers.get('Authorization'):\n   \t\tencrypted_token = request.headers.get('Authorization')\n   \t\tisValid, user_id = check_token(encrypted_token) //解析并验证token有效性\n   \t\tif not isValid:\n   \t\t\tabort(498) //token无效，返回498状态码\n   \t\tuser = get_user_by_id(user_id)\n   \t\tif not user:\n   \t\t\tabort(1001) //找不到user，自定义601状态码\n\t\t\tkwargs['user_id'] = user_id //成功解析出user_id\n   \treturn func(**kwargs)\n   return wrapped\t\n```\n\n```py\n@app.route(\"/www/index\")\n@mobile_request // 使用decorator包装方法\ndef get_user(**kwargs):\n\tuser_id = kwargs['user_id'] // 取出decorator中封装好的user_id\n\treturn db.get_user(user_id) // 利用user_id进行逻辑处理\n```\n\n**3. 最后，请求结果返回到客户端，如果通过监测状态码发现返回结果是与Token相关的`error/异常`，则表示`Token失效`，此时我们让用户强制重新登录，生成新Token。这一步仍然可以在上面的`interceptor`里进行。**\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n       .addInterceptor(new Interceptor() {\n         @Override\n         public Response intercept(Chain chain) throws IOException {\n           ... //put token into newRequest\n           Response response = chain.proceed(newRequest); // 获取服务端返回结果\n           switch(response.code()) {\n             case ResponseCode.USER_NOT_FOUND: // 自定义状态码: 1001 找不到user\n             \teventBus.post(new UserNotFoundEvent()); // 强制logout\n             \tbreak;\n             case ResponseCode.TOKEN_EXPIRED: // 498 token失效\n             \teventBus.post(new TokenExpiredEvent()); // 强制logout\n             \tbreak;\n             default:\n             \tbreak;\n           }\n           return response;\n         }\n       })\n       .build();\n```\n\n至此，我们完成了Android端和服务端的Token传递、解析和失效处理。\n\n因此，在完善了Token的管理机制后，我们未来的http请求中只要带上这个Token，就可以畅通无阻地去服务端做与自身user相关的各种操作了。\n\n那么，既然Token像家里门禁卡一样，<u>只要拥有就能进入我们服务端并获取这个特定user的所有数据</u>。那也就意味着，<u>一旦攻击者窃取了某个user的Token</u>，那在Token失效前，攻击者随时可以利用这个Token获取这个user的一切信息。\n\n遇到Token被盗，该怎么办呢？\n\n\n\n### 调整Token过期时间\n\n针对Token被盗这种威胁，我们可以缩短Token的过期时间的方法。这样即使一个Token泄漏了，在一段时间后，这个Token也会自动失效。当然这也做会需要用户频繁登录获取新Token；而且失效前的这段时间内，攻击者仍然是可以直接连上服务端随意获取数据的。\n\n\n\n### Request签名\n\n这种方法也是OAuth推荐的[一种方法](https://oauth.net/core/1.0/#signing_process)，其原理是<u>在客户端和服务端统一好某种加密方法和一个密钥</u>，这个密钥同时存储在客户端和服务端。每次客户端准备发起一个请求时，利用这种加密算法和密钥，针对<u>该请求的API和参数</u>进行计算得到一个数，称之为这个`Request的签名`，然后我们把这个`签名`放入到Request中。当服务端接收到Request后，就可以利用相同的加密算法和密钥来验证其中签名的真实性。\n\n```java\nOkHttpClient client = new OkHttpClient.Builder()\n        .addInterceptor(new Interceptor() {\n          @Override\n          public Response intercept(Chain chain) throws IOException {\n            Request request = chain.request();\n            String sign = RequestSignUtil.sign(request);\n            HttpUrl url = request.url().newBuilder()\n        \t\t.addQueryParameter(\"request_sign\", sign)\n        \t\t.build();\n            Request newRequest = request.newBuilder().url(url).build();\n            return chain.proceed(newRequest);\n          }\n        })\n        .build();\n```\n\n通过对每一个Request签名，可以确保服务端接收到的所有Request都来自我们自己的客户端。即使有人得到了Token想伪造Request，他也不知道如何计算Request签名，从而减小了Token被盗的危害。\n\n当然，每种安全方法都有漏洞，Request签名的方法意味着我们必须在客户端保存好加密算法和密钥，可以通过代码混淆、密钥存储到.so文件等方法来提高破解难度，这里就不再细述了。\n\n\n\n### 小结\n\n上文中，从注册流程开始，介绍了我们在数据安全性方面采取的一些策略和相关实现代码，希望能对读者有帮助。\n\n最后，笔者认为虽然没有完美的安全性，但我们所做的每一步都能加大被攻击的难度。\n\n","slug":"谈谈移动应用的安全性实践","published":1,"updated":"2017-06-23T04:07:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm0i0004moyxnkb1q9oq","sticky":0},{"title":"说一说我和博客","date":"2015-12-06T13:39:28.000Z","_content":"> 博客是个人的一方净土，记录技术成长，记录生活态度\n\n<!-- more -->\n\n![说一说我和博客](/img/me-and-blog.jpg)\n\n## 我和博客的那些事\n一直以来在各种平台上写过博客。\n\n最早在新浪、博客园。那时的博客是以笔记摘要为主，看一本书，摘抄几句话，即成一文。写多了，慢慢感觉意义不大，也极少回顾。或者说，写那些博客没有个人的思考，故果断弃之。\n\n然后，开始在[简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles)上写，逐渐记录自己的思考和技术为主，如在学习Android中对系统机制的思考和总结。在简书上也偶有佳作得到大家的喜欢，比如[如何在一天之内完成一款具备cool属性的Android产品](http://www.jianshu.com/p/cf496fc408b2)、[如何阅读Android系统源码－收藏必备](http://www.jianshu.com/p/b3580904d298)。这也激励了我更加努力并分享出更多优质的原创内容。另外，最近也开通了Medium博客平台，不过那上面主要写英文文章，此不细讲。\n\n然后，就是大家看到的个人博客网站。前夜，洗澡后头发没干，就乘机坐在被窝里搭了自己的博客。以前觉得个人博客和简书这类公共博客没什么差异，不过现在却发觉个人博客令人思想更自由，可以记录一切，更不怕随着博客平台的更换而丢失。\n\n\n## 介绍下我的博客\n介绍博客之前，要先麻烦朋友记住一个名字：wingjay。为什么要记住它呢，因为域名是：wingjay.com啊！哈哈（冷）。\n\n目前我的博客内容是同时挂载在两个地方GitHub、GitCafe以同时支持两个域名访问。在此我要感谢这二位，让我省去一笔购买服务器的开销，也同时保证了国内国外都能正常访问。\n\n我的博客主要会包括**技术、艺术和思考**。\n\n - 技术，有两种。一是自己工作中接触到的技术如Android和服务器开发。另一种是自己认为很cool的技术，难道不是每个有追求的人都希望自己变得更cool吗？\n - 艺术，讲不清，包含很多。比如美好的移动设计或工业设计，比如一组让人心静的摄影作品，比如一杯凛冽粗暴的伏特加。这些都是我心中的艺术。\n - 思考，同样讲不清。不过我可以肯定的是，我的博客里每个文字都会出自自己的思考。比如对大爷大妈手牵手的思考，比如对某水果台各类脑残剧和琅琊榜对比的思考，比如对Google和Apple之争的思考。太多了。\n\n## 我为什么要写作\n我认为有两点。\n\n1. 博客是程序员的简历之一。对程序员而言，大多数人都是通过你的博客来认识你。而且，多写博客能促使我们去专研问题并与人分享，同时通过他人反馈来改善自我。\n2. 热爱。通过写作，我们可以记录思考，记录生活，记录技术成长。这难道不是一件很正能量的事情吗？\n\n## 我的写作风格\n简单，直接，文艺\n\n\n\n\n逗逼\n","source":"_posts/说一说博客.md","raw":"title: 说一说我和博客\ndate: 2015-12-06 21:39:28\ncategories:\n  - Blog\ntags: 随笔\n---\n> 博客是个人的一方净土，记录技术成长，记录生活态度\n\n<!-- more -->\n\n![说一说我和博客](/img/me-and-blog.jpg)\n\n## 我和博客的那些事\n一直以来在各种平台上写过博客。\n\n最早在新浪、博客园。那时的博客是以笔记摘要为主，看一本书，摘抄几句话，即成一文。写多了，慢慢感觉意义不大，也极少回顾。或者说，写那些博客没有个人的思考，故果断弃之。\n\n然后，开始在[简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles)上写，逐渐记录自己的思考和技术为主，如在学习Android中对系统机制的思考和总结。在简书上也偶有佳作得到大家的喜欢，比如[如何在一天之内完成一款具备cool属性的Android产品](http://www.jianshu.com/p/cf496fc408b2)、[如何阅读Android系统源码－收藏必备](http://www.jianshu.com/p/b3580904d298)。这也激励了我更加努力并分享出更多优质的原创内容。另外，最近也开通了Medium博客平台，不过那上面主要写英文文章，此不细讲。\n\n然后，就是大家看到的个人博客网站。前夜，洗澡后头发没干，就乘机坐在被窝里搭了自己的博客。以前觉得个人博客和简书这类公共博客没什么差异，不过现在却发觉个人博客令人思想更自由，可以记录一切，更不怕随着博客平台的更换而丢失。\n\n\n## 介绍下我的博客\n介绍博客之前，要先麻烦朋友记住一个名字：wingjay。为什么要记住它呢，因为域名是：wingjay.com啊！哈哈（冷）。\n\n目前我的博客内容是同时挂载在两个地方GitHub、GitCafe以同时支持两个域名访问。在此我要感谢这二位，让我省去一笔购买服务器的开销，也同时保证了国内国外都能正常访问。\n\n我的博客主要会包括**技术、艺术和思考**。\n\n - 技术，有两种。一是自己工作中接触到的技术如Android和服务器开发。另一种是自己认为很cool的技术，难道不是每个有追求的人都希望自己变得更cool吗？\n - 艺术，讲不清，包含很多。比如美好的移动设计或工业设计，比如一组让人心静的摄影作品，比如一杯凛冽粗暴的伏特加。这些都是我心中的艺术。\n - 思考，同样讲不清。不过我可以肯定的是，我的博客里每个文字都会出自自己的思考。比如对大爷大妈手牵手的思考，比如对某水果台各类脑残剧和琅琊榜对比的思考，比如对Google和Apple之争的思考。太多了。\n\n## 我为什么要写作\n我认为有两点。\n\n1. 博客是程序员的简历之一。对程序员而言，大多数人都是通过你的博客来认识你。而且，多写博客能促使我们去专研问题并与人分享，同时通过他人反馈来改善自我。\n2. 热爱。通过写作，我们可以记录思考，记录生活，记录技术成长。这难道不是一件很正能量的事情吗？\n\n## 我的写作风格\n简单，直接，文艺\n\n\n\n\n逗逼\n","slug":"说一说博客","published":1,"updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm0o000bmoyx6ihlbgr0","sticky":0},{"title":"计划清单","date":"2016-02-20T11:09:52.000Z","_content":"\n本文长期更新，主要给自己用来记录计划要做的事项。\n\n<!-- more -->\n\n## 开源\n1. Android Fab\n\n2. 弹幕——好奇心日报\n\n## 博客\n1. Android - Drawable与bitmap、canvas、paint的关系\n2. SparseArray vs. HashMap LruCache on Android platform\n3. 100 Days of Google Dev series & Google I/O\n已完成：\n02 The Magic of LRU Cache\n进行中：\n65 Fun with ArrayMaps\n79 SparseArray Family Ties\n51 Smaller Pixel Formats\n59 Smaller PNG Files\n61 Android Development Patterns\n62 Re-using Bitmaps\n64 Android Performance Patterns – Performance Anxiety\n86 The price of ENUMs\n93 Double Layout Taxation\n100 Trimming and Sharing Memory\n排队：\n03 Google Play Services 7.5\n04 Push Notifications on the Open Web to increase engagement\n09 Using LINT for Performance Tips\n10 Supercharging page load\n11 Fingerprint and payments APIs\n12 Store Listing Experiments for Google Play\n16 Hidden Cost of Transparency\n17 Analyzing your App with Google Analytics\n20 New APIs in M for Android for Work\n21 Google Search for Developers\n23 Avoiding Allocations in onDraw()\n30 Strict Mode\n32 Promote your Apps with Google AdWords\n37 Custom Views and Performance\n38 Google’s International Fonts Noto\n41 Build a video chat app for Android, iOS and the Web\n44 Batching Background Work Until Later\n48 Introduction to the Physical Web\n72 Beware Autoboxing\n74 Google Play services 7.8\n75 Chat with Heidi Dohse about Cloud in Healthcare\n81 Introducing Face Detection in the Google Vision APIs\n88 Use WordPress APIs and Android Volley to build native apps\n89 Docker and Containers\n90 Developing for Android 6.0 Marshmallow\n95 Learn how to scale your applications with Google Compute Engine\n96 Chat with Sunil Vemuri about OK, Google\nhttps://www.youtube.com/watch?v=R5ON3iwx78M&index=2&list=PLOU2XLYxmsIJDPXCTt5TLDu67271PruEk\nhttp://www.ithome.com.tw/news/98805\nhttps://www.udacity.com/google\n\n4. Udacity TensorFlow by Google\n\n## idea\n1. 学习leancloud搭建后台，使用python flask，参考\nhttp://drakeet.me/leancloud-engine-guide\nhttp://drakeet.me/create-telegram-bot-with-python\n2. 开发个人微信公众号","source":"_posts/计划清单.md","raw":"title: 计划清单\ncategories:\n  - 年度计划\ndate: 2016-02-20 19:09:52\ntags:\n---\n\n本文长期更新，主要给自己用来记录计划要做的事项。\n\n<!-- more -->\n\n## 开源\n1. Android Fab\n\n2. 弹幕——好奇心日报\n\n## 博客\n1. Android - Drawable与bitmap、canvas、paint的关系\n2. SparseArray vs. HashMap LruCache on Android platform\n3. 100 Days of Google Dev series & Google I/O\n已完成：\n02 The Magic of LRU Cache\n进行中：\n65 Fun with ArrayMaps\n79 SparseArray Family Ties\n51 Smaller Pixel Formats\n59 Smaller PNG Files\n61 Android Development Patterns\n62 Re-using Bitmaps\n64 Android Performance Patterns – Performance Anxiety\n86 The price of ENUMs\n93 Double Layout Taxation\n100 Trimming and Sharing Memory\n排队：\n03 Google Play Services 7.5\n04 Push Notifications on the Open Web to increase engagement\n09 Using LINT for Performance Tips\n10 Supercharging page load\n11 Fingerprint and payments APIs\n12 Store Listing Experiments for Google Play\n16 Hidden Cost of Transparency\n17 Analyzing your App with Google Analytics\n20 New APIs in M for Android for Work\n21 Google Search for Developers\n23 Avoiding Allocations in onDraw()\n30 Strict Mode\n32 Promote your Apps with Google AdWords\n37 Custom Views and Performance\n38 Google’s International Fonts Noto\n41 Build a video chat app for Android, iOS and the Web\n44 Batching Background Work Until Later\n48 Introduction to the Physical Web\n72 Beware Autoboxing\n74 Google Play services 7.8\n75 Chat with Heidi Dohse about Cloud in Healthcare\n81 Introducing Face Detection in the Google Vision APIs\n88 Use WordPress APIs and Android Volley to build native apps\n89 Docker and Containers\n90 Developing for Android 6.0 Marshmallow\n95 Learn how to scale your applications with Google Compute Engine\n96 Chat with Sunil Vemuri about OK, Google\nhttps://www.youtube.com/watch?v=R5ON3iwx78M&index=2&list=PLOU2XLYxmsIJDPXCTt5TLDu67271PruEk\nhttp://www.ithome.com.tw/news/98805\nhttps://www.udacity.com/google\n\n4. Udacity TensorFlow by Google\n\n## idea\n1. 学习leancloud搭建后台，使用python flask，参考\nhttp://drakeet.me/leancloud-engine-guide\nhttp://drakeet.me/create-telegram-bot-with-python\n2. 开发个人微信公众号","slug":"计划清单","published":1,"updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm0s000gmoyx1br5d1m0","sticky":0},{"title":"自己动手改造个人博客","date":"2017-06-08T04:12:37.000Z","commentIssueId":1,"_content":"\n个人博客不仅是个人写作的地方，更是一个展示自己个性、扩大个人影响力的产品。\n\n之前我写过一篇《[如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客](http://www.jianshu.com/p/99665608d295)》帮助不少人从零开始搭建了自己的博客。而今天想做的是把博客当成个人产品来进行迭代开发，以更好地展示个人形象。\n\n<!-- more -->\n\n下面我将介绍一些关于个人博客的新功能，以及实现功能的过程。[注：建议进入[原文阅读](http://wingjay.com/2017/06/08/rebuild-personal-blog/)，可以查看到功能的具体效果。本站搭建在 Hexo 平台上]\n- 中英文自动添加空格\n- 推荐相关文章\n- 基于GitHub Issue来实现评论功能\n- 个人简历页面\n- RSS订阅\n\n\n## 中英文自动添加空格\n不少有追求的开发者在写博客时追求格式优雅，比如`中英文间隔`。为了达到这个目的，很多时候就不得不在写文时反复调整英文单词与中文的空格。\n\n这里介绍一个小巧的插件：[Auto-Spacing](https://github.com/hexojs/hexo-filter-auto-spacing)，它会在 markdown 文章转化成 html 时，自动为中英文添加空格。\n\n安装方法：\n在项目根目录下，执行 \n```\nnpm install hexo-filter-auto-spacing --save\n```\n\n执行完后可以在根目录的 `package.json` 里找到一行 \n\n```\ndenpendency`:`\"hexo-filter-auto-spacing\": \"^0.2.1\"\n```\n\n**提醒**\n使用这个工具要留意一点：如果你在文章里使用了中英文混合的url，如我本地的图片 `http://wingjay.com/img/我的博客.png`，它会变成 `http://wingjay.com/img/ 我的博客.png`，因此，这里推荐所有图片等资源的url都使用英文。\n\n## 相关文章推荐\n原生的 Hexo 等第三方博客框架并不能提供 `相关文章推荐` 的功能，而对于一款产品而言，增加用户的使用时间是非常好的。\n\n博客也是，当一位读者读完你的某篇文章感觉不错时，再推荐一些相关的文章，读者点击的几率是非常大的。\n\n在连续读完几遍文章后，读者便对你形成了基本的印象：xxx 作者在 Android 方面的 xxx 技术点有不少的研究，以后可以来多关注关注。\n\n下面讲解下如何实现 `相关文章推荐` 功能。\n\n基本思路是：\n1. 改造 hexo theme 里的`博客模板`文件，在模板底部添加一块 html/swig 片段；\n2. 利用 Hexo 提供的 `Helper` 功能，使用 `javascript` 去获取几篇相似文章的链接；\n3. 此处的 `相似`，可以找出相同 tag 的文章，也可以通过其他指标来定义；\n4. 找到了文章列表后，填充在文章模板底部即可。\n\n具体代码实现如下：\n\n0. 先阅读 Hexo 提供的`Helper`功能，https://hexo.io/zh-cn/api/helper.html\n1. 向 `Helper` 里注册函数 `related_posts`，用来抓取相关文章列表。\n进入博客目录的 `themes/next/scripts` 里面，创建 `related_posts.js` 文件，内容如下\n```javascript\n    hexo.extend.helper.register('related_posts', function(currentPost, allPosts){\n        var relatedPosts = [];\n        currentPost.tags.forEach(function (tag) {\n            allPosts.forEach(function (post) {\n                if (isTagRelated(tag.name, post.tags)) {\n                    var relatedPost = {\n                        title: post.title,\n                        path: post.path,\n                        weight: 1\n                    };\n\n                    var index = findItem(relatedPosts, 'path', post.path);\n\n                    if (index != -1) {\n                        relatedPosts[index].weight += 1;\n                    } else{\n                        if (currentPost.path != post.path) {\n                            relatedPosts.push(relatedPost);\n                        };\n                    };\n                };\n            });\n        });\n\n        if (relatedPosts.length == 0) {return ''};\n\n        var result = '<h3>相关文章：</h3><ul class=\"related-posts\">';\n        relatedPosts = relatedPosts.sort(compare('weight'));\n        for (var i = 0; i < Math.min(relatedPosts.length, 10); i++) {\n            result += '<li><a href=\"/' + relatedPosts[i].path + '\">' + relatedPosts[i].title + '</a></li>';\n        };\n        result += '</ul>';\n\n        // console.log(relatedPosts);\n        return result;\n    });\n\n    hexo.extend.helper.register('echo', function(path){\n      return path;\n    });\n\n    function isTagRelated (tagName, TBDtags) {\n        var result = false;\n        TBDtags.forEach(function (tag) {\n            if (tagName == tag.name) {\n                result = true;\n            };\n        })\n\n        return result;\n    }\n\n    function findItem (arrayToSearch, attr, val) {\n        for (var i = 0; i < arrayToSearch.length; i++) {\n            if (arrayToSearch[i][attr] == val) {\n                return i\n            };\n        };\n\n        return -1;\n    }\n\n    function compare (attr) {\n        return function (a, b) {\n            var val1 = a[attr];\n            var val2 = b[attr];\n            return val2 - val1;\n        }\n    }\n```\n2. 修改文章模板 theme/next/layout/_macro/post.swig。在文章底部添加：\n```\n{% if not is_index %} // 不需要显示在首页。\n\t{{ related_posts(post, site.posts) }} // 调用 related_posts\n{% endif %}\n```\n注意，如果是 ejs 文件，则要把`{ { }}`换成\"<\\%- \\%>\"格式，这是 swig 和 ejs 的语法差别。\n\n重新 generate 即可以看到文章底部出现了相关文章推荐。如果想要修改UI，可以在上面的 `related_posts.js` 里返回的 html 片段里添加一些 css 即可。\n\n## 基于GitHub Issue来实现评论功能\n个人博客里的评论功能一直是个很麻烦的存在，博主也一直在寻找合适的解决方案。\n\n“多说”挺好用的，但是今年关闭了；“disqus”是第二个选择，简洁美观，但tm国内经常不打开；“网易云跟帖”也不错，本来是个很好的选择，不过里面的广告留言超级多，过滤机制不好。\n\n本来我都已经放弃了，不过突发奇想，既然我的整个博客都是架在 GitHub 上，那么能不能让 GitHub 来帮我管理评论呢？对于一条评论而言，要能够实现：\n1. 创建评论\n2. 展示评论\n3. 能够过滤广告评论\n\n然后，我想到了 GitHub Issue 和 GitHub API。\n\n不过我几乎没见过国内有博主这么做，于是搜了些国外的文章，做了些调研，果然发现国外也有开发者做过这样的尝试，而且效果我感觉还不错。\n\n具体有两种实现方案：\n1. 读者直接在阅读个人博客时，直接登录 Github 并在文章页面进行评论；\n2. 读者跳转到博客对应的 Github issue处，在 issue 下进行评论，文章展示时会实时获取评论数据。\n\n第一处的用户体验比较好，但是要管理 Github 的第三方登录机制相对麻烦，而且我认为带来的好处没有那么明显。因此我采取了第二种方案，读者跳转到 GitHub Issue 进行评论，文章中利用 Github API 来拉取最新的评论数据。\n\n可以参考文末的评论区，也可以尝试点击到 GitHub Issue 进行评论，给出建议。\n\n实现代码如下：\n1. 在 `themes/myNext/layout/_partials` 创建一个评论 html 片段：`github-comments.swig`，它会自动去 Github 拉取相关的评论，你可以更改`$.ajax(\"https://api.github.com/repos/wingjay/wingjay.github.io/issues/1/comments\",`这句里的 issue url，放上你自己的Github地址。另外，评论里面的 UI 是我自己模仿 GitHub Issue 写的，就是为了保持一个一致性。\n```\n<!doctype html>\n<html>\n<div class=\"clearfix\"></div>\n<br>\n<div id=\"comments\">\n<div class=\"post-header bg-{{site.default_post_color}}\">\n  <h1 class=\"h1 post-title\">评论</h1>\n</div>\n\n<article class=\"post-content\">\n<p>本站评论搭建在 Github Issue 上，请前往 <a href=\"https://github.com/wingjay/wingjay.github.io/issues/1/{{page.commentIssueId}}\">  此文issue</a> 进行评论。（你需要有 Github 账号）<br/>\nWant to leave a comment? Visit <a href=\"https://github.com/wingjay/wingjay.github.io/issues/1/{{page.commentIssueId}}\"> this post's issue page on GitHub</a> (you'll need a GitHub account).</p>\n</article>\n</div>\n\n<style type=\"text/css\">\n.timeline-comment-wrapper {\n    margin-top: 0;\n    position: relative;\n    padding-left: 60px;\n    margin-top: 15px;\n    margin-bottom: 15px;\n    border-top: 2px solid #fff;\n    border-bottom: 2px solid #fff;\n}\n.timeline-comment-avatar {\n    float: left;\n    margin-left: -60px;\n    border-radius: 3px;\n}\n.avatar-parent-child {\n    position: relative;\n}\n.timeline-comment-wrapper a {\n    color: #0366d6;\n    text-decoration: none;\n    background-color: transparent;\n}\n.timeline-comment-wrapper .avatar {\n    display: inline-block;\n    overflow: hidden;\n    line-height: 1;\n    vertical-align: middle;\n    border-radius: 3px;\n}\n.timeline-comment-wrapper .rounded-1 {\n    border-radius: 3px !important;\n}\n.timeline-comment.current-user {\n    border-color: #c0d3eb;\n}\n.timeline-comment {\n    position: relative;\n    background-color: #fff;\n    border: 1px solid #d1d5da;\n    border-radius: 3px;\n}\n.timeline-comment.current-user .timeline-comment-header {\n    background-color: #f1f8ff;\n    border-bottom-color: #c0d3eb;\n}\n.timeline-comment-header {\n    padding-right: 15px;\n    padding-left: 15px;\n    color: #586069;\n    background-color: #f6f8fa;\n    border-bottom: 1px solid #d1d5da;\n    border-top-left-radius: 3px;\n    border-top-right-radius: 3px;\n}\n.timeline-comment-header-text {\n    padding-top: 10px;\n    padding-bottom: 10px;\n}\n.timeline-comment-header h3 {\n    margin-top: 0px;\n    margin-bottom: 0px;\n}\n.timeline-comment-header-text .post-meta {\n    margin-left: 6px;\n}\n.timeline-comment article p {\n    margin: 0px;\n}\n.text-normal {\n    font-weight: normal !important;\n}\n.f5 {\n    font-size: 14px !important;\n}\n</style>\n\n\n\n<script type=\"text/javascript\">\n  function loadComments(data) {\n    for (var i=0; i<data.length; i++) {\n      var cuser = data[i].user.login;\n      var cuserlink = data[i].user.html_url;\n      var avatarlink = data[i].user.avatar_url;\n      var clink = data[i].html_url;\n      var cbody = data[i].body_html;\n      var cavatarlink = data[i].user.avatar_url;      \n      var cdate = new Date(data[i].created_at);\n      var dopts = { month: 'short', day: 'numeric', year: 'numeric' }\n\n      $(\"#comments\").append('<div class=\"timeline-comment-wrapper\"><div class=\"avatar-parent-child timeline-comment-avatar\"><a href=\"' + cuserlink +'\"><img width=\"44\" height=\"44\" class=\"avatar rounded-1\" src=\"' + avatarlink + '\"></a></div><div class=\"timeline-comment current-user\"><div class=\"timeline-comment-header\"><h3 class=\"timeline-comment-header-text text-normal f5\"><strong>' + cuser + '</strong><span class=\"post-meta\">' + cdate.toLocaleDateString(\"en\", dopts) + '</span></h3></div><div style=\"display: block !important; padding: 15px;\"><article class=\"post-content\">' + cbody + '</article></div></div></div>');\n    }\n  }\n  console.log('start load');\n  $.ajax(\"https://api.github.com/repos/wingjay/wingjay.github.io/issues/1/comments\", {\n    headers: {Accept: \"application/vnd.github.v3.html+json\"},\n    dataType: \"json\",\n    success: function(msg){\n      console.log(msg);\n      loadComments(msg);\n   }\n  });\n</script>\n</html>\n```\n2. 然后把上面的html片段放入文章模板里面。`themes/myNext/layout/_macro/post.swig`\n```\n{% if page.commentIssueId %}\n  {% include '../_partials/github-comments.swig' %}\n{% endif %}\n```\n3. 由于上面的 js 代码里用到了 jQuery 的 ajax 语法，因此，还要在 `themes/myNext/layout/_partials/head.swig` 加载 jQuery，此处使用的是国内的 CDN url，加载时间 30ms。\n```\n{% if page.commentIssueId %}\n  <script src=\"https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js\"></script>\n{% endif %}\n```\n4. 在 Github 为文章创建一个 Issue，可以得到一个 Issue ID，在写文章时的 markdown 顶部加入 commentIssueId，值为刚刚得到的 Issue ID。\n```\ntitle: 自己动手改造个人博客\ndate: 2017-06-08 12:12:37\ncommentIssueId: 1  \n```\n本文对应的 Issue 就是 https://github.com/wingjay/wingjay.github.io/issues/1 。\n\n\n## 个人简历页面\n对于一个优秀的博主而言，每天会有很多开发者进入到他的博客。\n\n而无论出于职业生涯还是个人影响力的角度考虑，在博客里放置个人简历是一个很好的展示自己的机会。\n\n下面我们来利用 `hexo` 的 `page` 功能来创建一个新页面，然后用 markdown 来填充这个简历页面。\n\n1. 利用 `hexo new page \"resume\"`，可以看到 `source` 文件夹下出现了 `resume` 目录，里面有一个 `index.md` 文件；\n2. 在 `themes/next/_config.yml` 里的 `menu:` 下添加 `resume: /resume`，它会在首页创建一个新的 menu: resume 入口；\n3. 在 `index.md` 文件里填写自己的简历即可。\n\n最终效果参考本人[简历](/resume)\n  \n## RSS订阅\n目前很多人喜欢用 RSS 阅读器来实时更新某些作者的文章，如果你希望有更多死忠粉，那 RSS 是非常好的渠道把你的文章快速传达给你的读者。\n\n这里我们利用插件 [`hexo-generator-feed`](https://github.com/hexojs/hexo-generator-feed) 来实现这个功能。\n\n1. 安装\nnpm install hexo-generator-feed --save\n2. 修改 _config.yml，具体设置可以参考官方链接里的指示\n```\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n  hub:\n  content:\n```\n3. 在 themes/next/_config.yml 里的 menu 添加 \nrss: /atom.xml\n4. 在 themes/next/languages/zh-Hans.yml 里的 menu 添加中文翻译\nrss: RSS\n\n重新 generate 一下即可看到。\n\n\n## 总结\n好了，这次的功能性博客改造告一段落，欢迎读者提出意见想法。\n\n之后还会对博客做一些加载速度、图片及js文件加载方式等的优化，偏向于流畅性和加载方面。\n\n下次见。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n## 参考文章\n《[Hexo相关文章的代码实现](https://ethanblog.com/tech/hexo-related-posts.html)》\n《[next主题的模板引擎swig语法介绍](http://jinfang.oschina.io/posts/124966c9/)》\n《[Using GitHub to host blog comments: a working example](http://hydroecology.net/using-github-to-host-blog-comments/)》\n《[GitHub hosted comments for GitHub hosted blogs](http://ivanzuzak.info/2011/02/18/github-hosted-comments-for-github-hosted-blogs.html)》\n《[博客优化点汇总](https://imququ.com/post/summary-of-my-blog-optimization.html)》\n","source":"_posts/自己动手改造个人博客.md","raw":"title: 自己动手改造个人博客\ndate: 2017-06-08 12:12:37\npermalink: rebuild-personal-blog\ncategories:\n  - 个人博客\n  - 一天变cool\ntags:\n  - GitHub\n  - Blog\n  - Hexo\n  - 个人博客\n  - 一天变cool\ncommentIssueId: 1  \n---\n\n个人博客不仅是个人写作的地方，更是一个展示自己个性、扩大个人影响力的产品。\n\n之前我写过一篇《[如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客](http://www.jianshu.com/p/99665608d295)》帮助不少人从零开始搭建了自己的博客。而今天想做的是把博客当成个人产品来进行迭代开发，以更好地展示个人形象。\n\n<!-- more -->\n\n下面我将介绍一些关于个人博客的新功能，以及实现功能的过程。[注：建议进入[原文阅读](http://wingjay.com/2017/06/08/rebuild-personal-blog/)，可以查看到功能的具体效果。本站搭建在 Hexo 平台上]\n- 中英文自动添加空格\n- 推荐相关文章\n- 基于GitHub Issue来实现评论功能\n- 个人简历页面\n- RSS订阅\n\n\n## 中英文自动添加空格\n不少有追求的开发者在写博客时追求格式优雅，比如`中英文间隔`。为了达到这个目的，很多时候就不得不在写文时反复调整英文单词与中文的空格。\n\n这里介绍一个小巧的插件：[Auto-Spacing](https://github.com/hexojs/hexo-filter-auto-spacing)，它会在 markdown 文章转化成 html 时，自动为中英文添加空格。\n\n安装方法：\n在项目根目录下，执行 \n```\nnpm install hexo-filter-auto-spacing --save\n```\n\n执行完后可以在根目录的 `package.json` 里找到一行 \n\n```\ndenpendency`:`\"hexo-filter-auto-spacing\": \"^0.2.1\"\n```\n\n**提醒**\n使用这个工具要留意一点：如果你在文章里使用了中英文混合的url，如我本地的图片 `http://wingjay.com/img/我的博客.png`，它会变成 `http://wingjay.com/img/ 我的博客.png`，因此，这里推荐所有图片等资源的url都使用英文。\n\n## 相关文章推荐\n原生的 Hexo 等第三方博客框架并不能提供 `相关文章推荐` 的功能，而对于一款产品而言，增加用户的使用时间是非常好的。\n\n博客也是，当一位读者读完你的某篇文章感觉不错时，再推荐一些相关的文章，读者点击的几率是非常大的。\n\n在连续读完几遍文章后，读者便对你形成了基本的印象：xxx 作者在 Android 方面的 xxx 技术点有不少的研究，以后可以来多关注关注。\n\n下面讲解下如何实现 `相关文章推荐` 功能。\n\n基本思路是：\n1. 改造 hexo theme 里的`博客模板`文件，在模板底部添加一块 html/swig 片段；\n2. 利用 Hexo 提供的 `Helper` 功能，使用 `javascript` 去获取几篇相似文章的链接；\n3. 此处的 `相似`，可以找出相同 tag 的文章，也可以通过其他指标来定义；\n4. 找到了文章列表后，填充在文章模板底部即可。\n\n具体代码实现如下：\n\n0. 先阅读 Hexo 提供的`Helper`功能，https://hexo.io/zh-cn/api/helper.html\n1. 向 `Helper` 里注册函数 `related_posts`，用来抓取相关文章列表。\n进入博客目录的 `themes/next/scripts` 里面，创建 `related_posts.js` 文件，内容如下\n```javascript\n    hexo.extend.helper.register('related_posts', function(currentPost, allPosts){\n        var relatedPosts = [];\n        currentPost.tags.forEach(function (tag) {\n            allPosts.forEach(function (post) {\n                if (isTagRelated(tag.name, post.tags)) {\n                    var relatedPost = {\n                        title: post.title,\n                        path: post.path,\n                        weight: 1\n                    };\n\n                    var index = findItem(relatedPosts, 'path', post.path);\n\n                    if (index != -1) {\n                        relatedPosts[index].weight += 1;\n                    } else{\n                        if (currentPost.path != post.path) {\n                            relatedPosts.push(relatedPost);\n                        };\n                    };\n                };\n            });\n        });\n\n        if (relatedPosts.length == 0) {return ''};\n\n        var result = '<h3>相关文章：</h3><ul class=\"related-posts\">';\n        relatedPosts = relatedPosts.sort(compare('weight'));\n        for (var i = 0; i < Math.min(relatedPosts.length, 10); i++) {\n            result += '<li><a href=\"/' + relatedPosts[i].path + '\">' + relatedPosts[i].title + '</a></li>';\n        };\n        result += '</ul>';\n\n        // console.log(relatedPosts);\n        return result;\n    });\n\n    hexo.extend.helper.register('echo', function(path){\n      return path;\n    });\n\n    function isTagRelated (tagName, TBDtags) {\n        var result = false;\n        TBDtags.forEach(function (tag) {\n            if (tagName == tag.name) {\n                result = true;\n            };\n        })\n\n        return result;\n    }\n\n    function findItem (arrayToSearch, attr, val) {\n        for (var i = 0; i < arrayToSearch.length; i++) {\n            if (arrayToSearch[i][attr] == val) {\n                return i\n            };\n        };\n\n        return -1;\n    }\n\n    function compare (attr) {\n        return function (a, b) {\n            var val1 = a[attr];\n            var val2 = b[attr];\n            return val2 - val1;\n        }\n    }\n```\n2. 修改文章模板 theme/next/layout/_macro/post.swig。在文章底部添加：\n```\n{% if not is_index %} // 不需要显示在首页。\n\t{{ related_posts(post, site.posts) }} // 调用 related_posts\n{% endif %}\n```\n注意，如果是 ejs 文件，则要把`{ { }}`换成\"<\\%- \\%>\"格式，这是 swig 和 ejs 的语法差别。\n\n重新 generate 即可以看到文章底部出现了相关文章推荐。如果想要修改UI，可以在上面的 `related_posts.js` 里返回的 html 片段里添加一些 css 即可。\n\n## 基于GitHub Issue来实现评论功能\n个人博客里的评论功能一直是个很麻烦的存在，博主也一直在寻找合适的解决方案。\n\n“多说”挺好用的，但是今年关闭了；“disqus”是第二个选择，简洁美观，但tm国内经常不打开；“网易云跟帖”也不错，本来是个很好的选择，不过里面的广告留言超级多，过滤机制不好。\n\n本来我都已经放弃了，不过突发奇想，既然我的整个博客都是架在 GitHub 上，那么能不能让 GitHub 来帮我管理评论呢？对于一条评论而言，要能够实现：\n1. 创建评论\n2. 展示评论\n3. 能够过滤广告评论\n\n然后，我想到了 GitHub Issue 和 GitHub API。\n\n不过我几乎没见过国内有博主这么做，于是搜了些国外的文章，做了些调研，果然发现国外也有开发者做过这样的尝试，而且效果我感觉还不错。\n\n具体有两种实现方案：\n1. 读者直接在阅读个人博客时，直接登录 Github 并在文章页面进行评论；\n2. 读者跳转到博客对应的 Github issue处，在 issue 下进行评论，文章展示时会实时获取评论数据。\n\n第一处的用户体验比较好，但是要管理 Github 的第三方登录机制相对麻烦，而且我认为带来的好处没有那么明显。因此我采取了第二种方案，读者跳转到 GitHub Issue 进行评论，文章中利用 Github API 来拉取最新的评论数据。\n\n可以参考文末的评论区，也可以尝试点击到 GitHub Issue 进行评论，给出建议。\n\n实现代码如下：\n1. 在 `themes/myNext/layout/_partials` 创建一个评论 html 片段：`github-comments.swig`，它会自动去 Github 拉取相关的评论，你可以更改`$.ajax(\"https://api.github.com/repos/wingjay/wingjay.github.io/issues/1/comments\",`这句里的 issue url，放上你自己的Github地址。另外，评论里面的 UI 是我自己模仿 GitHub Issue 写的，就是为了保持一个一致性。\n```\n<!doctype html>\n<html>\n<div class=\"clearfix\"></div>\n<br>\n<div id=\"comments\">\n<div class=\"post-header bg-{{site.default_post_color}}\">\n  <h1 class=\"h1 post-title\">评论</h1>\n</div>\n\n<article class=\"post-content\">\n<p>本站评论搭建在 Github Issue 上，请前往 <a href=\"https://github.com/wingjay/wingjay.github.io/issues/1/{{page.commentIssueId}}\">  此文issue</a> 进行评论。（你需要有 Github 账号）<br/>\nWant to leave a comment? Visit <a href=\"https://github.com/wingjay/wingjay.github.io/issues/1/{{page.commentIssueId}}\"> this post's issue page on GitHub</a> (you'll need a GitHub account).</p>\n</article>\n</div>\n\n<style type=\"text/css\">\n.timeline-comment-wrapper {\n    margin-top: 0;\n    position: relative;\n    padding-left: 60px;\n    margin-top: 15px;\n    margin-bottom: 15px;\n    border-top: 2px solid #fff;\n    border-bottom: 2px solid #fff;\n}\n.timeline-comment-avatar {\n    float: left;\n    margin-left: -60px;\n    border-radius: 3px;\n}\n.avatar-parent-child {\n    position: relative;\n}\n.timeline-comment-wrapper a {\n    color: #0366d6;\n    text-decoration: none;\n    background-color: transparent;\n}\n.timeline-comment-wrapper .avatar {\n    display: inline-block;\n    overflow: hidden;\n    line-height: 1;\n    vertical-align: middle;\n    border-radius: 3px;\n}\n.timeline-comment-wrapper .rounded-1 {\n    border-radius: 3px !important;\n}\n.timeline-comment.current-user {\n    border-color: #c0d3eb;\n}\n.timeline-comment {\n    position: relative;\n    background-color: #fff;\n    border: 1px solid #d1d5da;\n    border-radius: 3px;\n}\n.timeline-comment.current-user .timeline-comment-header {\n    background-color: #f1f8ff;\n    border-bottom-color: #c0d3eb;\n}\n.timeline-comment-header {\n    padding-right: 15px;\n    padding-left: 15px;\n    color: #586069;\n    background-color: #f6f8fa;\n    border-bottom: 1px solid #d1d5da;\n    border-top-left-radius: 3px;\n    border-top-right-radius: 3px;\n}\n.timeline-comment-header-text {\n    padding-top: 10px;\n    padding-bottom: 10px;\n}\n.timeline-comment-header h3 {\n    margin-top: 0px;\n    margin-bottom: 0px;\n}\n.timeline-comment-header-text .post-meta {\n    margin-left: 6px;\n}\n.timeline-comment article p {\n    margin: 0px;\n}\n.text-normal {\n    font-weight: normal !important;\n}\n.f5 {\n    font-size: 14px !important;\n}\n</style>\n\n\n\n<script type=\"text/javascript\">\n  function loadComments(data) {\n    for (var i=0; i<data.length; i++) {\n      var cuser = data[i].user.login;\n      var cuserlink = data[i].user.html_url;\n      var avatarlink = data[i].user.avatar_url;\n      var clink = data[i].html_url;\n      var cbody = data[i].body_html;\n      var cavatarlink = data[i].user.avatar_url;      \n      var cdate = new Date(data[i].created_at);\n      var dopts = { month: 'short', day: 'numeric', year: 'numeric' }\n\n      $(\"#comments\").append('<div class=\"timeline-comment-wrapper\"><div class=\"avatar-parent-child timeline-comment-avatar\"><a href=\"' + cuserlink +'\"><img width=\"44\" height=\"44\" class=\"avatar rounded-1\" src=\"' + avatarlink + '\"></a></div><div class=\"timeline-comment current-user\"><div class=\"timeline-comment-header\"><h3 class=\"timeline-comment-header-text text-normal f5\"><strong>' + cuser + '</strong><span class=\"post-meta\">' + cdate.toLocaleDateString(\"en\", dopts) + '</span></h3></div><div style=\"display: block !important; padding: 15px;\"><article class=\"post-content\">' + cbody + '</article></div></div></div>');\n    }\n  }\n  console.log('start load');\n  $.ajax(\"https://api.github.com/repos/wingjay/wingjay.github.io/issues/1/comments\", {\n    headers: {Accept: \"application/vnd.github.v3.html+json\"},\n    dataType: \"json\",\n    success: function(msg){\n      console.log(msg);\n      loadComments(msg);\n   }\n  });\n</script>\n</html>\n```\n2. 然后把上面的html片段放入文章模板里面。`themes/myNext/layout/_macro/post.swig`\n```\n{% if page.commentIssueId %}\n  {% include '../_partials/github-comments.swig' %}\n{% endif %}\n```\n3. 由于上面的 js 代码里用到了 jQuery 的 ajax 语法，因此，还要在 `themes/myNext/layout/_partials/head.swig` 加载 jQuery，此处使用的是国内的 CDN url，加载时间 30ms。\n```\n{% if page.commentIssueId %}\n  <script src=\"https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js\"></script>\n{% endif %}\n```\n4. 在 Github 为文章创建一个 Issue，可以得到一个 Issue ID，在写文章时的 markdown 顶部加入 commentIssueId，值为刚刚得到的 Issue ID。\n```\ntitle: 自己动手改造个人博客\ndate: 2017-06-08 12:12:37\ncommentIssueId: 1  \n```\n本文对应的 Issue 就是 https://github.com/wingjay/wingjay.github.io/issues/1 。\n\n\n## 个人简历页面\n对于一个优秀的博主而言，每天会有很多开发者进入到他的博客。\n\n而无论出于职业生涯还是个人影响力的角度考虑，在博客里放置个人简历是一个很好的展示自己的机会。\n\n下面我们来利用 `hexo` 的 `page` 功能来创建一个新页面，然后用 markdown 来填充这个简历页面。\n\n1. 利用 `hexo new page \"resume\"`，可以看到 `source` 文件夹下出现了 `resume` 目录，里面有一个 `index.md` 文件；\n2. 在 `themes/next/_config.yml` 里的 `menu:` 下添加 `resume: /resume`，它会在首页创建一个新的 menu: resume 入口；\n3. 在 `index.md` 文件里填写自己的简历即可。\n\n最终效果参考本人[简历](/resume)\n  \n## RSS订阅\n目前很多人喜欢用 RSS 阅读器来实时更新某些作者的文章，如果你希望有更多死忠粉，那 RSS 是非常好的渠道把你的文章快速传达给你的读者。\n\n这里我们利用插件 [`hexo-generator-feed`](https://github.com/hexojs/hexo-generator-feed) 来实现这个功能。\n\n1. 安装\nnpm install hexo-generator-feed --save\n2. 修改 _config.yml，具体设置可以参考官方链接里的指示\n```\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n  hub:\n  content:\n```\n3. 在 themes/next/_config.yml 里的 menu 添加 \nrss: /atom.xml\n4. 在 themes/next/languages/zh-Hans.yml 里的 menu 添加中文翻译\nrss: RSS\n\n重新 generate 一下即可看到。\n\n\n## 总结\n好了，这次的功能性博客改造告一段落，欢迎读者提出意见想法。\n\n之后还会对博客做一些加载速度、图片及js文件加载方式等的优化，偏向于流畅性和加载方面。\n\n下次见。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n## 参考文章\n《[Hexo相关文章的代码实现](https://ethanblog.com/tech/hexo-related-posts.html)》\n《[next主题的模板引擎swig语法介绍](http://jinfang.oschina.io/posts/124966c9/)》\n《[Using GitHub to host blog comments: a working example](http://hydroecology.net/using-github-to-host-blog-comments/)》\n《[GitHub hosted comments for GitHub hosted blogs](http://ivanzuzak.info/2011/02/18/github-hosted-comments-for-github-hosted-blogs.html)》\n《[博客优化点汇总](https://imququ.com/post/summary-of-my-blog-optimization.html)》\n","slug":"rebuild-personal-blog","published":1,"updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm0v000jmoyxboq9bzi1","sticky":0},{"title":"独立全端开发的开源小作：简诗 2.0","date":"2016-11-26T12:11:03.000Z","commentIssueId":11,"_content":"> 简诗是自己的一份追求，对美好设计、全面技术的追求。\n\n<!-- more -->\n\n## 缘由\n大家好，我是 wingjay ，软件工程师，热爱全栈。\n\n简诗 是自己业余时间做的一款优雅、纯粹的文字 Android App ，传统纵书风格，以求为用户带来更质朴的书写体验。加之现有文字 App 要么过于复杂，要么界面不够特色，更促成简诗的诞生。\n\n>下载地址： http://fir.im/vd1r 。 GitHub 开源： https://github.com/wingjay/jianshi\n\n\n简诗 的想法最初来源于我阅读的一本来自 Kevin 的书《 Producter 》，书中介绍了 iOS 小记的开发设计过程。唯一的缺憾是没有开发 Android 版本。因此我联系 Kevin 并获取了开发 Android 版本的授权。\n\n简诗 主要由我独自开发，包括 Android 和 Server 端的，主要利用如周末或平时晚上的业余时间。开发的过程是比较累的，很多周末要熬夜到很晚；但也是充满惊喜的，因为里面有不少来自自己的灵感创意。\n\n抛开天天用的 Google Material Design ，不断思考新鲜的设计并从工程角度去实现它，这总是非常有成就感的。\n\n简诗 2.0 最主要的功能是登录注册、数据云同步。由于 1.0 是单机版，所以数据云备份这一点是最多用户反馈的。也正是这个需求，我决定重新为 简诗 搭建后台，实现数据云存储。也正是因为有了后台支持，简诗 添加了很多以前无法实现的功能，比如无限多实时更新的首页图片和三行诗等等。\n\n希望简诗质朴传统的中国风特质能让用户重新感受到文字的美好，在形影寂寞时，找回一点温暖。\n\n## 入选最美应用\n多谢最美应用对简诗的喜爱，并发表了这篇产品推介采访稿[《简诗—他在业余时间开发的这款「Android 版小记」，带你重新找回写作的乐趣》](http://zuimeia.com/app/4638/)。下面截取采访部分供大家阅读。\n\n**最美应用**：来给大家介绍一下自己吧\n**尹捷** ：大家好，我叫尹捷（wingjay），上海交通大学硕士毕业，软件工程师一枚，现居上海。\n\n**最美应用**： 除了工作，平时喜欢如何规划业余时间呢？\n**尹捷** ： 天气好的话我会在城市里徒步或去户外爬山，摄影；天气不好就宅在家中，开着音响听音乐，下厨、看电影、写代码、看书。\n\n**最美应用**： 开发简诗的初衷是怎样的呢？\n**尹捷** ： 简诗最初的设计稿来自《Producter》一书，该书介绍了 iOS 版小记的开发过程，不过可惜没有 Android 版本，因此我联系小记作者，获取了 Android 版开发授权。\n\n浓郁的中国风色彩和极简的设计风格，是我开发简诗最本质的原因。\n\n作为一名开发者，我看过很多设计风格的App，例如 Google 自家的 Material Design，Apple 的扁平化，锤子的拟物化。相比而言，简诗的设计思路和它们都不一样：别致的中国风纵书体验，大片留白的日式设计理念，体现浓郁传统中国文化的细节，都使得简诗与众不同。\n\n开发一款如此别具一格的 App，在我看来，是一件非常酷的事情。\n\n**最美应用**： 开发过程中，你遇到过哪些有意思的事情，或者是难题？\n**尹捷** ： 简诗的开发主要包括三方面：设计、Android 端、服务端。\n\n－ 设计：在最初《Producter》的设计草稿基础上，我对整个使用体验做了进一步优化：剔除了原始选择年、月、日的步骤；在首页添加实时变化的三行小诗；在撰写页面根据当前时间如正午、夜半，显示不同的提示语以让用户感觉更为亲近；支持更换背景颜色，色值取自中国传统颜色如素、月白、水红等；文章列表页面仿照古代书籍目录设计；分享时会自动生成简诗的印章，借鉴了传统书画作品中的印章；首页添加实时变化背景图片，这些图片均来自全球优质的摄影作品 UnSplash 网站。\n\n－ Android 端：Android 端采用了当前最为流行的移动架构和依赖，运行稳定，代码结构简洁，crash 率只有 0.1% ~ 0.3%，开发比较顺利，没有遇到什么难题。\n\n－ 服务端：本人之前有完整的 PHP 后端开发经验，所以如果采用 PHP 开发的话难度会小很多；不过我最终选择了自己不熟悉的 Python 来进行服务端开发，这给我带来了一些挑战。之所以采用 Python 有两个原因：一是对 Python 这门语言的好奇，软件工程师总是对未知领域充满好奇并想去探索；二是希望通过不同语言的服务端开发，来提升自己对服务端架构的理解。\n\n**最美应用**： 作为一名职业软件工程师，在开发简诗的过程中，是如何分配自己的时间精力的呢？\n**尹捷** ： 简诗 v2.0 的开发主要利用我周末的时间。总共花了三到四个周末，即六天到八天左右，完成了 Android 版本和服务端的开发。开发后段我的一位好友：Ray https://github.com/Panl) 也加入并协助进行了部分开发工作，有几个周六我俩都开发到了大概凌晨四点钟左右，一边阐述自己的产品创意，一边讨论工程实践的可行性，是非常有趣的一段经历。\n\n**最美应用**： 之后，还会对简诗做哪些方面的改进吗？\n**尹捷** ： 目前简诗 v2.0 已经有不少用户了，我们也在积极收集用户的反馈，后面还会有几个大 feature 要做，欢迎期待哦。\n\n**最美应用**： 对简诗有怎样的愿景呢？\n**尹捷** ： 当代的人们逐渐习惯于阅读快速的文字片段，淡忘了写作的体验。而简诗的存在，就是希望让人们重新找回文字的美好之处，重新感受写作的乐趣。或许并非所有人都喜欢简诗，但只要有一部分人，能从简诗里重新感受到文字的温暖，就足够了。\n\n**最美应用**： 来介绍几款自己喜欢或常用的应用吧\n**尹捷** ： Slack + Asana：团队开发效率大幅提高利器\n\nTypora：Mac 端优雅的 Markdown 书写利器\n\nMedium+稀土掘金+湾区日报：阅读优质技术文章，资讯\n\n网易云音乐+落网：前者能为你推荐你喜欢的音乐，后者收集了很多优秀独立音乐人的作品\n\n最美应用 + 豌豆荚一览：优质作品搜索利器\n\nShadowsocks：嗯\n\n**最美应用**： 在软件开发方面，有什么经验心得可以来和大家分享下吗？\n**尹捷** ： 作为一名造诣不够深的开发者，简单分享下两点拙见：\n\n－ 保持开放的心态，如果有可能的话，尝试下全栈。或许全栈这个词已经受到了很多误读，但至少，全栈开发能让你的思维更加全面，让你的思考更贴近工程实际；\n\n－ 追本溯源。我们日常的开发都是基于某些平台或工具，如 Android sdk，Flask 框架或其他开源项目。在熟练使用这些工具之后，我建议还应该去探究它们的实现原理，这样才能真正提高技术水平。\n\n**最美应用**： 还有什么想对大家说的吗？\n**尹捷** ： 作为一名开发者，我也热爱并重视产品设计。平日里会阅读一些如日式设计相关的书籍。不过，我深知自己在设计方面的学识浅的可怜，因此，我希望在业余时间里能和一些优秀的设计师合作，共同开发一些独具匠心的产品给大家使用。\n\n## 截屏\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/1.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/2.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/3.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/4.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/7.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/8.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/5.jpg)\n\n## 开源\n项目开源地址：https://github.com/wingjay/jianshi\n\n\n谢谢！\n\nwingjay\n\n\n","source":"_posts/独立全端开发的开源小作：简诗2-0.md","raw":"title: 独立全端开发的开源小作：简诗2.0\ncategories:\n  - 全栈\n  - Android\n  - Server\ndate: 2016-11-26 20:11:03\ncommentIssueId: 11\n---\n> 简诗是自己的一份追求，对美好设计、全面技术的追求。\n\n<!-- more -->\n\n## 缘由\n大家好，我是 wingjay ，软件工程师，热爱全栈。\n\n简诗 是自己业余时间做的一款优雅、纯粹的文字 Android App ，传统纵书风格，以求为用户带来更质朴的书写体验。加之现有文字 App 要么过于复杂，要么界面不够特色，更促成简诗的诞生。\n\n>下载地址： http://fir.im/vd1r 。 GitHub 开源： https://github.com/wingjay/jianshi\n\n\n简诗 的想法最初来源于我阅读的一本来自 Kevin 的书《 Producter 》，书中介绍了 iOS 小记的开发设计过程。唯一的缺憾是没有开发 Android 版本。因此我联系 Kevin 并获取了开发 Android 版本的授权。\n\n简诗 主要由我独自开发，包括 Android 和 Server 端的，主要利用如周末或平时晚上的业余时间。开发的过程是比较累的，很多周末要熬夜到很晚；但也是充满惊喜的，因为里面有不少来自自己的灵感创意。\n\n抛开天天用的 Google Material Design ，不断思考新鲜的设计并从工程角度去实现它，这总是非常有成就感的。\n\n简诗 2.0 最主要的功能是登录注册、数据云同步。由于 1.0 是单机版，所以数据云备份这一点是最多用户反馈的。也正是这个需求，我决定重新为 简诗 搭建后台，实现数据云存储。也正是因为有了后台支持，简诗 添加了很多以前无法实现的功能，比如无限多实时更新的首页图片和三行诗等等。\n\n希望简诗质朴传统的中国风特质能让用户重新感受到文字的美好，在形影寂寞时，找回一点温暖。\n\n## 入选最美应用\n多谢最美应用对简诗的喜爱，并发表了这篇产品推介采访稿[《简诗—他在业余时间开发的这款「Android 版小记」，带你重新找回写作的乐趣》](http://zuimeia.com/app/4638/)。下面截取采访部分供大家阅读。\n\n**最美应用**：来给大家介绍一下自己吧\n**尹捷** ：大家好，我叫尹捷（wingjay），上海交通大学硕士毕业，软件工程师一枚，现居上海。\n\n**最美应用**： 除了工作，平时喜欢如何规划业余时间呢？\n**尹捷** ： 天气好的话我会在城市里徒步或去户外爬山，摄影；天气不好就宅在家中，开着音响听音乐，下厨、看电影、写代码、看书。\n\n**最美应用**： 开发简诗的初衷是怎样的呢？\n**尹捷** ： 简诗最初的设计稿来自《Producter》一书，该书介绍了 iOS 版小记的开发过程，不过可惜没有 Android 版本，因此我联系小记作者，获取了 Android 版开发授权。\n\n浓郁的中国风色彩和极简的设计风格，是我开发简诗最本质的原因。\n\n作为一名开发者，我看过很多设计风格的App，例如 Google 自家的 Material Design，Apple 的扁平化，锤子的拟物化。相比而言，简诗的设计思路和它们都不一样：别致的中国风纵书体验，大片留白的日式设计理念，体现浓郁传统中国文化的细节，都使得简诗与众不同。\n\n开发一款如此别具一格的 App，在我看来，是一件非常酷的事情。\n\n**最美应用**： 开发过程中，你遇到过哪些有意思的事情，或者是难题？\n**尹捷** ： 简诗的开发主要包括三方面：设计、Android 端、服务端。\n\n－ 设计：在最初《Producter》的设计草稿基础上，我对整个使用体验做了进一步优化：剔除了原始选择年、月、日的步骤；在首页添加实时变化的三行小诗；在撰写页面根据当前时间如正午、夜半，显示不同的提示语以让用户感觉更为亲近；支持更换背景颜色，色值取自中国传统颜色如素、月白、水红等；文章列表页面仿照古代书籍目录设计；分享时会自动生成简诗的印章，借鉴了传统书画作品中的印章；首页添加实时变化背景图片，这些图片均来自全球优质的摄影作品 UnSplash 网站。\n\n－ Android 端：Android 端采用了当前最为流行的移动架构和依赖，运行稳定，代码结构简洁，crash 率只有 0.1% ~ 0.3%，开发比较顺利，没有遇到什么难题。\n\n－ 服务端：本人之前有完整的 PHP 后端开发经验，所以如果采用 PHP 开发的话难度会小很多；不过我最终选择了自己不熟悉的 Python 来进行服务端开发，这给我带来了一些挑战。之所以采用 Python 有两个原因：一是对 Python 这门语言的好奇，软件工程师总是对未知领域充满好奇并想去探索；二是希望通过不同语言的服务端开发，来提升自己对服务端架构的理解。\n\n**最美应用**： 作为一名职业软件工程师，在开发简诗的过程中，是如何分配自己的时间精力的呢？\n**尹捷** ： 简诗 v2.0 的开发主要利用我周末的时间。总共花了三到四个周末，即六天到八天左右，完成了 Android 版本和服务端的开发。开发后段我的一位好友：Ray https://github.com/Panl) 也加入并协助进行了部分开发工作，有几个周六我俩都开发到了大概凌晨四点钟左右，一边阐述自己的产品创意，一边讨论工程实践的可行性，是非常有趣的一段经历。\n\n**最美应用**： 之后，还会对简诗做哪些方面的改进吗？\n**尹捷** ： 目前简诗 v2.0 已经有不少用户了，我们也在积极收集用户的反馈，后面还会有几个大 feature 要做，欢迎期待哦。\n\n**最美应用**： 对简诗有怎样的愿景呢？\n**尹捷** ： 当代的人们逐渐习惯于阅读快速的文字片段，淡忘了写作的体验。而简诗的存在，就是希望让人们重新找回文字的美好之处，重新感受写作的乐趣。或许并非所有人都喜欢简诗，但只要有一部分人，能从简诗里重新感受到文字的温暖，就足够了。\n\n**最美应用**： 来介绍几款自己喜欢或常用的应用吧\n**尹捷** ： Slack + Asana：团队开发效率大幅提高利器\n\nTypora：Mac 端优雅的 Markdown 书写利器\n\nMedium+稀土掘金+湾区日报：阅读优质技术文章，资讯\n\n网易云音乐+落网：前者能为你推荐你喜欢的音乐，后者收集了很多优秀独立音乐人的作品\n\n最美应用 + 豌豆荚一览：优质作品搜索利器\n\nShadowsocks：嗯\n\n**最美应用**： 在软件开发方面，有什么经验心得可以来和大家分享下吗？\n**尹捷** ： 作为一名造诣不够深的开发者，简单分享下两点拙见：\n\n－ 保持开放的心态，如果有可能的话，尝试下全栈。或许全栈这个词已经受到了很多误读，但至少，全栈开发能让你的思维更加全面，让你的思考更贴近工程实际；\n\n－ 追本溯源。我们日常的开发都是基于某些平台或工具，如 Android sdk，Flask 框架或其他开源项目。在熟练使用这些工具之后，我建议还应该去探究它们的实现原理，这样才能真正提高技术水平。\n\n**最美应用**： 还有什么想对大家说的吗？\n**尹捷** ： 作为一名开发者，我也热爱并重视产品设计。平日里会阅读一些如日式设计相关的书籍。不过，我深知自己在设计方面的学识浅的可怜，因此，我希望在业余时间里能和一些优秀的设计师合作，共同开发一些独具匠心的产品给大家使用。\n\n## 截屏\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/1.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/2.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/3.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/4.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/7.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/8.PNG)\n![](https://github.com/wingjay/jianshi/raw/master/material/screenshots/with_phone/5.jpg)\n\n## 开源\n项目开源地址：https://github.com/wingjay/jianshi\n\n\n谢谢！\n\nwingjay\n\n\n","slug":"独立全端开发的开源小作：简诗2-0","published":1,"updated":"2017-06-23T04:06:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm0y000ymoyx6ocvtdry","sticky":0},{"title":"梦想升起的地方","date":"2016-06-06T14:42:14.000Z","_content":"> 交大，你赋予了我很多。\n\n<!-- more -->\n\n![](http://wingjay.com/img/dream.jpg)\n\n好赖，我毕业了🎓。\n\n从本科毕业时懵懂迷茫的自己，到现在坚定方向不为所动的自己。\n\n两三年的磨砺，我成长了非常多。\n\n\n还是那句话，我热爱交大的一草一木，沉静深远，热爱这里共同奋斗努力的同窗好友，热爱每位聪明上进的年轻人。\n\n这一切让我不舍怀念。\n\n然后，生命的车轮总在向前，离别是迟早的。\n\n属于交大的记忆，留在交大。\n\n此刻的我，会继续向前。\n\n在交大，我找到了自己的梦；离开交大，我会将这个梦继续坚持下去。\n\n饮水思源。","source":"_posts/梦想升起的地方.md","raw":"title: 梦想升起的地方\ncategories:\n  - 随感\ntags:\n  - 随笔\ndate: 2016-06-06 22:42:14\n---\n> 交大，你赋予了我很多。\n\n<!-- more -->\n\n![](http://wingjay.com/img/dream.jpg)\n\n好赖，我毕业了🎓。\n\n从本科毕业时懵懂迷茫的自己，到现在坚定方向不为所动的自己。\n\n两三年的磨砺，我成长了非常多。\n\n\n还是那句话，我热爱交大的一草一木，沉静深远，热爱这里共同奋斗努力的同窗好友，热爱每位聪明上进的年轻人。\n\n这一切让我不舍怀念。\n\n然后，生命的车轮总在向前，离别是迟早的。\n\n属于交大的记忆，留在交大。\n\n此刻的我，会继续向前。\n\n在交大，我找到了自己的梦；离开交大，我会将这个梦继续坚持下去。\n\n饮水思源。","slug":"梦想升起的地方","published":1,"updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm110015moyxw4mi8077","sticky":0},{"title":"有趣的曲线在 Android 上的实现","date":"2016-01-25T10:41:43.000Z","commentIssueId":19,"_content":"> 简单的数学原理其实很有趣\n\n<!-- more -->\n直接上图：\n<img src=\"/img/interesting-curve/7.png\" width=\"300\">\n\n几日前在OF Course公众号看到一篇蛮有意思的文章－[简单法则的魅力](http://mp.weixin.qq.com/s?__biz=MzA4NTc5MDU5OQ==&mid=411441608&idx=1&sn=5e846a882f58a7ba1b5312bdbeaafccf&scene=23&srcid=0120GiYhMXjmNDoN9MFQj7f5#rd)，觉得里面的动效很有意思，能够基于简单的数学法则通过修改几个参数便画出千变万化的优美的曲线，实在有趣。而且这篇文章里还给出了代码，简直给力。\n\n于是忍不住，自己动手实现了一下，动态效果图如图，下面给出本人随意得出的其它曲线。\n\n\n\n<img src=\"/img/interesting-curve/ring.gif\" width=\"300\">\n<img src=\"/img/interesting-curve/box.gif\" width=\"300\">\n<img src=\"/img/interesting-curve/1.png\" width=\"300\">\n<img src=\"/img/interesting-curve/2.png\" width=\"300\">\n<img src=\"/img/interesting-curve/3.png\" width=\"300\">\n<img src=\"/img/interesting-curve/4.png\" width=\"300\">\n<img src=\"/img/interesting-curve/5.png\" width=\"300\">\n<img src=\"/img/interesting-curve/6.png\" width=\"300\">\n<img src=\"/img/interesting-curve/7.png\" width=\"300\">\n<img src=\"/img/interesting-curve/8.png\" width=\"300\">\n<img src=\"/img/interesting-curve/9.jpg\" width=\"300\">\n<img src=\"/img/interesting-curve/10.png\" width=\"300\">\n<img src=\"/img/interesting-curve/11.png\" width=\"300\">","source":"_posts/有趣的曲线在Android上的实现.md","raw":"title: 有趣的曲线在Android上的实现\ncategories:\n  - Android\n  - Performance\ntags:\n  - cool\n  - 动效\ndate: 2016-01-25 18:41:43\ncommentIssueId: 19\n---\n> 简单的数学原理其实很有趣\n\n<!-- more -->\n直接上图：\n<img src=\"/img/interesting-curve/7.png\" width=\"300\">\n\n几日前在OF Course公众号看到一篇蛮有意思的文章－[简单法则的魅力](http://mp.weixin.qq.com/s?__biz=MzA4NTc5MDU5OQ==&mid=411441608&idx=1&sn=5e846a882f58a7ba1b5312bdbeaafccf&scene=23&srcid=0120GiYhMXjmNDoN9MFQj7f5#rd)，觉得里面的动效很有意思，能够基于简单的数学法则通过修改几个参数便画出千变万化的优美的曲线，实在有趣。而且这篇文章里还给出了代码，简直给力。\n\n于是忍不住，自己动手实现了一下，动态效果图如图，下面给出本人随意得出的其它曲线。\n\n\n\n<img src=\"/img/interesting-curve/ring.gif\" width=\"300\">\n<img src=\"/img/interesting-curve/box.gif\" width=\"300\">\n<img src=\"/img/interesting-curve/1.png\" width=\"300\">\n<img src=\"/img/interesting-curve/2.png\" width=\"300\">\n<img src=\"/img/interesting-curve/3.png\" width=\"300\">\n<img src=\"/img/interesting-curve/4.png\" width=\"300\">\n<img src=\"/img/interesting-curve/5.png\" width=\"300\">\n<img src=\"/img/interesting-curve/6.png\" width=\"300\">\n<img src=\"/img/interesting-curve/7.png\" width=\"300\">\n<img src=\"/img/interesting-curve/8.png\" width=\"300\">\n<img src=\"/img/interesting-curve/9.jpg\" width=\"300\">\n<img src=\"/img/interesting-curve/10.png\" width=\"300\">\n<img src=\"/img/interesting-curve/11.png\" width=\"300\">","slug":"有趣的曲线在Android上的实现","published":1,"updated":"2017-06-23T04:11:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm160019moyxh5j53hg5","sticky":0},{"title":"我与代码的相知相遇","date":"2015-12-28T16:12:45.000Z","_content":"> 误打误撞进入了计算机的世界，觉得有趣，就一直留在这里\n\n<!-- more -->\n![](https://drscdn.500px.org/photo/3706985/m%3D2048/d9cba44c9d66f27d27e1628fa7f4606c)\n\nHi，我是wingjay\n------------------------------------------------------------------\n大家好，我是[《如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客》](http://www.jianshu.com/p/99665608d295)、[如何在一天之内完成一款具备cool属性的Android产品<简诗>](http://www.jianshu.com/p/cf496fc408b2)的作者[wingjay](https://github.com/wingjay)，今天抽空来和大家一起告别2015，迎接新的技术成长的一年。\n\n\n再过半年，我就要从交大硕士毕业了。\n------------------------------------------------------------------\n2013年9月入学交大，自动化小硕，从没想过未来会从事计算机相关行业，因为对于编程我唯一的背景就是大二那年的C语言课程。\n\n我是怎么开始对编程感兴趣的？不记得了，也不会有人关心。只知道那时逢人就介绍智能手机的硬件配置多么发烧，喜欢调侃小米的成功哲学，也跟风追着“大数据”和“云计算”这两朵云奔跑。\n\n慢慢的，觉得搞计算机的人很酷。\n\n那时，我正式入学。\n\n\n也在那时，我缠着父母给我买了一款手机－小米2s。我记得我对着这款手机盯了快半个小时，乐的。\n\n然后开启了两年的研究生生涯。\n\n没有我想象的顺利，但也没有我想象的不堪。\n\n用两句话来概括这两年吧：\n\n1. 第一年我把除了马克思之外所有的课都认真学了一遍，还选修了诸如机器学习、模式识别和数据挖掘等课程，这一年，感觉踏实。\n\n2. 第二年，30%的时间去提心吊胆地帮导师干杂活；70%的时间背着导师更加提心吊胆地去学习编程，这一年，以为自己会消沉，后来没有。\n\n自学编程的那些日子\n------------------------------------------------------------------\n还是那句话，现在吃的苦，都是当年专业没选计算机时脑子进的水。\n\n2014年初，作为一名只会C语言的我而言，真正开始自学计算机，依次经历了以下几步：\n\n1. 14年3月，师兄说要学编程，先学基础。于是我过了一遍数据结构和操作系统的书，过的比较粗略；\n\n2. 14年4月，想学Android开发，在网上发现了Mars的教程视频。于是我每天只要有空就背着导师偷偷看视频，做笔记。学习Android的同时也顺带着学了些Java的知识。每天晚上还会在新浪博客或博客园上把自己的笔记记录上去，虽然这种做法并没什么作用，但那时觉得很happy。\n\n3. 14年6月，视频自学效果不佳，我非常苦恼。那时我非常希望有人能够来帮帮我这个新手，同时我每天去寻找实践的机会。要知道，作为一名研究生，导师每天管着你，不能放开学，很不爽的。不过，上天眷顾，我终于找到一份校内实习，技术开发，离实验室又近，每天还有80元的工资，天，那几天我感觉我复活了！\n\n4. 14年6月中到11月，开始学习网站开发。校内实习启动，我过上了白天实验室，晚上工作室的日子了。工作室四个人，两个大牛，两个菜鸟，我当然是后者。6月到11月，我饥渴地学习！开始做网站，前端、后端、数据库。这半年我差不多每天是白天在实验室干完活之后晚上去写代码，半年下来，差不多把前端的html、css、js和一些框架Bootstrap、jQuery等，后端的php，和如thinkphp等框架，还有数据库MySQL、MongoDB都学了一通。空闲时也自己配置过服务器，搭建自己的网站。\n\n5. 15年3月到5月，算是开始了Android开发学习之路吧。15年，也就是今年，三月开学时，工作室里两个人离开了，一个是被导师抓走干活了，另一个大三的准备毕业了。于是工作室就只剩我和一位大牛。说实话，有点寂寞，但我的热情并没有减少。相反，我仍旧专注于Android的开发和学习。实验室方面，到了今年，反而轻松了些，每天上午和晚上在工作室，下午跑回实验室蹲班。另外在实际的开发中，我发现以前视频学的东西和实际应用相差很大，可能那些更基础吧，总之我几乎又是从零开始去学习，从项目中自学。\n\n6. 15年5月，我学了近三个月的Android开发，虽然工作室另一位大牛偶尔会帮我，但多数时候还是我一头人默默对着电脑学习、研究和修bug。不过好歹这几个月时间把工作室之前的一款Android应用重新写了一遍，每天晚上学到深夜，冒着寒风骑车回宿舍的场景我记得清楚。最后开发完的应用，工作室的指导老师很满意，我也对自己比较满意。\n\n7. 15年5月中到6月，工作室只剩我一人了。我没有想到，在六月某一天，工作室的顶梁柱大牛说要去北京微软亚研院实习了，意味着整个工作室从最初的四个人只剩下我一个了。那时，我真感觉到有点孤单，看着身边做技术的小伙伴依次离开，到最后竟然只剩我自己一人。不过，我还是照常来工作室开发Android、学习，不过，这时只能一人去食堂吃饭，遇到问题也再没有人来指导，完全靠自己。\n\n8. 15年6月初，迷茫地寻找校外实习。我独自在工作室开发近一个月后，由于即将面临毕业，于是也开始寻找实习。那时摆在我眼前有两条路，大公司；创业公司。对我个人而言，我是追求技术成长的，不希望自己受限于某种技术，所以害怕大公司那种只让我一直从事某个项目的某个方面。所以在我心里，虽知大公司稳妥，但我更偏心于创业型公司。另外我也希望提高自己的英语，也希望有还不错的待遇，希望未来有好的职业发展规划。很多的希望，让我很迷茫，不知道能不能找到真正适合自己的企业。\n\n9. 15年6月中，确定实习公司Glow, 正式离开工作室。终于，我也要离开这个伴随我技术成长的地方了。这期间，我参加了一些公司的面试。大小公司都有，也拿到不少开发岗offer。当然，最后我选择了目前我所在的这家硅谷创业公司－－Glow。说到Glow，我就觉得有缘。一年前，我被Glow的招聘帖吸引，便去关注了公众号，说实话，Glow的Google背景、扁平式氛围一瞬间就吸引了我。不过接下来的一年再也没收到任何关于Glow的招聘信息，所以自己也就淡忘了，加之也觉得自己没戏，所以也就没有多想。直到今年找实习时，在路上走着突然想起这家公司，说实话那时除了Glow这个名字和这家公司很独特之外其他都不记得。于是我回到学校，把bbs重新翻了一遍，竟被我找回了那个招聘帖。之后大家就知道了，投递简历，电话面试，onsite面试。然后很快就入职了。\n\n10. 15年6月中到现在，Glow的Android开发实习生活。因为不想有软文的嫌疑，所以我也就不做太多介绍了。我只想说，在Glow的这半年，我和一堆Google大牛相处，技术成长很快。他们并不介怀我非计算机出身，也不担心我只有几个月的Android的开发背景。我想我唯一的优势就是努力了。开始时我还挺有压力，担心会拖他们的后腿，不过在他们的帮助下和我个人的不懈努力下，现在我已经能够很好的与他们合作，也得到了他们的认可。我最爱Glow的扁平氛围，我相信现在很多创业公司也如此，没有上下级，一心做好产品。\n\n在Glow的这半年，我不用提心吊胆担心导师随时来使唤我，我可以全身心来提高技术，而身边的人都随时准备帮助你。\n\n说实话，我感激自己这两年的坚持，感谢这两年遇到的大牛们。\n\n2016年的技术规划\n------------------------------------------------------------------\n2016年对我而言，是个大年。\n\n正式离开校园，步入工作。\n\n下面，简单列一下我的规划吧：\n\n1. 工作方面。目前我在Glow已经独立负责一整块的开发任务了，包括Android和服务器开发。我希望把自己在开源方面学到的新技术应用到我负责的模块上，持续地提高用户体验和稳定性，为用户提供更棒的作品。这点是我每天都在心心念念的。\n\n2. 个人技术方面。由于Glow不用加班，所以我平常会有很多的个人时间。我当然不准备把这些时间用在看剧和睡觉上。我会多去写作，之前在简书上写的几篇文章[《如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客》](http://www.jianshu.com/p/99665608d295)、[如何在一天之内完成一款具备cool属性的Android产品<简诗>](http://www.jianshu.com/p/cf496fc408b2)收获了不少读者，所以以后会继续努力。同时也会在[个人微博](http://weibo.com/1625892654)和[稀土](http://gold.xitu.io/#/user/562a410800b07d3623109a95)上多多分享优质文章。\n\n3. 开源方面。最近因为又忙实习又忙毕业写论文，就没有花太多时间做开源。只是贡献了两个库：[简诗](https://github.com/wingjay/jianshi) 和[BlurImageView](https://github.com/wingjay/BlurImageView)，加起来快一千个star左右。不过以后还会继续贡献优秀的库和大家分享的。\n\n4. [我的个人博客](http://wingjay.com) http://wingjay.com。\n除了技术，我也会开始提高自己的艺术方面的敏感度。比如开始接触建筑设计、文学方面的，一方面扩大自己的知识面，另一方面也是提高自己的感性思维吧。\n\n最近在读的书\n------------------------------------------------------------------\n1. 《一切始于设计－一个设计师的世博十日手记   －   迪人 著》\n这本书我看到了一位设计师对世界的认知，接触了世界各国的设计思想，如意大利、德国、法国等，收获很大！\n\n2. 《设计中的设计   －   原研哉 著》\n原研哉，无印良品设计总监。感受日本设计思想中留白这一概念，让人重新认识身边的事物。\n\n3. 《Android开发艺术探索  － 任玉刚 著》\n把Android里很多晦涩的概念讲解清楚，超喜欢里面对View的讲解，解开了我一个很大的困惑谜团。\n\n4. 《Android群英传  －  徐宜生 著》\n从实际开发的角度，讲解开发中常见的各种问题，结合上面那本书一起看，差不多能把多数开发问题搞明白。\n\n还有不少书，下次再来推荐吧！\n\n如果你也热爱技术，交个朋友吧\n------------------------------------------------------------------\n我是[wingjay](http://wingjay.com)，你可以通过我的[GitHub](https://github.com/wingjay)或者[简书平台](http://www.jianshu.com/users/da333fd63fe5/latest_articles)来找到我哦。\n\n谢谢！\n\n\n\n\n\n\n\n","source":"_posts/我与代码的相知相遇.md","raw":"title: 我与代码的相知相遇\ncategories:\n  - 随感\ntags:\n  - Goodbye2015 Hi 2016\n  - 随笔\ndate: 2015-12-29 00:12:45\n---\n> 误打误撞进入了计算机的世界，觉得有趣，就一直留在这里\n\n<!-- more -->\n![](https://drscdn.500px.org/photo/3706985/m%3D2048/d9cba44c9d66f27d27e1628fa7f4606c)\n\nHi，我是wingjay\n------------------------------------------------------------------\n大家好，我是[《如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客》](http://www.jianshu.com/p/99665608d295)、[如何在一天之内完成一款具备cool属性的Android产品<简诗>](http://www.jianshu.com/p/cf496fc408b2)的作者[wingjay](https://github.com/wingjay)，今天抽空来和大家一起告别2015，迎接新的技术成长的一年。\n\n\n再过半年，我就要从交大硕士毕业了。\n------------------------------------------------------------------\n2013年9月入学交大，自动化小硕，从没想过未来会从事计算机相关行业，因为对于编程我唯一的背景就是大二那年的C语言课程。\n\n我是怎么开始对编程感兴趣的？不记得了，也不会有人关心。只知道那时逢人就介绍智能手机的硬件配置多么发烧，喜欢调侃小米的成功哲学，也跟风追着“大数据”和“云计算”这两朵云奔跑。\n\n慢慢的，觉得搞计算机的人很酷。\n\n那时，我正式入学。\n\n\n也在那时，我缠着父母给我买了一款手机－小米2s。我记得我对着这款手机盯了快半个小时，乐的。\n\n然后开启了两年的研究生生涯。\n\n没有我想象的顺利，但也没有我想象的不堪。\n\n用两句话来概括这两年吧：\n\n1. 第一年我把除了马克思之外所有的课都认真学了一遍，还选修了诸如机器学习、模式识别和数据挖掘等课程，这一年，感觉踏实。\n\n2. 第二年，30%的时间去提心吊胆地帮导师干杂活；70%的时间背着导师更加提心吊胆地去学习编程，这一年，以为自己会消沉，后来没有。\n\n自学编程的那些日子\n------------------------------------------------------------------\n还是那句话，现在吃的苦，都是当年专业没选计算机时脑子进的水。\n\n2014年初，作为一名只会C语言的我而言，真正开始自学计算机，依次经历了以下几步：\n\n1. 14年3月，师兄说要学编程，先学基础。于是我过了一遍数据结构和操作系统的书，过的比较粗略；\n\n2. 14年4月，想学Android开发，在网上发现了Mars的教程视频。于是我每天只要有空就背着导师偷偷看视频，做笔记。学习Android的同时也顺带着学了些Java的知识。每天晚上还会在新浪博客或博客园上把自己的笔记记录上去，虽然这种做法并没什么作用，但那时觉得很happy。\n\n3. 14年6月，视频自学效果不佳，我非常苦恼。那时我非常希望有人能够来帮帮我这个新手，同时我每天去寻找实践的机会。要知道，作为一名研究生，导师每天管着你，不能放开学，很不爽的。不过，上天眷顾，我终于找到一份校内实习，技术开发，离实验室又近，每天还有80元的工资，天，那几天我感觉我复活了！\n\n4. 14年6月中到11月，开始学习网站开发。校内实习启动，我过上了白天实验室，晚上工作室的日子了。工作室四个人，两个大牛，两个菜鸟，我当然是后者。6月到11月，我饥渴地学习！开始做网站，前端、后端、数据库。这半年我差不多每天是白天在实验室干完活之后晚上去写代码，半年下来，差不多把前端的html、css、js和一些框架Bootstrap、jQuery等，后端的php，和如thinkphp等框架，还有数据库MySQL、MongoDB都学了一通。空闲时也自己配置过服务器，搭建自己的网站。\n\n5. 15年3月到5月，算是开始了Android开发学习之路吧。15年，也就是今年，三月开学时，工作室里两个人离开了，一个是被导师抓走干活了，另一个大三的准备毕业了。于是工作室就只剩我和一位大牛。说实话，有点寂寞，但我的热情并没有减少。相反，我仍旧专注于Android的开发和学习。实验室方面，到了今年，反而轻松了些，每天上午和晚上在工作室，下午跑回实验室蹲班。另外在实际的开发中，我发现以前视频学的东西和实际应用相差很大，可能那些更基础吧，总之我几乎又是从零开始去学习，从项目中自学。\n\n6. 15年5月，我学了近三个月的Android开发，虽然工作室另一位大牛偶尔会帮我，但多数时候还是我一头人默默对着电脑学习、研究和修bug。不过好歹这几个月时间把工作室之前的一款Android应用重新写了一遍，每天晚上学到深夜，冒着寒风骑车回宿舍的场景我记得清楚。最后开发完的应用，工作室的指导老师很满意，我也对自己比较满意。\n\n7. 15年5月中到6月，工作室只剩我一人了。我没有想到，在六月某一天，工作室的顶梁柱大牛说要去北京微软亚研院实习了，意味着整个工作室从最初的四个人只剩下我一个了。那时，我真感觉到有点孤单，看着身边做技术的小伙伴依次离开，到最后竟然只剩我自己一人。不过，我还是照常来工作室开发Android、学习，不过，这时只能一人去食堂吃饭，遇到问题也再没有人来指导，完全靠自己。\n\n8. 15年6月初，迷茫地寻找校外实习。我独自在工作室开发近一个月后，由于即将面临毕业，于是也开始寻找实习。那时摆在我眼前有两条路，大公司；创业公司。对我个人而言，我是追求技术成长的，不希望自己受限于某种技术，所以害怕大公司那种只让我一直从事某个项目的某个方面。所以在我心里，虽知大公司稳妥，但我更偏心于创业型公司。另外我也希望提高自己的英语，也希望有还不错的待遇，希望未来有好的职业发展规划。很多的希望，让我很迷茫，不知道能不能找到真正适合自己的企业。\n\n9. 15年6月中，确定实习公司Glow, 正式离开工作室。终于，我也要离开这个伴随我技术成长的地方了。这期间，我参加了一些公司的面试。大小公司都有，也拿到不少开发岗offer。当然，最后我选择了目前我所在的这家硅谷创业公司－－Glow。说到Glow，我就觉得有缘。一年前，我被Glow的招聘帖吸引，便去关注了公众号，说实话，Glow的Google背景、扁平式氛围一瞬间就吸引了我。不过接下来的一年再也没收到任何关于Glow的招聘信息，所以自己也就淡忘了，加之也觉得自己没戏，所以也就没有多想。直到今年找实习时，在路上走着突然想起这家公司，说实话那时除了Glow这个名字和这家公司很独特之外其他都不记得。于是我回到学校，把bbs重新翻了一遍，竟被我找回了那个招聘帖。之后大家就知道了，投递简历，电话面试，onsite面试。然后很快就入职了。\n\n10. 15年6月中到现在，Glow的Android开发实习生活。因为不想有软文的嫌疑，所以我也就不做太多介绍了。我只想说，在Glow的这半年，我和一堆Google大牛相处，技术成长很快。他们并不介怀我非计算机出身，也不担心我只有几个月的Android的开发背景。我想我唯一的优势就是努力了。开始时我还挺有压力，担心会拖他们的后腿，不过在他们的帮助下和我个人的不懈努力下，现在我已经能够很好的与他们合作，也得到了他们的认可。我最爱Glow的扁平氛围，我相信现在很多创业公司也如此，没有上下级，一心做好产品。\n\n在Glow的这半年，我不用提心吊胆担心导师随时来使唤我，我可以全身心来提高技术，而身边的人都随时准备帮助你。\n\n说实话，我感激自己这两年的坚持，感谢这两年遇到的大牛们。\n\n2016年的技术规划\n------------------------------------------------------------------\n2016年对我而言，是个大年。\n\n正式离开校园，步入工作。\n\n下面，简单列一下我的规划吧：\n\n1. 工作方面。目前我在Glow已经独立负责一整块的开发任务了，包括Android和服务器开发。我希望把自己在开源方面学到的新技术应用到我负责的模块上，持续地提高用户体验和稳定性，为用户提供更棒的作品。这点是我每天都在心心念念的。\n\n2. 个人技术方面。由于Glow不用加班，所以我平常会有很多的个人时间。我当然不准备把这些时间用在看剧和睡觉上。我会多去写作，之前在简书上写的几篇文章[《如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客》](http://www.jianshu.com/p/99665608d295)、[如何在一天之内完成一款具备cool属性的Android产品<简诗>](http://www.jianshu.com/p/cf496fc408b2)收获了不少读者，所以以后会继续努力。同时也会在[个人微博](http://weibo.com/1625892654)和[稀土](http://gold.xitu.io/#/user/562a410800b07d3623109a95)上多多分享优质文章。\n\n3. 开源方面。最近因为又忙实习又忙毕业写论文，就没有花太多时间做开源。只是贡献了两个库：[简诗](https://github.com/wingjay/jianshi) 和[BlurImageView](https://github.com/wingjay/BlurImageView)，加起来快一千个star左右。不过以后还会继续贡献优秀的库和大家分享的。\n\n4. [我的个人博客](http://wingjay.com) http://wingjay.com。\n除了技术，我也会开始提高自己的艺术方面的敏感度。比如开始接触建筑设计、文学方面的，一方面扩大自己的知识面，另一方面也是提高自己的感性思维吧。\n\n最近在读的书\n------------------------------------------------------------------\n1. 《一切始于设计－一个设计师的世博十日手记   －   迪人 著》\n这本书我看到了一位设计师对世界的认知，接触了世界各国的设计思想，如意大利、德国、法国等，收获很大！\n\n2. 《设计中的设计   －   原研哉 著》\n原研哉，无印良品设计总监。感受日本设计思想中留白这一概念，让人重新认识身边的事物。\n\n3. 《Android开发艺术探索  － 任玉刚 著》\n把Android里很多晦涩的概念讲解清楚，超喜欢里面对View的讲解，解开了我一个很大的困惑谜团。\n\n4. 《Android群英传  －  徐宜生 著》\n从实际开发的角度，讲解开发中常见的各种问题，结合上面那本书一起看，差不多能把多数开发问题搞明白。\n\n还有不少书，下次再来推荐吧！\n\n如果你也热爱技术，交个朋友吧\n------------------------------------------------------------------\n我是[wingjay](http://wingjay.com)，你可以通过我的[GitHub](https://github.com/wingjay)或者[简书平台](http://www.jianshu.com/users/da333fd63fe5/latest_articles)来找到我哦。\n\n谢谢！\n\n\n\n\n\n\n\n","slug":"我与代码的相知相遇","published":1,"updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm19001hmoyxuiylz935","sticky":0},{"title":"[干货] Glow Android 优化实践","date":"2016-11-02T11:58:15.000Z","commentIssueId":12,"_content":"\n> 分享下自己在实际工作中积累的技术经验。\n\n<!-- more -->\n\n了解 Glow 的朋友应该知道，我们主营四款 App，分别是Eve、Glow、Nuture和Baby。作为创业公司，我们的四款 App 都处于高速开发中，平均每个 Android App 由两人负责开发，包括 Android 和 Server 开发，在满足 PM 各种需求的同时，我们的session crash free率保持不低于 99.8%，其中两款 App 接近 100%。\n\n本文将对 Glow 当前 Android 对现有工具的探索及优化作出讲解，希望对读者有所启发。\n\n## 整体结构概览\n\n由于架构都是为了实际业务服务，因此在深入讲解前，需要先展示 Android 端的大体结构：\n\n ![Glow Android 整体结构](http://upload-images.jianshu.io/upload_images/281665-6a05f7e014dc6234.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们有四个 Android App，它们共用同一个 Community 社区，最底层是 Base-Library，存放公用的模块组件，如支付模块，Logging模块等等。\n\n下面，我将依次从以下几个方面进行讲解：\n\n- 网络层优化\n- 内存优化实践\n- 在App和Library中集成依赖注入\n- etc.\n\n\n\n\n## 网络层优化\n\n#### 1. Retrofit2 + OkHttp3 + RxJava\n\n上面这套结构是目前最为流行的网络层架构，可以帮我们写出简洁而稳定的网络请求代码，比起以前复杂的异步回调、主次线程切换等代码更为易用，而且能支持 `https` 请求。\n\n基本用法如下:\n\n```java\nUserApi userApi = retrofit.create(UserApi.class);  \n```\n\n```java\n@Get(\"/{id}\")\nObservable<User> getUser(@Path(\"id\") long id);\n```\n\n```java\nuserApi.getUser(1)\n  .subscribeOn(Schedulers.io())\n  .observeOn(AndroidSchedulers.mainThread())\n  .subscribe(new Action1<User>() {\n    @Override\n    public void call(User user) {\n\t\t// handle user\n    }\n  }, new Action1<Throwable>() {\n    @Override\n    public void call(Throwable throwable) {\n\t\t// handle throwable\n    }\n  });\n```\n\n这只是通用做法。下面我们要根据实际情况进行优化。\n\n#### 2. 封装线程切换代码\n\n上面的代码中可以看到，为了执行网络请求，我们会利用`RxJava`提供的`Schedulers`工具来方便切换线程。\n\n```java\n  .subscribeOn(Schedulers.io())\n  .observeOn(AndroidSchedulers.mainThread())\n```\n\n上面的代码的作用是：让网络请求进入 `io线程` 执行，并将返回结果转入 `UI线程` 去进行渲染。\n\n不过，我们 app 有非常多的网络请求，而且除了`网络请求`，其他的`数据库操作` 或者 `文件读写操作` 都需要一样的线程切换。因此，为了代码复用，我们利用 `RxJava` 提供的 `Transformer` 来进行封装。\n\n```java\n// RxUtil.java  \npublic static <T> Observable.Transformer<T, T> normalSchedulers() {\n  return new Observable.Transformer<T, T>() {\n    @Override\n    public Observable<T> call(Observable<T> source) {\n      return source.subscribeOn(Schedulers.io())\n        .observeOn(AndroidSchedulers.mainThread());\n    }\n  };\n}\n```\n\n然后，我们可以把网络请求代码转化为\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(...)\n```\n\n这虽然只是很简单的改进，但能让我们的代码更简洁，更不易出错。\n\n#### 3. 封装响应结果 JsonDataResponse\n\n我们 server 的所有返回结果都符合如下格式:\n\n```json\n{\n  'rc': 0,\n  'data': {...},\n  'msg': \"Successful Call\"\n}\n```\n\n其中 `rc` 是自定义的结果标志，server 用来告诉我们该请求的逻辑处理是否成功（此时 `rc = 0`）。`data`是这个请求需要的 json 数据。`msg`一般用来存放错误提示信息。\n\n于是我们创建了一个通用类来封装所有的 `Response`。\n\n```java\npublic class JsonDataResponse<T> {\n  @SerializedName(\"rc\")\n  private int rc;\n\n  @SerializedName(\"msg\")\n  private String msg;\n\n  @SerializedName(\"data\")\n  T data;\n  \n  public int getRc() { return rc; }\n  \n  public T getData() { return data; }\n} \n```\n\n于是，我们的请求变成如下：\n\n```java\n@Get(\"/{id}\")\nObservable<JsonDataResponse<User>> getUser(@Path(\"id\") long id);\n```\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new Action1<JsonDataResponse<User>>() {\n    @Override\n    public void call(JsonDataResponse<User> response) {\n\t\tif (response.getRc() == 0) {\n          User user = response.getData();\n          // handle user\n\t\t} else {\n          Toast.makeToast(context, response.getMsg())\n\t\t}\n    }\n  }, new Action1<Throwable>() {\n    @Override\n    public void call(Throwable throwable) {\n\t\t// handle throwable\n    }\n  });\n```\n\n#### 4. 异常处理\n\n上面已经能完成正常的网络请求了，但是，却还没有对错误进行处理。\n\n一次网络请求中，可能发生以下几种错误：\n\n- 没有网络\n- 网络正常，但 http 请求失败，即 http 状态码不在 `[200, 300)` 之间，如`404`、`500`等\n- 网络正常，http 请求成功，但是 server 在处理请求时出了问题，使得返回结果的 `rc != 0`\n\n不同的错误，我们希望给用户不同的提示，并且统计这些错误。\n\n目前我们的网络请求里已经能够处理第三种情况，另外两种都在 `throwable` 里面，我们可以通过判断 `throwable` 是 `IOException` 还是 `retrofit2.HttpException` 来区分这两种情况。\n\n因此，我们可得到如下异常处理代码：\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new Action1<JsonDataResponse<User>>() {\n    @Override\n    public void call(JsonDataResponse<User> response) {\n\t\tif (response.getRc() == 0) {\n          User user = response.getData();\n          // handle user\n          handleUser();\n\t\t} else {\n          // such as: customized errorMsg: \"cannot find this user\".\n          Toast.makeToast(context, response.getMsg(), Toast.LENGTH_SHORT).show();\n\t\t}\n    }\n  }, new Action1<Throwable>() {\n    @Override\n    public void call(Throwable throwable) {\n        String errorMsg = \"\";\n\t\tif (throwable instanceof IOException) {\n          // io Exception\n          errorMsg = \"Please check your network status\";\n\t\t} else if (throwable instanceof HttpException) {\n          HttpException httpException = (HttpException) throwable;\n          // http error.\n          errorMsg = httpException.response(); \n\t\t} else {\n          errorMsg = \"unknown error\";\n\t\t}\n        Toast.makeToast(...);\n    }\n  });\n```\n\n#### 5. 封装异常处理代码\n\n当然，我们并不想在每一个网络请求里都写上面一大段代码来处理 `error`，那样太傻了。比如上面 `getUser()` 请求，我希望只要写 `handleUser()` 这个方法，至于是网络问题还是 server 自己问题我都不想每次去 handle。\n\n接下来我们来封装上面两个 `Action` 。我们可以自定义两个 `Action`:\n\n```java\nWebSuccessAction<T extends JsonDataResponse> implements Action1<T> \n```\n\n```java\nWebFailureAction implements Action1<Throwable>\n```\n\n其中，`WebSuccessAction` 用来处理一切正常（网络正常，请求正常，`rc=0`）后的处理，`WebFailureAction` 用来统一处理上面`三种 error`。\n\n实现如下：\n\n```java\nclass WebSuccessAction<T extends JsonDataResponse> implements Action1<T> {\n  @Override\n  public void call(T response) {\n    int rc = response.getRc();\n    if (rc != 0) {\n      throw new ResponseCodeError(extendedResponse.getMessage());\n    }\n    onSuccess(extendedResponse);\n  }\n\n  public abstract void onSuccess(T extendedResponse);\n}\n```\n\n```java\n// (rc != 0) Error\nclass ResponseCodeError extends RuntimeException {\n  public ResponseCodeError(String detailMessage) {\n    super(detailMessage);\n  }\n}\n```\n\n在 `WebSuccessAction` 里，我们把 `rc != 0` 这种情况转化成 `ResponseCodeError` 并抛出给 `WebFailureAction` 去统一处理。\n\n```java\nclass WebFailAction implements Action1<Throwable> {\n  @Override\n  public void call(Throwable throwable) {\n    String errorMsg = \"\";\n    if (throwable instanceof IOException) {\n      errorMsg = \"Please check your network status\";\n    } else if (throwable instanceof HttpException) {\n      HttpException httpException = (HttpException) throwable;\n      // such as: \"server internal error\".\n      errorMsg = httpException.response(); \n    } else {\n      errorMsg = \"unknown error\";\n    }\n    Toast.makeToast(...);\n  }\n}\n```\n\n有了上面两个自定义 `Action` 后，我们就可以把前面 `getUser()` 请求转化如下：\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new WebSuccessAction<JsonDataResponse<User>>() {\n      @Override\n      public void onSuccess(JsonDataResponse<User> response) {\n    \thandleUser(response.getUser());\n      }\n    }, new WebFailAction())\n```\n\nBingo! 至此我们能够用非常简洁的方式来执行网络操作，而且完全不用担心异常处理。\n\n\n\n## 内存优化实践\n\n在内存优化方面，Google 官方文档里能找到非常多的学习资料，例如常见的内存泄漏、[bitmap官方最佳实践](https://developer.android.com/training/displaying-bitmaps/manage-memory.html)。而且 Android studio 里也集成了很多有效的工具如 [Heap Viewer](https://developer.android.com/studio/profile/heap-viewer-walkthru.html), [Memory Monitor](https://developer.android.com/studio/profile/am-memory.html) 和 [Hierarchy Viewer](https://developer.android.com/studio/profile/hierarchy-viewer.html) 等等。\n\n下面，本文将从其它角度出发，来对内存作进一步优化。\n\n#### 1. 当Activity关闭时，立即取消掉网络请求结果处理。\n\n这一点很容易被忽略掉。大家最常用的做法是在 `Activity` 执行网络操作，当 `Http Response` 回来后直接进行UI渲染，却并不会去判断此时 `Activity` 是否仍然存在，即用户是否已经离开了当时的页面。\n\n那么，有什么方法能够让每个网络请求都自动监听 Activity(Fragment) 的 lifecycle 事件并且当特定 lifecycle 事件发生时，`自动中断`掉网络请求的继续执行呢？\n\n首先来看下我们的网络请求代码：\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new WebSuccessAction<JsonDataResponse<User>>() {\n      @Override\n      public void onSuccess(JsonDataResponse<User> response) {\n    \thandleUser(response.getUser());\n      }\n    }, new WebFailAction())\n```\n\n我们希望达到的是，当 `Activity` 进入 `onStop` 时立即停掉网络请求的后续处理。\n\n这里我们参考了 [RxLifecycle](https://github.com/trello/RxLifecycle) 的实现方式，之所以没有直接使用 [RxLifecycle](https://github.com/trello/RxLifecycle) 是因为它必须我们的 BaseActivity 继承其提供的 [RxActivity](https://github.com/trello/RxLifecycle/blob/master/rxlifecycle-components/src/main/java/com/trello/rxlifecycle/components/RxActivity.java) ，而 RxActivity 并未继承我们需要的 `AppCompatActivity`。因此本人只能在学习其源码后，自己重新实现一套，并做了一些改动以更符合我们自己的应用场景。\n\n具体实现如下：\n\n- 首先，我们在 BaseActivity 里，利用 RxJava 提供的 `PublishSubject` 把所有 lifecycle event 发送出来。\n\n  ```java\n  class BaseActivity extends AppCompatActivity {\n    protected final PublishSubject<ActivityLifeCycleEvent> lifecycleSubject = PublishSubject.create();\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n\n      lifecycleSubject.onNext(ActivityLifeCycleEvent.CREATE);\n    }\n    \n    @Override\n    protected void onDestroy() {\n      lifecycleSubject.onNext(ActivityLifeCycleEvent.DESTROY);\n      \n      super.onDestroy();\n    }\n    \n    @Override\n    protected void onStop() {\n      lifecycleSubject.onNext(ActivityLifeCycleEvent.STOP);\n\n      super.onStop();\n    }\n  }\n  ```\n\n- 然后，在 `BaseActivity` 里，提供 `bindUntilEvent(LifeCycleEvent)` 方法\n\n  ```java\n  class BaseActivity extends AppCompatActivity {\n    \n    @NonNull\n    @Override\n    public <T> Observable.Transformer<T, T> bindUntilEvent(@NonNull final ActivityLifeCycleEvent event) {\n      return new Observable.Transformer<T, T>() {\n        @Override\n        public Observable<T> call(Observable<T> sourceObservable) {\n          Observable<ActivityLifeCycleEvent> o =\n              lifecycleSubject.takeFirst(activityLifeCycleEvent -> {\n                return activityLifeCycleEvent.equals(event);\n              });\n          return sourceObservable.takeUntil(o);\n        }\n      };\n    }\n  }\n  ```\n\n  这个方法可以用于每一个网络请求 Observable 中，当它监听到特定的 lifecycle event 时，就会自动让网络请求 Observable 终止掉，不会再去监听网络请求结果。\n\n- 具体使用如下：\n\n  ```java\n  userApi.getUser(1)\n    .compose(bindUntilEvent(ActivityLifeCycleEvent.PAUSE))\n    .compose(RxUtil.normalSchedulers())\n    .subscribe(new WebSuccessAction<JsonDataResponse<User>>() {\n      @Override\n        public void onSuccess(JsonDataResponse<User> response) {\n          handleUser(response.getUser());\n        }\n    }, new WebFailAction())\n  ```\n\n  利用 `.compose(bindUntilEvent(ActivityLifeCycleEvent.STOP))` 来监听 Activity 的 Stop 事件并终止 `userApi.getUser(1)` 的 `subscription`，从而防止内存泄漏。\n\n#### 2. 图片优化实践\n\nAndroid开发者都知道，每个app的可用内存时有限的，一旦内存占用太多或者在主线程突然请求较大内存，很有可能发生 OOM 问题。而其中，图片又是占用内存的大头，因此我们必须采取多种方法来进行优化。\n\n多数情况下我们是从 server 获取一张高清图片下来，然后在内存里进行裁剪成需要的大小来进行显示。这里面存在两个问题，\n\n1：假设我们只需要一张小图，而server取回来的图如果比较大，那就会浪费带宽和内存。\n\n2：如果直接在主线程去为图片请求大块空间，很容易由于系统难于快速分配而 OOM；\n\n比较理想的情况是：需要显示多大的图片，就向server请求多大的图片，既节省用户带宽流量，更减少内存的占用，减小 OOM 的机率。\n\n为了实现 server 端的图片Resize，我们采用了 [thumbor](https://github.com/thumbor/thumbor) 来提供图片 Resize 的功能。android端只需要提供一个原图片 URL 和需要的 size 信息，就可以得到一张 Resize 好的图片资源文件。具体server端实现这里就不细讲了，感兴趣的读者可以阅读官方文档。\n\n这里介绍下我们在 Android 端的实现，以 Picasso 为栗子。\n\n- 首先要引入 Square 提供的 [pollexor](https://github.com/square/pollexor) 工具，它可以让我们更简便的创建 thumbor 的规范 URI，参考如下：\n\n  ```java\n  thumbor.buildImage(\"http://example.com/image.png\")\n      .resize(48, 48)\n      .toUrl()\n  ```\n\n- 然后，利用 Picasso 提供的 requestTransformer 来实时获取当前需要显示的图片的真实尺寸，同时设置图片格式为 WebP，这种格式的图片可以保持图片质量的同时具有更小的体积：\n\n  ```java\n  Picasso picasso = new Picasso.Builder(context).requestTransformer(new Picasso.RequestTransformer() {\n        @Override\n        public Request transformRequest(Request request) {\n          String modifiedUrl = URLEncoder.encode(originUrl);\n          ThumborUrlBuilder thumborUrlBuilder = thumbor.buildImage(modifiedUrl);\n          String url = thumborUrlBuilder.resize(request.targetWidth, request.targetHeight)\n              .filter(ThumborUrlBuilder.format(ThumborUrlBuilder.ImageFormat.WEBP))\n              .toUrl();\n          Timber.i(\"SponsorAd Image Resize url to \" + url);\n          return request.buildUpon().setUri(Uri.parse(url)).build();\n        }\n      }).build();\n  ```\n\n- 利用修改后的 picasso 对象来请求图片\n\n  ```java\n  picasso.load(originUrl).fit().centerCrop().into(imageView);\n  ```\n\n利用上面这种方法，我们可以为不同的 ImageView 计算显示需要的真实尺寸，然后去请求一张尺寸匹配的图片下来，节约带宽，减小内存开销。\n\n当然，在应用这种方法的时候，不要忘记考虑服务器的负载情况，毕竟这种方案意味着每张图片会被生成各种尺寸的小图缓存起来，而且Android设备分辨率不同，即使是同一个 ImageView，真实的宽高 Pixel 值也会不同，从而生成不同的小图。\n\n\n\n## 在App和Library中集成依赖注入\n\n依赖注入框架 [Dagger](https://github.com/square/dagger) 我们很早就开始用了，从早期的 Dagger1 到现在的 Dagger2。虽然 Dagger 本身较为陡峭的学习曲线使得不少人止步，不过一旦用过，根本停不下来。\n\n如果只是在 App 里使用 Dagger 相对比较简单，不过，我们还需要在 `Community` 和 `Base-Android` 两个公用 Library 里也集成 Dagger，这就需要费点功夫了。\n\n下面我来逐步讲解下我们是如何将 Dagger 同时集成进 App 和 Library 中。\n\n#### 1. 在App里集成Dagger\n\n首先需要在 `GlowApplication` 里生成一个全局的 `AppComponent`\n\n```java\n@Singleton\n@Component(modules = AppModule.class)\npublic interface AppComponent {\n  void inject(MainActivity mainActivity);\n}\n```\n\n创建 `AppModule`\n\n```java\n@Module\npublic class AppModule {\n  private final LexieApplication lexieApplication;\n\n  public AppModule(LexieApplication lexieApplication) {\n    this.lexieApplication = lexieApplication;\n  }\n  \n  @Provides Context applicationContext() {\n    return lexieApplication;\n  }\n  \n  // mock tool object\n  @Provides Tool provideTool() {\n    return new Tool();\n  }\n}\n```\n\n集成进 `Application`\n\n```java\nclass GlowApplication extends Application {\n  private AppComponent appComponent;\n  \n  @Override\n  public void onCreate() {\n    appComponent = DaggerAppComponent.builder()\n        .appModule(new AppModule(this))\n        .build();\n  }\n  \n  public static AppComponent getAppComponent() {\n    return appComponent;\n  }\n}\n```\n\n在 `MainActivity`中使用`inject` 一个 `tool` 对象\n\n```java\nclass MainActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    GlowApplication.getAppComponent().inject(this);\n  }\n}\n```\n\n#### 2. 在 Library 中集成 Dagger\n\n（下面以公用Library：Community为例子）\n\n逆向思维下，先设想应用场景：即 Dagger 已经集成好了，那么我们应该可以按如下方式在 `CommunityActivity` 里 `inject` 一个 `tool` 对象。\n\n```java\nclass CommunityActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    GlowApplication.getAppComponent().inject(this);\n  }\n}\n```\n\n关键在于： `GlowApplication.getAppComponent().inject(this);` 这一句。\n\n那么问题来了：\n\n**对于一个 Library 而言，它是无法拿到 GlowApplication 对象的，因为作为一个被别人调用的 Library，它甚至不知道这个上层 class 的存在**\n\n为了解决这个问题，我们在`community`里定义一个公用接口作为`中间桥梁`，让`GlowApplication`实现这个公共接口即可。\n\n```java\n// 在Community定义接口CommunityComponentProvider\npublic interface CommunityComponentProvider {\n  AppComponent getAppComponent();\n}\n```\n\n```java\n// 每个app的Application类都实现这个接口来提供AppComponent\nclass GlowApplication implements CommunityComponentProvider {\n  AppComponent getAppComponent() {\n    return appComponent;\n  }\n}\n```\n\n然后 `CommunityActivity`就可以实现如下：\n\n```java\nclass CommunityActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    Context applicationContext = getApplicationContext();\n    CommunityComponentProvider provider = (CommunityComponentProvider) applicationContext;\n    provider.getAppComponent().inject(this);\n  }\n}\n```\n\n#### 3. 从 AppComponent 抽离 CommunityComponent\n\n```java\nprovider.getAppComponent().inject(this);\n```\n\n这一句里我们已经实现前半句 `provider.getAppComponent()` 了，但后半句的实现呢？\n\n正常情况下，我们要把\n\n```java\nvoid inject(CommunityActivity communityActivity);\n```\n\n放入 `AppComponent` 中\n\n```java\n@Singleton\n@Component(modules = AppModule.class)\npublic interface AppComponent {\n  void inject(MainActivity mainActivity);\n  \n  // 加在这里\n  void inject(CommunityActivity communityActivity);\n}\n```\n\n其实这样我们就已经几乎完成了整个 Library 和 App 的依赖注入了。\n\n但细心的朋友应该发现里面存在一个小问题，那就是\n\n```java\nvoid inject(CommunityActivity communityActivity);\n```\n\n这句代码如果放入了 `App` 里的 `AppComponent` 里，那就意味着我们也需要在另外三个 `App` 里的 `AppComponent` 都加上一句相同的代码？这样可以吗？\n\n理论上当然是可行的。但是，从单一职责的角度来考虑，`AppComponent` 只需要负责 `App` 层的 `inject` 就行，我们不应该把属于 `Community` 的 `inject` 放到`App` 里，这样的代码太ugly，而且更重要的是，随着 Community 越来越多 Activity 需要 inject ，每个 inject 都要在各个 App 里重复加，这太烦了，也太笨了。\n\n因此，我们采用了一个简洁有效的方法来改进。\n\n在 `Community` 里创建一个 `CommunityComponent`，所有属于 `Community` 的`inject` 直接写在 `CommunityComponent` 里，不需要 `App` 再去关心。与此同时，为了保持前面 `provider.getAppComponent()` 仍然有效，我们让 `AppComponent` 继承 `CommunityComponent`。\n\n实现代码如下：\n\n```java\nclass AppComponent extends CommunityComponent {...}\n```\n\n在 `Community` 里\n\n```java\nclass CommunityComponent {\n  void inject(CommunityActivity communityActivity);\n}\n```\n\n```java\nclass CommunityActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    Context applicationContext = getApplicationContext();\n    CommunityComponentProvider provider = (CommunityComponentProvider) applicationContext;\n    provider.getAppComponent().inject(this);\n  }\n}\n```\n\n![依赖注入](http://upload-images.jianshu.io/upload_images/281665-483c8a864c09503d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nBingo! 至此我们已经能够优雅简洁地在 App 和 Library 里同时应用依赖注入了。\n\n\n\n## 小结\n\n由于篇幅有限，本文暂时先从网络层、内存优化和依赖注入方面进行讲解，之后会再考虑从 Logging模块、数据同步模块、Deep Linking模块、多Library的Gradle发布管理、持续集成和崩溃监测模块等进行讲解。\n\n谢谢。\n\nwingjay\n\n\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>","source":"_posts/干货-Glow-Android-优化实践.md","raw":"title: '[干货] Glow Android 优化实践'\ndate: 2016-11-02 19:58:15\ncategories:\n  - Android\ntags: Android\ncommentIssueId: 12\n---\n\n> 分享下自己在实际工作中积累的技术经验。\n\n<!-- more -->\n\n了解 Glow 的朋友应该知道，我们主营四款 App，分别是Eve、Glow、Nuture和Baby。作为创业公司，我们的四款 App 都处于高速开发中，平均每个 Android App 由两人负责开发，包括 Android 和 Server 开发，在满足 PM 各种需求的同时，我们的session crash free率保持不低于 99.8%，其中两款 App 接近 100%。\n\n本文将对 Glow 当前 Android 对现有工具的探索及优化作出讲解，希望对读者有所启发。\n\n## 整体结构概览\n\n由于架构都是为了实际业务服务，因此在深入讲解前，需要先展示 Android 端的大体结构：\n\n ![Glow Android 整体结构](http://upload-images.jianshu.io/upload_images/281665-6a05f7e014dc6234.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们有四个 Android App，它们共用同一个 Community 社区，最底层是 Base-Library，存放公用的模块组件，如支付模块，Logging模块等等。\n\n下面，我将依次从以下几个方面进行讲解：\n\n- 网络层优化\n- 内存优化实践\n- 在App和Library中集成依赖注入\n- etc.\n\n\n\n\n## 网络层优化\n\n#### 1. Retrofit2 + OkHttp3 + RxJava\n\n上面这套结构是目前最为流行的网络层架构，可以帮我们写出简洁而稳定的网络请求代码，比起以前复杂的异步回调、主次线程切换等代码更为易用，而且能支持 `https` 请求。\n\n基本用法如下:\n\n```java\nUserApi userApi = retrofit.create(UserApi.class);  \n```\n\n```java\n@Get(\"/{id}\")\nObservable<User> getUser(@Path(\"id\") long id);\n```\n\n```java\nuserApi.getUser(1)\n  .subscribeOn(Schedulers.io())\n  .observeOn(AndroidSchedulers.mainThread())\n  .subscribe(new Action1<User>() {\n    @Override\n    public void call(User user) {\n\t\t// handle user\n    }\n  }, new Action1<Throwable>() {\n    @Override\n    public void call(Throwable throwable) {\n\t\t// handle throwable\n    }\n  });\n```\n\n这只是通用做法。下面我们要根据实际情况进行优化。\n\n#### 2. 封装线程切换代码\n\n上面的代码中可以看到，为了执行网络请求，我们会利用`RxJava`提供的`Schedulers`工具来方便切换线程。\n\n```java\n  .subscribeOn(Schedulers.io())\n  .observeOn(AndroidSchedulers.mainThread())\n```\n\n上面的代码的作用是：让网络请求进入 `io线程` 执行，并将返回结果转入 `UI线程` 去进行渲染。\n\n不过，我们 app 有非常多的网络请求，而且除了`网络请求`，其他的`数据库操作` 或者 `文件读写操作` 都需要一样的线程切换。因此，为了代码复用，我们利用 `RxJava` 提供的 `Transformer` 来进行封装。\n\n```java\n// RxUtil.java  \npublic static <T> Observable.Transformer<T, T> normalSchedulers() {\n  return new Observable.Transformer<T, T>() {\n    @Override\n    public Observable<T> call(Observable<T> source) {\n      return source.subscribeOn(Schedulers.io())\n        .observeOn(AndroidSchedulers.mainThread());\n    }\n  };\n}\n```\n\n然后，我们可以把网络请求代码转化为\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(...)\n```\n\n这虽然只是很简单的改进，但能让我们的代码更简洁，更不易出错。\n\n#### 3. 封装响应结果 JsonDataResponse\n\n我们 server 的所有返回结果都符合如下格式:\n\n```json\n{\n  'rc': 0,\n  'data': {...},\n  'msg': \"Successful Call\"\n}\n```\n\n其中 `rc` 是自定义的结果标志，server 用来告诉我们该请求的逻辑处理是否成功（此时 `rc = 0`）。`data`是这个请求需要的 json 数据。`msg`一般用来存放错误提示信息。\n\n于是我们创建了一个通用类来封装所有的 `Response`。\n\n```java\npublic class JsonDataResponse<T> {\n  @SerializedName(\"rc\")\n  private int rc;\n\n  @SerializedName(\"msg\")\n  private String msg;\n\n  @SerializedName(\"data\")\n  T data;\n  \n  public int getRc() { return rc; }\n  \n  public T getData() { return data; }\n} \n```\n\n于是，我们的请求变成如下：\n\n```java\n@Get(\"/{id}\")\nObservable<JsonDataResponse<User>> getUser(@Path(\"id\") long id);\n```\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new Action1<JsonDataResponse<User>>() {\n    @Override\n    public void call(JsonDataResponse<User> response) {\n\t\tif (response.getRc() == 0) {\n          User user = response.getData();\n          // handle user\n\t\t} else {\n          Toast.makeToast(context, response.getMsg())\n\t\t}\n    }\n  }, new Action1<Throwable>() {\n    @Override\n    public void call(Throwable throwable) {\n\t\t// handle throwable\n    }\n  });\n```\n\n#### 4. 异常处理\n\n上面已经能完成正常的网络请求了，但是，却还没有对错误进行处理。\n\n一次网络请求中，可能发生以下几种错误：\n\n- 没有网络\n- 网络正常，但 http 请求失败，即 http 状态码不在 `[200, 300)` 之间，如`404`、`500`等\n- 网络正常，http 请求成功，但是 server 在处理请求时出了问题，使得返回结果的 `rc != 0`\n\n不同的错误，我们希望给用户不同的提示，并且统计这些错误。\n\n目前我们的网络请求里已经能够处理第三种情况，另外两种都在 `throwable` 里面，我们可以通过判断 `throwable` 是 `IOException` 还是 `retrofit2.HttpException` 来区分这两种情况。\n\n因此，我们可得到如下异常处理代码：\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new Action1<JsonDataResponse<User>>() {\n    @Override\n    public void call(JsonDataResponse<User> response) {\n\t\tif (response.getRc() == 0) {\n          User user = response.getData();\n          // handle user\n          handleUser();\n\t\t} else {\n          // such as: customized errorMsg: \"cannot find this user\".\n          Toast.makeToast(context, response.getMsg(), Toast.LENGTH_SHORT).show();\n\t\t}\n    }\n  }, new Action1<Throwable>() {\n    @Override\n    public void call(Throwable throwable) {\n        String errorMsg = \"\";\n\t\tif (throwable instanceof IOException) {\n          // io Exception\n          errorMsg = \"Please check your network status\";\n\t\t} else if (throwable instanceof HttpException) {\n          HttpException httpException = (HttpException) throwable;\n          // http error.\n          errorMsg = httpException.response(); \n\t\t} else {\n          errorMsg = \"unknown error\";\n\t\t}\n        Toast.makeToast(...);\n    }\n  });\n```\n\n#### 5. 封装异常处理代码\n\n当然，我们并不想在每一个网络请求里都写上面一大段代码来处理 `error`，那样太傻了。比如上面 `getUser()` 请求，我希望只要写 `handleUser()` 这个方法，至于是网络问题还是 server 自己问题我都不想每次去 handle。\n\n接下来我们来封装上面两个 `Action` 。我们可以自定义两个 `Action`:\n\n```java\nWebSuccessAction<T extends JsonDataResponse> implements Action1<T> \n```\n\n```java\nWebFailureAction implements Action1<Throwable>\n```\n\n其中，`WebSuccessAction` 用来处理一切正常（网络正常，请求正常，`rc=0`）后的处理，`WebFailureAction` 用来统一处理上面`三种 error`。\n\n实现如下：\n\n```java\nclass WebSuccessAction<T extends JsonDataResponse> implements Action1<T> {\n  @Override\n  public void call(T response) {\n    int rc = response.getRc();\n    if (rc != 0) {\n      throw new ResponseCodeError(extendedResponse.getMessage());\n    }\n    onSuccess(extendedResponse);\n  }\n\n  public abstract void onSuccess(T extendedResponse);\n}\n```\n\n```java\n// (rc != 0) Error\nclass ResponseCodeError extends RuntimeException {\n  public ResponseCodeError(String detailMessage) {\n    super(detailMessage);\n  }\n}\n```\n\n在 `WebSuccessAction` 里，我们把 `rc != 0` 这种情况转化成 `ResponseCodeError` 并抛出给 `WebFailureAction` 去统一处理。\n\n```java\nclass WebFailAction implements Action1<Throwable> {\n  @Override\n  public void call(Throwable throwable) {\n    String errorMsg = \"\";\n    if (throwable instanceof IOException) {\n      errorMsg = \"Please check your network status\";\n    } else if (throwable instanceof HttpException) {\n      HttpException httpException = (HttpException) throwable;\n      // such as: \"server internal error\".\n      errorMsg = httpException.response(); \n    } else {\n      errorMsg = \"unknown error\";\n    }\n    Toast.makeToast(...);\n  }\n}\n```\n\n有了上面两个自定义 `Action` 后，我们就可以把前面 `getUser()` 请求转化如下：\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new WebSuccessAction<JsonDataResponse<User>>() {\n      @Override\n      public void onSuccess(JsonDataResponse<User> response) {\n    \thandleUser(response.getUser());\n      }\n    }, new WebFailAction())\n```\n\nBingo! 至此我们能够用非常简洁的方式来执行网络操作，而且完全不用担心异常处理。\n\n\n\n## 内存优化实践\n\n在内存优化方面，Google 官方文档里能找到非常多的学习资料，例如常见的内存泄漏、[bitmap官方最佳实践](https://developer.android.com/training/displaying-bitmaps/manage-memory.html)。而且 Android studio 里也集成了很多有效的工具如 [Heap Viewer](https://developer.android.com/studio/profile/heap-viewer-walkthru.html), [Memory Monitor](https://developer.android.com/studio/profile/am-memory.html) 和 [Hierarchy Viewer](https://developer.android.com/studio/profile/hierarchy-viewer.html) 等等。\n\n下面，本文将从其它角度出发，来对内存作进一步优化。\n\n#### 1. 当Activity关闭时，立即取消掉网络请求结果处理。\n\n这一点很容易被忽略掉。大家最常用的做法是在 `Activity` 执行网络操作，当 `Http Response` 回来后直接进行UI渲染，却并不会去判断此时 `Activity` 是否仍然存在，即用户是否已经离开了当时的页面。\n\n那么，有什么方法能够让每个网络请求都自动监听 Activity(Fragment) 的 lifecycle 事件并且当特定 lifecycle 事件发生时，`自动中断`掉网络请求的继续执行呢？\n\n首先来看下我们的网络请求代码：\n\n```java\nuserApi.getUser(1)\n  .compose(RxUtil.normalSchedulers())\n  .subscribe(new WebSuccessAction<JsonDataResponse<User>>() {\n      @Override\n      public void onSuccess(JsonDataResponse<User> response) {\n    \thandleUser(response.getUser());\n      }\n    }, new WebFailAction())\n```\n\n我们希望达到的是，当 `Activity` 进入 `onStop` 时立即停掉网络请求的后续处理。\n\n这里我们参考了 [RxLifecycle](https://github.com/trello/RxLifecycle) 的实现方式，之所以没有直接使用 [RxLifecycle](https://github.com/trello/RxLifecycle) 是因为它必须我们的 BaseActivity 继承其提供的 [RxActivity](https://github.com/trello/RxLifecycle/blob/master/rxlifecycle-components/src/main/java/com/trello/rxlifecycle/components/RxActivity.java) ，而 RxActivity 并未继承我们需要的 `AppCompatActivity`。因此本人只能在学习其源码后，自己重新实现一套，并做了一些改动以更符合我们自己的应用场景。\n\n具体实现如下：\n\n- 首先，我们在 BaseActivity 里，利用 RxJava 提供的 `PublishSubject` 把所有 lifecycle event 发送出来。\n\n  ```java\n  class BaseActivity extends AppCompatActivity {\n    protected final PublishSubject<ActivityLifeCycleEvent> lifecycleSubject = PublishSubject.create();\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n\n      lifecycleSubject.onNext(ActivityLifeCycleEvent.CREATE);\n    }\n    \n    @Override\n    protected void onDestroy() {\n      lifecycleSubject.onNext(ActivityLifeCycleEvent.DESTROY);\n      \n      super.onDestroy();\n    }\n    \n    @Override\n    protected void onStop() {\n      lifecycleSubject.onNext(ActivityLifeCycleEvent.STOP);\n\n      super.onStop();\n    }\n  }\n  ```\n\n- 然后，在 `BaseActivity` 里，提供 `bindUntilEvent(LifeCycleEvent)` 方法\n\n  ```java\n  class BaseActivity extends AppCompatActivity {\n    \n    @NonNull\n    @Override\n    public <T> Observable.Transformer<T, T> bindUntilEvent(@NonNull final ActivityLifeCycleEvent event) {\n      return new Observable.Transformer<T, T>() {\n        @Override\n        public Observable<T> call(Observable<T> sourceObservable) {\n          Observable<ActivityLifeCycleEvent> o =\n              lifecycleSubject.takeFirst(activityLifeCycleEvent -> {\n                return activityLifeCycleEvent.equals(event);\n              });\n          return sourceObservable.takeUntil(o);\n        }\n      };\n    }\n  }\n  ```\n\n  这个方法可以用于每一个网络请求 Observable 中，当它监听到特定的 lifecycle event 时，就会自动让网络请求 Observable 终止掉，不会再去监听网络请求结果。\n\n- 具体使用如下：\n\n  ```java\n  userApi.getUser(1)\n    .compose(bindUntilEvent(ActivityLifeCycleEvent.PAUSE))\n    .compose(RxUtil.normalSchedulers())\n    .subscribe(new WebSuccessAction<JsonDataResponse<User>>() {\n      @Override\n        public void onSuccess(JsonDataResponse<User> response) {\n          handleUser(response.getUser());\n        }\n    }, new WebFailAction())\n  ```\n\n  利用 `.compose(bindUntilEvent(ActivityLifeCycleEvent.STOP))` 来监听 Activity 的 Stop 事件并终止 `userApi.getUser(1)` 的 `subscription`，从而防止内存泄漏。\n\n#### 2. 图片优化实践\n\nAndroid开发者都知道，每个app的可用内存时有限的，一旦内存占用太多或者在主线程突然请求较大内存，很有可能发生 OOM 问题。而其中，图片又是占用内存的大头，因此我们必须采取多种方法来进行优化。\n\n多数情况下我们是从 server 获取一张高清图片下来，然后在内存里进行裁剪成需要的大小来进行显示。这里面存在两个问题，\n\n1：假设我们只需要一张小图，而server取回来的图如果比较大，那就会浪费带宽和内存。\n\n2：如果直接在主线程去为图片请求大块空间，很容易由于系统难于快速分配而 OOM；\n\n比较理想的情况是：需要显示多大的图片，就向server请求多大的图片，既节省用户带宽流量，更减少内存的占用，减小 OOM 的机率。\n\n为了实现 server 端的图片Resize，我们采用了 [thumbor](https://github.com/thumbor/thumbor) 来提供图片 Resize 的功能。android端只需要提供一个原图片 URL 和需要的 size 信息，就可以得到一张 Resize 好的图片资源文件。具体server端实现这里就不细讲了，感兴趣的读者可以阅读官方文档。\n\n这里介绍下我们在 Android 端的实现，以 Picasso 为栗子。\n\n- 首先要引入 Square 提供的 [pollexor](https://github.com/square/pollexor) 工具，它可以让我们更简便的创建 thumbor 的规范 URI，参考如下：\n\n  ```java\n  thumbor.buildImage(\"http://example.com/image.png\")\n      .resize(48, 48)\n      .toUrl()\n  ```\n\n- 然后，利用 Picasso 提供的 requestTransformer 来实时获取当前需要显示的图片的真实尺寸，同时设置图片格式为 WebP，这种格式的图片可以保持图片质量的同时具有更小的体积：\n\n  ```java\n  Picasso picasso = new Picasso.Builder(context).requestTransformer(new Picasso.RequestTransformer() {\n        @Override\n        public Request transformRequest(Request request) {\n          String modifiedUrl = URLEncoder.encode(originUrl);\n          ThumborUrlBuilder thumborUrlBuilder = thumbor.buildImage(modifiedUrl);\n          String url = thumborUrlBuilder.resize(request.targetWidth, request.targetHeight)\n              .filter(ThumborUrlBuilder.format(ThumborUrlBuilder.ImageFormat.WEBP))\n              .toUrl();\n          Timber.i(\"SponsorAd Image Resize url to \" + url);\n          return request.buildUpon().setUri(Uri.parse(url)).build();\n        }\n      }).build();\n  ```\n\n- 利用修改后的 picasso 对象来请求图片\n\n  ```java\n  picasso.load(originUrl).fit().centerCrop().into(imageView);\n  ```\n\n利用上面这种方法，我们可以为不同的 ImageView 计算显示需要的真实尺寸，然后去请求一张尺寸匹配的图片下来，节约带宽，减小内存开销。\n\n当然，在应用这种方法的时候，不要忘记考虑服务器的负载情况，毕竟这种方案意味着每张图片会被生成各种尺寸的小图缓存起来，而且Android设备分辨率不同，即使是同一个 ImageView，真实的宽高 Pixel 值也会不同，从而生成不同的小图。\n\n\n\n## 在App和Library中集成依赖注入\n\n依赖注入框架 [Dagger](https://github.com/square/dagger) 我们很早就开始用了，从早期的 Dagger1 到现在的 Dagger2。虽然 Dagger 本身较为陡峭的学习曲线使得不少人止步，不过一旦用过，根本停不下来。\n\n如果只是在 App 里使用 Dagger 相对比较简单，不过，我们还需要在 `Community` 和 `Base-Android` 两个公用 Library 里也集成 Dagger，这就需要费点功夫了。\n\n下面我来逐步讲解下我们是如何将 Dagger 同时集成进 App 和 Library 中。\n\n#### 1. 在App里集成Dagger\n\n首先需要在 `GlowApplication` 里生成一个全局的 `AppComponent`\n\n```java\n@Singleton\n@Component(modules = AppModule.class)\npublic interface AppComponent {\n  void inject(MainActivity mainActivity);\n}\n```\n\n创建 `AppModule`\n\n```java\n@Module\npublic class AppModule {\n  private final LexieApplication lexieApplication;\n\n  public AppModule(LexieApplication lexieApplication) {\n    this.lexieApplication = lexieApplication;\n  }\n  \n  @Provides Context applicationContext() {\n    return lexieApplication;\n  }\n  \n  // mock tool object\n  @Provides Tool provideTool() {\n    return new Tool();\n  }\n}\n```\n\n集成进 `Application`\n\n```java\nclass GlowApplication extends Application {\n  private AppComponent appComponent;\n  \n  @Override\n  public void onCreate() {\n    appComponent = DaggerAppComponent.builder()\n        .appModule(new AppModule(this))\n        .build();\n  }\n  \n  public static AppComponent getAppComponent() {\n    return appComponent;\n  }\n}\n```\n\n在 `MainActivity`中使用`inject` 一个 `tool` 对象\n\n```java\nclass MainActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    GlowApplication.getAppComponent().inject(this);\n  }\n}\n```\n\n#### 2. 在 Library 中集成 Dagger\n\n（下面以公用Library：Community为例子）\n\n逆向思维下，先设想应用场景：即 Dagger 已经集成好了，那么我们应该可以按如下方式在 `CommunityActivity` 里 `inject` 一个 `tool` 对象。\n\n```java\nclass CommunityActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    GlowApplication.getAppComponent().inject(this);\n  }\n}\n```\n\n关键在于： `GlowApplication.getAppComponent().inject(this);` 这一句。\n\n那么问题来了：\n\n**对于一个 Library 而言，它是无法拿到 GlowApplication 对象的，因为作为一个被别人调用的 Library，它甚至不知道这个上层 class 的存在**\n\n为了解决这个问题，我们在`community`里定义一个公用接口作为`中间桥梁`，让`GlowApplication`实现这个公共接口即可。\n\n```java\n// 在Community定义接口CommunityComponentProvider\npublic interface CommunityComponentProvider {\n  AppComponent getAppComponent();\n}\n```\n\n```java\n// 每个app的Application类都实现这个接口来提供AppComponent\nclass GlowApplication implements CommunityComponentProvider {\n  AppComponent getAppComponent() {\n    return appComponent;\n  }\n}\n```\n\n然后 `CommunityActivity`就可以实现如下：\n\n```java\nclass CommunityActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    Context applicationContext = getApplicationContext();\n    CommunityComponentProvider provider = (CommunityComponentProvider) applicationContext;\n    provider.getAppComponent().inject(this);\n  }\n}\n```\n\n#### 3. 从 AppComponent 抽离 CommunityComponent\n\n```java\nprovider.getAppComponent().inject(this);\n```\n\n这一句里我们已经实现前半句 `provider.getAppComponent()` 了，但后半句的实现呢？\n\n正常情况下，我们要把\n\n```java\nvoid inject(CommunityActivity communityActivity);\n```\n\n放入 `AppComponent` 中\n\n```java\n@Singleton\n@Component(modules = AppModule.class)\npublic interface AppComponent {\n  void inject(MainActivity mainActivity);\n  \n  // 加在这里\n  void inject(CommunityActivity communityActivity);\n}\n```\n\n其实这样我们就已经几乎完成了整个 Library 和 App 的依赖注入了。\n\n但细心的朋友应该发现里面存在一个小问题，那就是\n\n```java\nvoid inject(CommunityActivity communityActivity);\n```\n\n这句代码如果放入了 `App` 里的 `AppComponent` 里，那就意味着我们也需要在另外三个 `App` 里的 `AppComponent` 都加上一句相同的代码？这样可以吗？\n\n理论上当然是可行的。但是，从单一职责的角度来考虑，`AppComponent` 只需要负责 `App` 层的 `inject` 就行，我们不应该把属于 `Community` 的 `inject` 放到`App` 里，这样的代码太ugly，而且更重要的是，随着 Community 越来越多 Activity 需要 inject ，每个 inject 都要在各个 App 里重复加，这太烦了，也太笨了。\n\n因此，我们采用了一个简洁有效的方法来改进。\n\n在 `Community` 里创建一个 `CommunityComponent`，所有属于 `Community` 的`inject` 直接写在 `CommunityComponent` 里，不需要 `App` 再去关心。与此同时，为了保持前面 `provider.getAppComponent()` 仍然有效，我们让 `AppComponent` 继承 `CommunityComponent`。\n\n实现代码如下：\n\n```java\nclass AppComponent extends CommunityComponent {...}\n```\n\n在 `Community` 里\n\n```java\nclass CommunityComponent {\n  void inject(CommunityActivity communityActivity);\n}\n```\n\n```java\nclass CommunityActivity extends Activity {\n  @Inject Tool tool;\n  \n  @Override\n  public void onCreate() {\n    Context applicationContext = getApplicationContext();\n    CommunityComponentProvider provider = (CommunityComponentProvider) applicationContext;\n    provider.getAppComponent().inject(this);\n  }\n}\n```\n\n![依赖注入](http://upload-images.jianshu.io/upload_images/281665-483c8a864c09503d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nBingo! 至此我们已经能够优雅简洁地在 App 和 Library 里同时应用依赖注入了。\n\n\n\n## 小结\n\n由于篇幅有限，本文暂时先从网络层、内存优化和依赖注入方面进行讲解，之后会再考虑从 Logging模块、数据同步模块、Deep Linking模块、多Library的Gradle发布管理、持续集成和崩溃监测模块等进行讲解。\n\n谢谢。\n\nwingjay\n\n\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>","slug":"干货-Glow-Android-优化实践","published":1,"updated":"2017-06-23T04:07:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm1c001mmoyx0huzkmtc","sticky":0},{"title":"带你学开源项目：OkHttp-- 自己动手实现 okhttp","date":"2016-07-21T06:54:33.000Z","commentIssueId":14,"_content":"> 私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。\n此次来分享下 OkHttp 源码的分析。\n\n<!-- more -->\n\n## 一、开源项目 OkHttp\n在Android、Java开发领域中，相信大家都听过或者在使用Square家大名鼎鼎的网络请求库——[OkHttp](https://github.com/square/okhttp)——https://github.com/square/okhttp ，当前多数著名的开源项目如 [Fresco](https://github.com/facebook/fresco)、[Glide](https://github.com/bumptech/glide)、 [Picasso](https://github.com/square/picasso)、 [Retrofit](https://github.com/square/retrofit)都在使用OkHttp，这足以说明其质量，而且该项目仍处在[不断维护中](https://github.com/square/okhttp/commits/master)。\n\n\n## 二、问题\n在分析okhttp源码之前，我想先提出一个问题，如果我们自己来设计一个网络请求库，这个库应该长什么样子？大致是什么结构呢？\n\n下面我和大家一起来构建一个网络请求库，并在其中融入okhttp中核心的设计思想，希望借此让读者感受并学习到okhttp中的精华之处，而非仅限于了解其实现。\n\n笔者相信，如果你能耐心阅读完本篇，不仅能对http协议有进一步理解，更能够学习到世界级项目的思维精华，提高自身思维方式。\n\n## 三、思考\n首先，我们假设要构建的的网络请求库叫做`WingjayHttpClient`，那么，作为一个网络请求库，它最基本功能是什么呢？\n\n在我看来应该是：接收用户的请求 -> 发出请求 -> 接收响应结果并返回给用户。\n\n那么从使用者角度而言，需要做的事是：\n\n1. 创建一个`Request`：在里面设置好目标URL；请求method如GET/POST等；一些header如Host、User-Agent等；如果你在POST上传一个表单，那么还需要body。\n2. 将创建好的`Request`传递给`WingjayHttpClient`。\n3. `WingjayHttpClient`去执行`Request`，并把返回结果封装成一个`Response`给用户。而一个`Response`里应该包括statusCode如200，一些header如content-type等，可能还有body\n\n到此即为一次完整请求的雏形。那么下面我们来具体实现这三步。\n\n## 四、雏形实现\n下面我们先来实现一个httpClient的雏形，只具备最基本的功能。\n\n#### 1. 创建`Request`类\n首先，我们要建立一个`Request`类，利用`Request`类用户可以把自己需要的参数传入进去，基本形式如下：\n```\nclass Request {\n\tString url;\n\tString method;\n\tHeaders headers;\n\tBody requestBody;\n\n\tpublic Request(String url, String method, @Nullable Headers headers, @Nullable Body body) {\n\t\tthis.url = url;\n\t\t...\n\t}\n}\n```\n#### 2. 将`Request`对象传递给`WingjayHttpClient`\n我们可以设计`WingjayHttpClient`如下：\n```\nclass WingjayHttpClient {\n\tpublic Response sendRequest(Request request) {\n\t\treturn executeRequest(request);\n\t}\n}\n```\n#### 3. 执行`Request`，并把返回结果封装成一个`Response`返回\n```\nclass WingjayHttpClient {\n\t...\n\tprivate Response executeRequest(Request request) {\n\t\t//使用socket来进行访问\n\t\tSocket socket = new Socket(request.getUrl(), 80);\n\t\tResponseData data = socket.connect().getResponseData();\n\t\treturn new Response(data);\n\t}\n\t...\n}\n\nclass Response {\n\tint statusCode;\n\tHeaders headers;\n\tBody responseBody\n\t...\n}\n```\n\n## 五、功能扩展\n利用上面的雏形，可以得到其使用方法如下：\n```\nRequest request = new Request(\"http://wingjay.com\");\nWingjayHttpClient client = new WingjayHttpClient();\nResponse response = client.sendRequest(request);\nhandle(response);\n```\n\n然而，上面的雏形是远远不能胜任常规的应用需求的，因此，下面再来对它添加一些常用的功能模块。\n\n#### 1. 重新把简陋的user Request组装成一个规范的http request\n一般的request中，往往用户只会指定一个URL和method，这个简单的user request是不足以成为一个http request，我们还需要为它添加一些header，如Content-Length, Transfer-Encoding, User-Agent, Host, Connection, 和 Content-Type，如果这个request使用了cookie，那我们还要将cookie添加到这个request中。\n\n我们可以扩展上面的`sendRequest(request)`方法：\n```\n[class WingjayHttpClient]\n\npublic Response sendRequest(Request userRequest) {\n    Request httpRequest = expandHeaders(userRequest);\n    return executeRequest(httpRequest);\n}\n\nprivate Request expandHeaders(Request userRequest) {\n    if (userRequest.header(\"Connection\") == null) {\n      requestBuilder.header(\"Connection\", \"Keep-Alive\");\n    }\n    \n    if (userRequest.header(\"User-Agent\") == null) {\n      requestBuilder.header(\"User-Agent\", Version.userAgent());\n    }\n    ...\n}\t\n```\n\n#### 2. 支持自动重定向\n有时我们请求的URL已经被移走了，此时server会返回301状态码和一个重定向的新URL，此时我们要能够支持自动访问新URL而不是向用户报错。\n\n对于重定向这里有一个测试性URL：http://www.publicobject.com/helloworld.txt ，通过访问并抓包，可以看到如下信息：\n\n![](http://upload-images.jianshu.io/upload_images/281665-62df4e64fd04dc24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n因此，我们在接收到Response后要根据status_code是否为重定向，如果是，则要从Response Header里解析出新的URL－`Location`并自动请求新URL。那么，我们可以继续改写`sendRequest(request)`方法：\n```java\n[class WingjayHttpClient]\n\nprivate boolean allowRedirect = true;\n// user can set redirect status when building WingjayHttpClient\npublic void setAllowRedirect(boolean allowRedirect) {\n\tthis.allowRedirect = allowRedirect;\n}\n\npublic Response sendRequest(Request userRequest) {\n\t\tRequest httpRequest = expandHeaders(userRequest);\n\t\tResponse response = executeRequest(httpRequest);\n\t\tswitch (response.statusCode()) {\n\t\t\t// 300: multi choice; 301: moven permanently; \n\t\t\t// 302: moved temporarily; 303: see other; \n\t\t\t// 307: redirect temporarily; 308: redirect permanently\n\t\t\tcase 300:\n\t\t\tcase 301:\n\t\t\tcase 302:\n\t\t\tcase 303:\n\t\t\tcase 307:\n\t\t\tcase 308:\n\t\t\t\treturn handleRedirect(response);\n\t\t\tdefault:\n\t\t\t\treturn response;\n\t\t}\n\t\t\n}\n// the max times of followup request\nprivate static final int MAX_FOLLOW_UPS = 20;\nprivate int followupCount = 0;\n\nprivate Response handleRedirect(Response response) {\n\t// Does the WingjayHttpClient allow redirect?\n\tif (!client.allowRedirect()) {\n\t\treturn null;\n\t}\n\n\t// Get the redirecting url\n\tString nextUrl = response.header(\"Location\");\n\n\t// Construct a redirecting request\n\tRequest followup = new Request(nextUrl);\n\n\t// check the max followupCount\n\tif (++followupCount > MAX_FOLLOW_UPS) {\n\t\tthrow new Exception(\"Too many follow-up requests: \" + followUpCount);\n\t}\n\n\t// not reach the max followup times, send followup request then.\n\treturn sendRequest(followup);\n}\n```\n利用上面的代码，我们通过获取原始`userRequest`的返回结果，判断结果是否为重定向，并做出自动followup处理。\n\n> 一些常用的状态码\n100~199：指示信息，表示请求已接收，继续处理\n200~299：请求成功，表示请求已被成功接收、理解、接受\n300~399：重定向，要完成请求必须进行更进一步的操作\n400~499：客户端错误，请求有语法错误或请求无法实现\n500~599：服务器端错误，服务器未能实现合法的请求\n\n#### 3. 支持重试机制\n所谓重试，和重定向非常类似，即通过判断`Response`状态，如果连接服务器失败等，那么可以尝试获取一个新的路径进行重新连接，大致的实现和重定向非常类似，此不赘述。\n\n#### 4. Request & Response 拦截机制\n这是非常核心的部分。\n\n通过上面的重新组装`request`和重定向机制，我们可以感受的，一个`request`从user创建出来后，会经过层层处理后，才真正发出去，而一个`response`，也会经过各种处理，最终返回给用户。\n\n笔者认为这和网络协议栈非常相似，用户在应用层发出简单的数据，然后经过传输层、网络层等，层层封装后真正把请求从物理层发出去，当请求结果回来后又层层解析，最终把最直接的结果返回给用户使用。\n\n最重要的是，每一层都是抽象的，互不相关的！\n\n因此在我们设计时，也可以借鉴这个思想，通过设置`拦截器Interceptor`，每个拦截器会做两件事情：\n\n1. 接收上一层拦截器封装后的request，然后自身对这个request进行处理，例如添加一些header，处理后向下传递；\n2. 接收下一层拦截器传递回来的response，然后自身对response进行处理，例如判断返回的statusCode，然后进一步处理。\n\n那么，我们可以为拦截器定义一个抽象接口，然后去实现具体的拦截器。\n```java\ninterface Interceptor {\n\tResponse intercept(Request request);\n}\n```\n大家可以看下上面这个拦截器设计是否有问题？\n\n![](http://upload-images.jianshu.io/upload_images/281665-00ec5b478499a386.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们想象这个拦截器能够接收一个request，进行拦截处理，并返回结果。\n\n但实际上，它无法返回结果，而且它在处理request后，并不能继续向下传递，因为它并不知道下一个`Interceptor`在哪里，也就无法继续向下传递。\n\n那么，如何解决才能把所有`Interceptor`串在一起，并能够依次传递下去。\n```java\npublic interface Interceptor {\n  Response intercept(Chain chain);\n\n  interface Chain {\n    Request request();\n\n    Response proceed(Request request);\n  }\n}\n```\n使用方法如下：假如我们现在有三个`Interceptor`需要依次拦截：\n```java\n// Build a full stack of interceptors.\nList<Interceptor> interceptors = new ArrayList<>();\ninterceptors.add(new MyInterceptor1());\ninterceptors.add(new MyInterceptor2());\ninterceptors.add(new MyInterceptor3());\n\nInterceptor.Chain chain = new RealInterceptorChain(\n        interceptors, 0, originalRequest);\nchain.proceed(originalRequest);        \n```\n里面的`RealInterceptorChain`的基本思想是：我们把所有`interceptors`传进去，然后`chain`去依次把`request`传入到每一个`interceptors`进行拦截即可。\n\n通过下面的示意图可以明确看出拦截流程：\n\n![](http://upload-images.jianshu.io/upload_images/281665-aa94adfc49da4e40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中，`RetryAndFollowupInterceptor`是用来做自动重试和自动重定向的拦截器；`BridgeInterceptor`是用来扩展`request`的`header`的拦截器。这两个拦截器存在于`okhttp`里，实际上在`okhttp`里还有好几个拦截器，这里暂时不做深入分析。\n\n![](http://upload-images.jianshu.io/upload_images/281665-1b58154250ce74d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n1. `CacheInterceptor`\n这是用来拦截请求并提供缓存的，当request进入这一层，它会自动去检查缓存，如果有，就直接返回缓存结果；否则的话才将request继续向下传递。而且，当下层把response返回到这一层，它会根据需求进行缓存处理；\n\n2. `ConnectInterceptor`\n这一层是用来与目标服务器建立连接\n\n3. `CallServerInterceptor`\n这一层位于最底层，直接向服务器发出请求，并接收服务器返回的response，并向上层层传递。\n\n上面几个都是okhttp自带的，也就是说需要在`WingjayHttpClient`自己实现的。除了这几个功能性的拦截器，我们还要支持用户`自定义拦截器`，主要有以下两种（见图中非虚线框蓝色字部分）：\n\n1. `interceptors`\n这里的拦截器是拦截用户最原始的request。\n\n2. `NetworkInterceptor`\n这是最底层的request拦截器。\n\n如何区分这两个呢？举个例子，我创建两个`LoggingInterceptor`，分别放在`interceptors`层和`NetworkInterceptor`层，然后访问一个会重定向的`URL_1`，当访问完`URL_1`后会再去访问重定向后的新地址`URL_2`。对于这个过程，`interceptors`层的拦截器只会拦截到`URL_1`的request，而在`NetworkInterceptor`层的拦截器则会同时拦截到`URL_1`和`URL_2`两个request。具体原因可以看上面的图。\n\n#### 5. 同步、异步 Request池管理机制\n这是非常核心的部分。\n\n通过上面的工作，我们修改`WingjayHttpClient`后得到了下面的样子：\n```java\nclass WingjayHttpClient {\n\tpublic Response sendRequest(Request userRequest) {\n\t\tRequest httpRequest = expandHeaders(userRequest);\n\t\tResponse response = executeRequest(httpRequest);\n\t\tswitch (response.statusCode()) {\n\t\t\t// 300: multi choice; 301: moven permanently; \n\t\t\t// 302: moved temporarily; 303: see other; \n\t\t\t// 307: redirect temporarily; 308: redirect permanently\n\t\t\tcase 300:\n\t\t\tcase 301:\n\t\t\tcase 302:\n\t\t\tcase 303:\n\t\t\tcase 307:\n\t\t\tcase 308:\n\t\t\t\treturn handleRedirect(response);\n\t\t\tdefault:\n\t\t\t\treturn response;\n\t\t}\n\t}\n\n\tprivate Request expandHeaders(Request userRequest) {...}\n\tprivate Response executeRequest(Request httpRequest) {...}\n\tprivate Response handleRedirect(Response response) {...}\n}\n```\n也就是说，`WingjayHttpClient`现在能够`同步`地处理单个`Request`了。\n\n然而，在实际应用中，一个`WingjayHttpClient`可能会被用于同时处理几十个用户request，而且这些request里还分成了`同步`和`异步`两种不同的请求方式，所以我们显然不能简单把一个request直接塞给`WingjayHttpClient`。\n\n我们知道，一个request除了上面定义的http协议相关的内容，还应该要设置其处理方式`同步`和`异步`。那这些信息应该存在哪里呢？两种选择：\n\n1. 直接放入`Request`\n从理论上来讲是可以的，但是却违背了初衷。我们最开始是希望用`Request`来构造符合http协议的一个请求，里面应该包含的是请求目标网址URL，请求端口，请求方法等等信息，而http协议是不关心这个request是同步还是异步之类的信息\n\n2. 创建一个类，专门来管理`Request`的状态\n这是更为合适的，我们可以更好的拆分职责。\n\n因此，这里选择创建两个类`SyncCall`和`AsyncCall`，用来区分`同步`和`异步`。\n```java\nclass SyncCall {\n\tprivate Request userRequest;\n\n\tpublic SyncCall(Request userRequest) {\n\t\tthis.userRequest = userRequest;\n\t}\n}\n\nclass AsyncCall {\n\tprivate Request userRequest;\n\tprivate Callback callback;\n\n\tpublic AsyncCall(Request userRequest, Callback callback) {\n\t\tthis.userRequest = userRequest;\n\t\tthis.callback = callback;\n\t}\n\n\tinterface Callback {\n\t\tvoid onFailure(Call call, IOException e);\n\t\tvoid onResponse(Call call, Response response) throws IOException;\n\t}\n}\n```\n基于上面两个类，我们的使用场景如下：\n```java\nWingjayHttpClient client = new WingjayHttpClient();\n// Sync\nRequest syncRequest = new Request(\"http://wingjay.com\");\nSyncCall syncCall = new SyncCall(request);\nResponse response = client.sendSyncCall(syncCall);\nhandle(response);\n\n// Async\nAsyncCall asyncCall = new AsyncCall(request, new CallBack() {\n\t  @Override\n      public void onFailure(Call call, IOException e) {}\n\n      @Override\n      public void onResponse(Call call, Response response) throws IOException {\n        handle(response);\n      }\n});\nclient.equeueAsyncCall(asyncCall);\n```\n从上面的代码可以看到，`WingjayHttpClient`的职责发生了变化：以前是**response = client.sendRequest(request);**，而现在变成了\n```java\nresponse = client.sendSyncCall(syncCall);\n\nclient.equeueAsyncCall(asyncCall);\n```\n\n那么，我们也需要对`WingjayHttpClient`进行改造，基本思路是在内部添加`请求池`来对所有request进行管理。那么这个`请求池`我们怎么来设计呢？有两个方法：\n\n1. 直接在`WingjayHttpClient`内部创建几个容器\n同样，从理论上而言是可行的。当用户把(a)syncCall传给client后，client自动把call存入对应的容器进行管理。\n\n2. 创建一个独立的类进行管理\n显然这样可以更好的分配职责。我们把`WingjayHttpClient`的职责定义为，接收一个call，内部进行处理后返回结果。这就是`WingjayHttpClient`的任务，那么具体如何去管理这些request的执行顺序和生命周期，自然不需要由它来管。\n\n因此，我们创建一个新的类：`Dispatcher`，这个类的作用是：\n\n1. 存储外界不断传入的`SyncCall`和`AsyncCall`，如果用户想取消则可以遍历所有的call进行cancel操作;\n2. 对于`SyncCall`，由于它是即时运行的，因此`Dispatcher`只需要在`SyncCall`运行前存储进来，在运行结束后移除即可；\n3. 对于`AsyncCall`，`Dispatcher`首先启动一个ExecutorService，不断取出`AsyncCall`去进行执行，然后，我们设置最多执行的request数量为64，如果已经有64个request在执行中，那么就将这个asyncCall存入等待区。\n\n根据设计可以得到`Dispatcher`构造：\n```java\nclass Dispatcher {\n\t// sync call\n\tprivate final Deque<SyncCall> runningSyncCalls = new ArrayDeque<>();\n\t// async call\n\tprivate int maxRequests = 64;\n\tprivate final Deque<AsyncCall> waitingAsyncCalls = new ArrayDeque<>();\n\tprivate final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n\tprivate ExecutorService executorService;\n\n\t// begin execute Sync call\n\tpublic void startSyncCall(SyncCall syncCall) {\n\t\trunningSyncCalls.add(syncCall);\n\t}\n\t// finish Sync call\n\tpublic void finishSyncCall(SyncCall syncCall) {\n\t\trunningSyncCalls.remove(syncCall);\n\t}\n\n\t// enqueue a new AsyncCall\n\tpublic void enqueue(AsyncCall asyncCall) {\n\t\tif (runningAsyncCalls.size() < 64) {\n\t\t\t// run directly\n\t\t\trunningAsyncCalls.add(asyncCall);\n\t\t\texecutorService.execute(asyncCall);\n\t\t} else {\n\t\t\treadyAsyncCalls.add(asyncCall);\n\t\t}\n\t}\n\t// finish a AsyncCall\n\tpublic void finishAsyncCall(AsyncCall asyncCall) {\n\t\trunningAsyncCalls.remove(asyncCall);\n\t}\n}\n```\n有了这个`Dispatcher`，那我们就可以去修改`WingjayHttpClient`以实现\n```java\nresponse = client.sendSyncCall(syncCall);\n\nclient.equeueAsyncCall(asyncCall);\n```\n这两个方法了。具体实现如下\n```java\n[class WingjayHttpClient]\n\n\tprivate Dispatcher dispatcher;\n\n\tpublic Response sendSyncCall(SyncCall syncCall) {\n\t\ttry {\n\t\t\t// store syncCall into dispatcher;\n\t\t\tdispatcher.startSyncCall(syncCall);\n\t\t\t// execute\n\t\t\treturn sendRequest(syncCall.getRequest());\n\t\t} finally {\n\t\t\t// remove syncCall from dispatcher\n\t\t\tdispatcher.finishSyncCall(syncCall);\n\t\t}\n\t}\n\n\tpublic void equeueAsyncCall(AsyncCall asyncCall) {\n\t\t// store asyncCall into dispatcher;\n\t\tdispatcher.enqueue(asyncCall);\n\t\t// it will be removed when this asyncCall be executed\n\t}\n```\n\n基于以上，我们能够很好的处理`同步`和`异步`两种请求，使用场景如下：\n```java\nWingjayHttpClient client = new WingjayHttpClient();\n// Sync\nRequest syncRequest = new Request(\"http://wingjay.com\");\nSyncCall syncCall = new SyncCall(request);\nResponse response = client.sendSyncCall(syncCall);\nhandle(response);\n\n// Async\nAsyncCall asyncCall = new AsyncCall(request, new CallBack() {\n\t  @Override\n      public void onFailure(Call call, IOException e) {}\n\n      @Override\n      public void onResponse(Call call, Response response) throws IOException {\n        handle(response);\n      }\n});\nclient.equeueAsyncCall(asyncCall);\n```\n\n## 六、总结\n到此，我们基本把`okhttp`里核心的机制都讲解了一遍，相信读者对于okhttp的整体结构和核心机制都有了较为详细的了解。\n\n如果有问题欢迎联系我。\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/带你学开源项目：OkHttp-自己动手实现okhttp.md","raw":"title: 带你学开源项目：OkHttp--自己动手实现okhttp\ndate: 2016-07-21 14:54:33\ncategories:\n  - Android\n  - 带你学开源项目\ntags:\n    - Android\n    - 带你学开源项目\ncommentIssueId: 14    \n---\n> 私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。\n此次来分享下 OkHttp 源码的分析。\n\n<!-- more -->\n\n## 一、开源项目 OkHttp\n在Android、Java开发领域中，相信大家都听过或者在使用Square家大名鼎鼎的网络请求库——[OkHttp](https://github.com/square/okhttp)——https://github.com/square/okhttp ，当前多数著名的开源项目如 [Fresco](https://github.com/facebook/fresco)、[Glide](https://github.com/bumptech/glide)、 [Picasso](https://github.com/square/picasso)、 [Retrofit](https://github.com/square/retrofit)都在使用OkHttp，这足以说明其质量，而且该项目仍处在[不断维护中](https://github.com/square/okhttp/commits/master)。\n\n\n## 二、问题\n在分析okhttp源码之前，我想先提出一个问题，如果我们自己来设计一个网络请求库，这个库应该长什么样子？大致是什么结构呢？\n\n下面我和大家一起来构建一个网络请求库，并在其中融入okhttp中核心的设计思想，希望借此让读者感受并学习到okhttp中的精华之处，而非仅限于了解其实现。\n\n笔者相信，如果你能耐心阅读完本篇，不仅能对http协议有进一步理解，更能够学习到世界级项目的思维精华，提高自身思维方式。\n\n## 三、思考\n首先，我们假设要构建的的网络请求库叫做`WingjayHttpClient`，那么，作为一个网络请求库，它最基本功能是什么呢？\n\n在我看来应该是：接收用户的请求 -> 发出请求 -> 接收响应结果并返回给用户。\n\n那么从使用者角度而言，需要做的事是：\n\n1. 创建一个`Request`：在里面设置好目标URL；请求method如GET/POST等；一些header如Host、User-Agent等；如果你在POST上传一个表单，那么还需要body。\n2. 将创建好的`Request`传递给`WingjayHttpClient`。\n3. `WingjayHttpClient`去执行`Request`，并把返回结果封装成一个`Response`给用户。而一个`Response`里应该包括statusCode如200，一些header如content-type等，可能还有body\n\n到此即为一次完整请求的雏形。那么下面我们来具体实现这三步。\n\n## 四、雏形实现\n下面我们先来实现一个httpClient的雏形，只具备最基本的功能。\n\n#### 1. 创建`Request`类\n首先，我们要建立一个`Request`类，利用`Request`类用户可以把自己需要的参数传入进去，基本形式如下：\n```\nclass Request {\n\tString url;\n\tString method;\n\tHeaders headers;\n\tBody requestBody;\n\n\tpublic Request(String url, String method, @Nullable Headers headers, @Nullable Body body) {\n\t\tthis.url = url;\n\t\t...\n\t}\n}\n```\n#### 2. 将`Request`对象传递给`WingjayHttpClient`\n我们可以设计`WingjayHttpClient`如下：\n```\nclass WingjayHttpClient {\n\tpublic Response sendRequest(Request request) {\n\t\treturn executeRequest(request);\n\t}\n}\n```\n#### 3. 执行`Request`，并把返回结果封装成一个`Response`返回\n```\nclass WingjayHttpClient {\n\t...\n\tprivate Response executeRequest(Request request) {\n\t\t//使用socket来进行访问\n\t\tSocket socket = new Socket(request.getUrl(), 80);\n\t\tResponseData data = socket.connect().getResponseData();\n\t\treturn new Response(data);\n\t}\n\t...\n}\n\nclass Response {\n\tint statusCode;\n\tHeaders headers;\n\tBody responseBody\n\t...\n}\n```\n\n## 五、功能扩展\n利用上面的雏形，可以得到其使用方法如下：\n```\nRequest request = new Request(\"http://wingjay.com\");\nWingjayHttpClient client = new WingjayHttpClient();\nResponse response = client.sendRequest(request);\nhandle(response);\n```\n\n然而，上面的雏形是远远不能胜任常规的应用需求的，因此，下面再来对它添加一些常用的功能模块。\n\n#### 1. 重新把简陋的user Request组装成一个规范的http request\n一般的request中，往往用户只会指定一个URL和method，这个简单的user request是不足以成为一个http request，我们还需要为它添加一些header，如Content-Length, Transfer-Encoding, User-Agent, Host, Connection, 和 Content-Type，如果这个request使用了cookie，那我们还要将cookie添加到这个request中。\n\n我们可以扩展上面的`sendRequest(request)`方法：\n```\n[class WingjayHttpClient]\n\npublic Response sendRequest(Request userRequest) {\n    Request httpRequest = expandHeaders(userRequest);\n    return executeRequest(httpRequest);\n}\n\nprivate Request expandHeaders(Request userRequest) {\n    if (userRequest.header(\"Connection\") == null) {\n      requestBuilder.header(\"Connection\", \"Keep-Alive\");\n    }\n    \n    if (userRequest.header(\"User-Agent\") == null) {\n      requestBuilder.header(\"User-Agent\", Version.userAgent());\n    }\n    ...\n}\t\n```\n\n#### 2. 支持自动重定向\n有时我们请求的URL已经被移走了，此时server会返回301状态码和一个重定向的新URL，此时我们要能够支持自动访问新URL而不是向用户报错。\n\n对于重定向这里有一个测试性URL：http://www.publicobject.com/helloworld.txt ，通过访问并抓包，可以看到如下信息：\n\n![](http://upload-images.jianshu.io/upload_images/281665-62df4e64fd04dc24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n因此，我们在接收到Response后要根据status_code是否为重定向，如果是，则要从Response Header里解析出新的URL－`Location`并自动请求新URL。那么，我们可以继续改写`sendRequest(request)`方法：\n```java\n[class WingjayHttpClient]\n\nprivate boolean allowRedirect = true;\n// user can set redirect status when building WingjayHttpClient\npublic void setAllowRedirect(boolean allowRedirect) {\n\tthis.allowRedirect = allowRedirect;\n}\n\npublic Response sendRequest(Request userRequest) {\n\t\tRequest httpRequest = expandHeaders(userRequest);\n\t\tResponse response = executeRequest(httpRequest);\n\t\tswitch (response.statusCode()) {\n\t\t\t// 300: multi choice; 301: moven permanently; \n\t\t\t// 302: moved temporarily; 303: see other; \n\t\t\t// 307: redirect temporarily; 308: redirect permanently\n\t\t\tcase 300:\n\t\t\tcase 301:\n\t\t\tcase 302:\n\t\t\tcase 303:\n\t\t\tcase 307:\n\t\t\tcase 308:\n\t\t\t\treturn handleRedirect(response);\n\t\t\tdefault:\n\t\t\t\treturn response;\n\t\t}\n\t\t\n}\n// the max times of followup request\nprivate static final int MAX_FOLLOW_UPS = 20;\nprivate int followupCount = 0;\n\nprivate Response handleRedirect(Response response) {\n\t// Does the WingjayHttpClient allow redirect?\n\tif (!client.allowRedirect()) {\n\t\treturn null;\n\t}\n\n\t// Get the redirecting url\n\tString nextUrl = response.header(\"Location\");\n\n\t// Construct a redirecting request\n\tRequest followup = new Request(nextUrl);\n\n\t// check the max followupCount\n\tif (++followupCount > MAX_FOLLOW_UPS) {\n\t\tthrow new Exception(\"Too many follow-up requests: \" + followUpCount);\n\t}\n\n\t// not reach the max followup times, send followup request then.\n\treturn sendRequest(followup);\n}\n```\n利用上面的代码，我们通过获取原始`userRequest`的返回结果，判断结果是否为重定向，并做出自动followup处理。\n\n> 一些常用的状态码\n100~199：指示信息，表示请求已接收，继续处理\n200~299：请求成功，表示请求已被成功接收、理解、接受\n300~399：重定向，要完成请求必须进行更进一步的操作\n400~499：客户端错误，请求有语法错误或请求无法实现\n500~599：服务器端错误，服务器未能实现合法的请求\n\n#### 3. 支持重试机制\n所谓重试，和重定向非常类似，即通过判断`Response`状态，如果连接服务器失败等，那么可以尝试获取一个新的路径进行重新连接，大致的实现和重定向非常类似，此不赘述。\n\n#### 4. Request & Response 拦截机制\n这是非常核心的部分。\n\n通过上面的重新组装`request`和重定向机制，我们可以感受的，一个`request`从user创建出来后，会经过层层处理后，才真正发出去，而一个`response`，也会经过各种处理，最终返回给用户。\n\n笔者认为这和网络协议栈非常相似，用户在应用层发出简单的数据，然后经过传输层、网络层等，层层封装后真正把请求从物理层发出去，当请求结果回来后又层层解析，最终把最直接的结果返回给用户使用。\n\n最重要的是，每一层都是抽象的，互不相关的！\n\n因此在我们设计时，也可以借鉴这个思想，通过设置`拦截器Interceptor`，每个拦截器会做两件事情：\n\n1. 接收上一层拦截器封装后的request，然后自身对这个request进行处理，例如添加一些header，处理后向下传递；\n2. 接收下一层拦截器传递回来的response，然后自身对response进行处理，例如判断返回的statusCode，然后进一步处理。\n\n那么，我们可以为拦截器定义一个抽象接口，然后去实现具体的拦截器。\n```java\ninterface Interceptor {\n\tResponse intercept(Request request);\n}\n```\n大家可以看下上面这个拦截器设计是否有问题？\n\n![](http://upload-images.jianshu.io/upload_images/281665-00ec5b478499a386.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们想象这个拦截器能够接收一个request，进行拦截处理，并返回结果。\n\n但实际上，它无法返回结果，而且它在处理request后，并不能继续向下传递，因为它并不知道下一个`Interceptor`在哪里，也就无法继续向下传递。\n\n那么，如何解决才能把所有`Interceptor`串在一起，并能够依次传递下去。\n```java\npublic interface Interceptor {\n  Response intercept(Chain chain);\n\n  interface Chain {\n    Request request();\n\n    Response proceed(Request request);\n  }\n}\n```\n使用方法如下：假如我们现在有三个`Interceptor`需要依次拦截：\n```java\n// Build a full stack of interceptors.\nList<Interceptor> interceptors = new ArrayList<>();\ninterceptors.add(new MyInterceptor1());\ninterceptors.add(new MyInterceptor2());\ninterceptors.add(new MyInterceptor3());\n\nInterceptor.Chain chain = new RealInterceptorChain(\n        interceptors, 0, originalRequest);\nchain.proceed(originalRequest);        \n```\n里面的`RealInterceptorChain`的基本思想是：我们把所有`interceptors`传进去，然后`chain`去依次把`request`传入到每一个`interceptors`进行拦截即可。\n\n通过下面的示意图可以明确看出拦截流程：\n\n![](http://upload-images.jianshu.io/upload_images/281665-aa94adfc49da4e40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n其中，`RetryAndFollowupInterceptor`是用来做自动重试和自动重定向的拦截器；`BridgeInterceptor`是用来扩展`request`的`header`的拦截器。这两个拦截器存在于`okhttp`里，实际上在`okhttp`里还有好几个拦截器，这里暂时不做深入分析。\n\n![](http://upload-images.jianshu.io/upload_images/281665-1b58154250ce74d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n1. `CacheInterceptor`\n这是用来拦截请求并提供缓存的，当request进入这一层，它会自动去检查缓存，如果有，就直接返回缓存结果；否则的话才将request继续向下传递。而且，当下层把response返回到这一层，它会根据需求进行缓存处理；\n\n2. `ConnectInterceptor`\n这一层是用来与目标服务器建立连接\n\n3. `CallServerInterceptor`\n这一层位于最底层，直接向服务器发出请求，并接收服务器返回的response，并向上层层传递。\n\n上面几个都是okhttp自带的，也就是说需要在`WingjayHttpClient`自己实现的。除了这几个功能性的拦截器，我们还要支持用户`自定义拦截器`，主要有以下两种（见图中非虚线框蓝色字部分）：\n\n1. `interceptors`\n这里的拦截器是拦截用户最原始的request。\n\n2. `NetworkInterceptor`\n这是最底层的request拦截器。\n\n如何区分这两个呢？举个例子，我创建两个`LoggingInterceptor`，分别放在`interceptors`层和`NetworkInterceptor`层，然后访问一个会重定向的`URL_1`，当访问完`URL_1`后会再去访问重定向后的新地址`URL_2`。对于这个过程，`interceptors`层的拦截器只会拦截到`URL_1`的request，而在`NetworkInterceptor`层的拦截器则会同时拦截到`URL_1`和`URL_2`两个request。具体原因可以看上面的图。\n\n#### 5. 同步、异步 Request池管理机制\n这是非常核心的部分。\n\n通过上面的工作，我们修改`WingjayHttpClient`后得到了下面的样子：\n```java\nclass WingjayHttpClient {\n\tpublic Response sendRequest(Request userRequest) {\n\t\tRequest httpRequest = expandHeaders(userRequest);\n\t\tResponse response = executeRequest(httpRequest);\n\t\tswitch (response.statusCode()) {\n\t\t\t// 300: multi choice; 301: moven permanently; \n\t\t\t// 302: moved temporarily; 303: see other; \n\t\t\t// 307: redirect temporarily; 308: redirect permanently\n\t\t\tcase 300:\n\t\t\tcase 301:\n\t\t\tcase 302:\n\t\t\tcase 303:\n\t\t\tcase 307:\n\t\t\tcase 308:\n\t\t\t\treturn handleRedirect(response);\n\t\t\tdefault:\n\t\t\t\treturn response;\n\t\t}\n\t}\n\n\tprivate Request expandHeaders(Request userRequest) {...}\n\tprivate Response executeRequest(Request httpRequest) {...}\n\tprivate Response handleRedirect(Response response) {...}\n}\n```\n也就是说，`WingjayHttpClient`现在能够`同步`地处理单个`Request`了。\n\n然而，在实际应用中，一个`WingjayHttpClient`可能会被用于同时处理几十个用户request，而且这些request里还分成了`同步`和`异步`两种不同的请求方式，所以我们显然不能简单把一个request直接塞给`WingjayHttpClient`。\n\n我们知道，一个request除了上面定义的http协议相关的内容，还应该要设置其处理方式`同步`和`异步`。那这些信息应该存在哪里呢？两种选择：\n\n1. 直接放入`Request`\n从理论上来讲是可以的，但是却违背了初衷。我们最开始是希望用`Request`来构造符合http协议的一个请求，里面应该包含的是请求目标网址URL，请求端口，请求方法等等信息，而http协议是不关心这个request是同步还是异步之类的信息\n\n2. 创建一个类，专门来管理`Request`的状态\n这是更为合适的，我们可以更好的拆分职责。\n\n因此，这里选择创建两个类`SyncCall`和`AsyncCall`，用来区分`同步`和`异步`。\n```java\nclass SyncCall {\n\tprivate Request userRequest;\n\n\tpublic SyncCall(Request userRequest) {\n\t\tthis.userRequest = userRequest;\n\t}\n}\n\nclass AsyncCall {\n\tprivate Request userRequest;\n\tprivate Callback callback;\n\n\tpublic AsyncCall(Request userRequest, Callback callback) {\n\t\tthis.userRequest = userRequest;\n\t\tthis.callback = callback;\n\t}\n\n\tinterface Callback {\n\t\tvoid onFailure(Call call, IOException e);\n\t\tvoid onResponse(Call call, Response response) throws IOException;\n\t}\n}\n```\n基于上面两个类，我们的使用场景如下：\n```java\nWingjayHttpClient client = new WingjayHttpClient();\n// Sync\nRequest syncRequest = new Request(\"http://wingjay.com\");\nSyncCall syncCall = new SyncCall(request);\nResponse response = client.sendSyncCall(syncCall);\nhandle(response);\n\n// Async\nAsyncCall asyncCall = new AsyncCall(request, new CallBack() {\n\t  @Override\n      public void onFailure(Call call, IOException e) {}\n\n      @Override\n      public void onResponse(Call call, Response response) throws IOException {\n        handle(response);\n      }\n});\nclient.equeueAsyncCall(asyncCall);\n```\n从上面的代码可以看到，`WingjayHttpClient`的职责发生了变化：以前是**response = client.sendRequest(request);**，而现在变成了\n```java\nresponse = client.sendSyncCall(syncCall);\n\nclient.equeueAsyncCall(asyncCall);\n```\n\n那么，我们也需要对`WingjayHttpClient`进行改造，基本思路是在内部添加`请求池`来对所有request进行管理。那么这个`请求池`我们怎么来设计呢？有两个方法：\n\n1. 直接在`WingjayHttpClient`内部创建几个容器\n同样，从理论上而言是可行的。当用户把(a)syncCall传给client后，client自动把call存入对应的容器进行管理。\n\n2. 创建一个独立的类进行管理\n显然这样可以更好的分配职责。我们把`WingjayHttpClient`的职责定义为，接收一个call，内部进行处理后返回结果。这就是`WingjayHttpClient`的任务，那么具体如何去管理这些request的执行顺序和生命周期，自然不需要由它来管。\n\n因此，我们创建一个新的类：`Dispatcher`，这个类的作用是：\n\n1. 存储外界不断传入的`SyncCall`和`AsyncCall`，如果用户想取消则可以遍历所有的call进行cancel操作;\n2. 对于`SyncCall`，由于它是即时运行的，因此`Dispatcher`只需要在`SyncCall`运行前存储进来，在运行结束后移除即可；\n3. 对于`AsyncCall`，`Dispatcher`首先启动一个ExecutorService，不断取出`AsyncCall`去进行执行，然后，我们设置最多执行的request数量为64，如果已经有64个request在执行中，那么就将这个asyncCall存入等待区。\n\n根据设计可以得到`Dispatcher`构造：\n```java\nclass Dispatcher {\n\t// sync call\n\tprivate final Deque<SyncCall> runningSyncCalls = new ArrayDeque<>();\n\t// async call\n\tprivate int maxRequests = 64;\n\tprivate final Deque<AsyncCall> waitingAsyncCalls = new ArrayDeque<>();\n\tprivate final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n\tprivate ExecutorService executorService;\n\n\t// begin execute Sync call\n\tpublic void startSyncCall(SyncCall syncCall) {\n\t\trunningSyncCalls.add(syncCall);\n\t}\n\t// finish Sync call\n\tpublic void finishSyncCall(SyncCall syncCall) {\n\t\trunningSyncCalls.remove(syncCall);\n\t}\n\n\t// enqueue a new AsyncCall\n\tpublic void enqueue(AsyncCall asyncCall) {\n\t\tif (runningAsyncCalls.size() < 64) {\n\t\t\t// run directly\n\t\t\trunningAsyncCalls.add(asyncCall);\n\t\t\texecutorService.execute(asyncCall);\n\t\t} else {\n\t\t\treadyAsyncCalls.add(asyncCall);\n\t\t}\n\t}\n\t// finish a AsyncCall\n\tpublic void finishAsyncCall(AsyncCall asyncCall) {\n\t\trunningAsyncCalls.remove(asyncCall);\n\t}\n}\n```\n有了这个`Dispatcher`，那我们就可以去修改`WingjayHttpClient`以实现\n```java\nresponse = client.sendSyncCall(syncCall);\n\nclient.equeueAsyncCall(asyncCall);\n```\n这两个方法了。具体实现如下\n```java\n[class WingjayHttpClient]\n\n\tprivate Dispatcher dispatcher;\n\n\tpublic Response sendSyncCall(SyncCall syncCall) {\n\t\ttry {\n\t\t\t// store syncCall into dispatcher;\n\t\t\tdispatcher.startSyncCall(syncCall);\n\t\t\t// execute\n\t\t\treturn sendRequest(syncCall.getRequest());\n\t\t} finally {\n\t\t\t// remove syncCall from dispatcher\n\t\t\tdispatcher.finishSyncCall(syncCall);\n\t\t}\n\t}\n\n\tpublic void equeueAsyncCall(AsyncCall asyncCall) {\n\t\t// store asyncCall into dispatcher;\n\t\tdispatcher.enqueue(asyncCall);\n\t\t// it will be removed when this asyncCall be executed\n\t}\n```\n\n基于以上，我们能够很好的处理`同步`和`异步`两种请求，使用场景如下：\n```java\nWingjayHttpClient client = new WingjayHttpClient();\n// Sync\nRequest syncRequest = new Request(\"http://wingjay.com\");\nSyncCall syncCall = new SyncCall(request);\nResponse response = client.sendSyncCall(syncCall);\nhandle(response);\n\n// Async\nAsyncCall asyncCall = new AsyncCall(request, new CallBack() {\n\t  @Override\n      public void onFailure(Call call, IOException e) {}\n\n      @Override\n      public void onResponse(Call call, Response response) throws IOException {\n        handle(response);\n      }\n});\nclient.equeueAsyncCall(asyncCall);\n```\n\n## 六、总结\n到此，我们基本把`okhttp`里核心的机制都讲解了一遍，相信读者对于okhttp的整体结构和核心机制都有了较为详细的了解。\n\n如果有问题欢迎联系我。\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"带你学开源项目：OkHttp-自己动手实现okhttp","published":1,"updated":"2017-06-23T04:08:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm1f001pmoyx89gve7uf","sticky":0},{"title":"带你学开源项目：Meizhi Android 之 RxJava & Retrofit 最佳实践","date":"2016-04-12T16:17:28.000Z","commentIssueId":16,"_content":"> 私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。\n此次来分享下 Meizhi Android 源码的分析。\n\n<!-- more -->\n\n## 零、背景\n比起阅读枯燥的技术文档，独自苦苦摸索新技术的基本用法，还有一种更好更快速也更有效的提高自身技术的方法，那就是阅读学习优质的开源项目，通过仿写、练习最终达到理解，潜移默化提升自身编程技能。\n\n《带你学开源项目》系列将带领你深入阅读及分析当前流行的一些开源项目，并针对其中采用的新技术与精妙之处进行细致的阐述，以期让你快速掌握Android开发中的多种强大技能点。\n\n\n## 一、本期开源项目Meizhi Android\n本次的开源项目选择了[Meizhi Android](https://github.com/drakeet/Meizhi)，本文主要介绍该项目中采用的`RxJava`、`Retrofit`两种技术，这二者在Android开发者中非常流行，不仅能够`优美地处理异步回调`，而且能`提高代码的性能和稳定性`。而Meizhi Android中较好的覆盖了二者的多种应用场景，能够给多数开发者一个全面的学习。\n\n下面本人会`对原项目的代码进行详细的介绍`，同时为了读者看的清楚其中的逻辑关系，可能会做一定调整以帮助读者理解，比如把lambda表达式还原成普通java函数形式，以避免很多读者对lambda并不熟悉。\n\n## 二、原项目分析\n### 0. clone项目到本地\n第一步当然是把项目clone下来，编译，运行。有兴趣的同学可以执行这一步。\n### 1. 添加`Stetho`抓包工具\n首先，由于我们要分析retrofit，所以为了查看app的网络请求，有兴趣的同学可以手动在代码里添加[Stetho](http://facebook.github.io/stetho/)。`Stetho`是Facebook推出的一款黑科技，能够在chrome里轻松查看app所有的网络请求，比起iOS需要装个[Charles](https://www.charlesproxy.com/)查看http请求方便多咯。\n\n![Stetho使用场景](http://upload-images.jianshu.io/upload_images/281665-50854bb575db05f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 2. Retrofit结构\n从下图我们可以看到，首页里有很多card，每一个card里有两个元素：`妹纸图片`， `描述文字`，具体UI实现我们不在乎，只要明白一点，这两个元素数据是来自于两个不同的api。其中，`妹纸图片`来自于`http://gank.io/api/data/福利/10`;`描述文字`来自于`http://gank.io/api/data/休息视频/10`。\n\napp中为了请求网络数据，采用了[Retrofit](http://square.github.io/retrofit/)。具体关于retrofit如何配置请各位参考官网，这里只讲解如何使用`Retrofit`。\n\n该项目中主要创建了以下几个类来实现`Retrofit`结构，大家可以作为参考用于自己的项目中。\n\n ##### i. `GankApi`：这个类用来定义相关的`http`接口，这是符合retrofit规范的定义形式，每一个api返回的为`Observable<T>`格式结果，方便`RxJava`进行进一步处理。\n    @GET(\"/data/福利/{page}\") Observable<MeizhiList> getMeizhiList(@Path(\"page\") int page);\n    @GET(\"/data/休息视频/{page}\") Observable<GankVideoList> getGankVideoList(@Path(\"page\") int page);\n##### ii. `DrakeetRetrofit`：这个类用来对`Retrofit`进行相关配置并生成`GankApi`实例`gankApi`\n    OkHttpClient client = new OkHttpClient();\n    RestAdapter.Builder builder = new RestAdapter.Builder();\n    builder.setClient(new OkClient(client))\n          .setLogLevel(RestAdapter.LogLevel.FULL) \n          .setEndpoint(\"http://gank.io/api\")\n          .setConverter(new GsonConverter(gson));\n    RestAdapter gankRestAdapter = builder.build();\n    GankApi gankApi = gankRestAdapter.create(GankApi.class);\n\n    public GankApi getGankApi() {    \n        return gankApi;\n    }\n##### iii. `DrakeetFactory`： 这个类用来对外生成单例`GankApi`实例，为确保`GankApi`实例只生成一次。\n    public static GankApi getGankApi() {    \n        if (sGankApi == null) {\n            synchronized (monitor) {        \n               if (sGankApi == null) {            \n                  sGankApi = new DrakeetRetrofit().getGankApi();        \n               }       \n               return sGankApi;    \n            }\n        }\n    }\n\n所以，在实际应用场景中，比如我们想要发起一个http请求来获取`福利`数据，那么我们可以采用以下方式：\n\n    GankApi gankApi = DrakeetFactory.getGankApi();\n    Observable<MeizhiList> meizhiList = gankApi. getMeizhiList(10);\n\n\n![首页.png](http://upload-images.jianshu.io/upload_images/281665-2129d871aff9a884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 3. 首页的RxJava的实现\n既然我们已经把网络框架搭建好了，那么可以开始从服务器获取数据并显示了。我们首先看首页的数据。下面，我来对首页数据进行分析，一步步推出所需要的RxJava表达式。\n\n上面已经介绍过，每一个card里有两部分数据：`妹纸图片`(红色方框)和`描述文本`(绿色方框)。\n\n- `妹纸图片`数据来自于`\"/data/福利/{page}\"`这个api，该api会返回妹纸图片的url；\n- `描述文本`来自于`\"/data/休息视频/{page}\"`这个api，该api会返回休息视频及相关描述信息，card里会把描述信息显示出来；\n- 两个api均可以携带`page`字段，即一次请求可以获得多个数据。如我们在`\"/data/福利/{page}\"`里设置`page=10`，那么我们一次请求可以得到10条`福利`数据，即`10张妹纸图片url`；\n- 由于我们一次可以获得多张妹纸图片url和多个视频信息，那我们就需要把`二者进行合并`，即`单拎出来一张妹纸图片和一个视频信息组装成一个card`。然后按这种方式生成其他的card。\n\n小结一下，根据以上描述，假如我们把两个api的page都设置为`10`，那么两个请求同时发出去后，我们能得到`10张妹纸图片url`（如`http://img.com/1.png`, `http://img.com/2.png`, ...）和`10个视频信息`(如`舌尖上的中国`, `星际穿越`， ...)，然后我们将二者组装成`10个card所需要的数据`，放入每个card里显示即可。\n\n好，终于可以开始动手写代码了。上面的分析看似复杂，然后只要你学会了如何分析，很快就能写出对应的RxJava代码。下面我结合RxJava的`数据流思想`和`具体操作符`来介绍实现代码。\n\n##### i. 在网络请求数据之前，我们要创建几个数据entry对象来将获取回来的json字符串转化为object\n    public class Meizhi {\n        public String url;\n        public Date publishDate;\n    } //这是一个Meizhi对象，存储妹纸图片的url，图片描述信息和创建日期\n\n    public class Video {\n      public String desc;\n      public Date publishDate;\n    } //这是一个视频对象，存储视频描述信息和创建日期\n\n    public class MeizhiList {\n      public List<Meizhi> meizhiList;\n    } //由于我们一次请求能获取到10个(根据`page`设置)，所以我们用MeizhiList来存储结果\n\n    public class VideoList {\n      public List<Video> videoList;\n    } //原理同上，存储多个video对象\n\n    public class MeizhiWithVideo {\n      public String url;\n      public String desc;\n      public Date publishDate;\n    }//将video信息合并入meizhi对象中\n    \n    public class MeizhiWithVideoList {\n      public List<MeizhiWithVideoList> data;\n    }\n  \n##### ii. zip: 将两个retrofit接口请求后得到的两个数据源Observable<MeizhiList>  Observable<VideoList>进行合并\n我们需要把这两个数据源的数据拼接起来，所以我们可以考虑使用[zip操作符](http://reactivex.io/documentation/operators/zip.html)，该操作符可以将两个数据源发射出来的数据依次组装在一起。\n\n比如一个`Observable数据源`依次发射出`1, 3, 5, 7`, 另一个`Observable数据源`依次发射出`a, b, c, d`，那么`zip操作符`组装后会对外发射出`1a, 3b, 5c, 7d`这样的数据。\n\n而我们需要的正是这样。\n\n`Observable<MeizhiList>`一次对外发射一个`MeizhiList`对象，`Observable<VideoList>`一次对外发射一个`VideoList`对象，我们将二者合并成一个`MeizhiWithVideoList`对象。然后把`MeizhiWithVideoList`对象拿给UI去进行显示即可。\n\n所以，我们可以得到：\n\n    Observable<MeizhiList> meizhiListObservable = gankApi.getMeizhiList(10);\n    Observable<VideoList> videoListObservable = gankApi.getVideoList(10);\n    Observable<MeizhiWithVideoList> meizhiWithVideoListObservable = \n    Observable.zip(meizhiListObservable, videoListObservable, this::mergeVideoWithMeizhi)\n\n其中`mergeVideoWithMeizhi`是一个合并函数，把`video`信息与`meizhi`信息合并成新的`MeizhiWithVideo对象`。\n\n    public MeizhiWithVideoList\n    mergeVideoWithMeizhi(MeizhiList meizhiList, VideoList videoList) {//省略...}\n\n![RxJava - zip](http://upload-images.jianshu.io/upload_images/281665-91320f2cce108a8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n##### iii. 对MeizhiWithVideo对象进行排序。\n在上面，我们通过合并，得到了  `Observable<MeizhiWithVideoList>`数据源，这个数据源对外发射出一个`MeizhiWithVideoList`对象，这个对象里有10个`MeizhiWithVideo`数据，我们可以对这10个数据利用它们的发布日期进行排序。\n\n所以我们要实现以下几步：\n- 先把`Observable<MeizhiWithVideoList>`数据源转化为`Observable<List<MeizhiWithVideo>>`，从对外发一个`MeizhiWithVideoList`对象变成对外发射一个`List<MeizhiWithVideo>`对象；\n\n- 再把`Observale<List<MeizhiWithVideo>>`转化为`Observable<MeizhiWithVideo>`数据源，变成了对外发射出10个`MeizhiWithVideo`对象;\n\n- 对这10个`MeizhiWithVideo`对象基于`publishDate`进行排序；\n\n- 其中比较操作很耗cpu，所以我们放在`Schedulers.computation()`线程中做\n\n代码实现：\n    \n    meizhiWithVideoListObservable.map(new Func1<MeizhiWithVideoList, List<MeizhiWithVideo>>() {    \n          @Override    \n          public List<Meizhi> call(MeizhiList meizhiList) {                \n                return MeizhiWithVideoList.data;    \n          }\n    })\n    .flatMap(new Func1<List<MeizhiWithVideo>, Observable<MeizhiWithVideo>>() {    \n          @Override    \n          public Observable<MeizhiWithVideo> call(List<MeizhiWithVideo> meizhiWithVideos) {        \n                return Observable.from(meizhiWithVideos);    \n          }\n    })\n    .toSortedList(new Func2<MeizhiWithVideo, MeizhiWithVideo, Integer>() {    \n          @Override    \n          public Integer call(MeizhiWithVideo meizhiWithVideo1, MeizhiWithVideo meizhiWithVideo2) {        \n                return meizhiWithVideo2.publishedAt.compareTo(meizhiWithVideo1.publishedAt);    \n          }\n    })\n    .subscribeOn(Schedulers.computation());\n\n##### iv. 排序后，我们得到`Observable<List<MeizhiWithVideo>>`数据源，传给adapter去更新UI\n上面的`toSortedList(xxx)`方法会把`Observable<MeizhiWithVideo>`排序后重新组装成`Observable<List<MeizhiWithVideo>>`对象`sortedMVListObservable`，该对象对外发射一个`有序的List<MeizhiWithVideo>`。我们将该数据源提供给adapter供显示。\n\n代码如下：\n\n    sortedMVListObservable.observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new Subscriber<List<MeizhiWithVideo>>() {    \n        @Override    \n        public void onCompleted() {            \n            setRefresh(false); // stop refreshing data.                 \n        }    \n        @Override    \n        public void onError(Throwable e) {    \n\n        }\n        @Override    \n        public void onNext(List<MeizhiWithVideo> meizhiWithVideoList) {    \n            adapter.setData(meizhiWithVideoList);\n            adapter.notifyDataSetChanged(); // update UI\n        }\n    })\n\n### 4. 利用`Subscription`来管理异步处理与Activity生命周期\n对于异步我们知道一直存在一个问题，假设一个页面要同时发出很多个http请求，如http1, http2, http3...，然后这些请求会被放在一个队列里依次发出，而且每个请求发出后需要等待一段时间才能得到返回数据。\n\n那么问题就来了，假设在A页面发出了多个网络请求，在这些网络请求还在等待响应时用户就跳转到了B页面，在以前的情况下是，A页面的网络请求仍然进行直到所有数据返回，而且当数据返回时会尝试去调用A页面的UI进行修改，而此时已经进入了B页面，所以，这不仅造成了网络资源的浪费，也存在一定的风险。\n\n有了RxJava，我们可以把每一个网络请求转化为一个`Subscription`对象，这个`Subscription`对象可以被手动`unsubscribe`，即停止订阅所请求的数据源，这样就可以暂定数据请求，而且即使数据返回回来，由于我已经取消订阅了，所以不会再接收到这些数据了。\n\n代码实现：\n在`BaseActivity`中，创建一个`CompositeSubscription`对象来进行管理\n\n    `BaseActivity`\n    private CompositeSubscription mCompositeSubscription;\n    protected void addSubscription(Subscription s) {   \n       if (this.mCompositeSubscription == null) {                \n            this.mCompositeSubscription = new CompositeSubscription();    \n        }    \n        this.mCompositeSubscription.add(s);\n    }\n\n    @Override \n    protected void onDestroy() {    \n          super.onDestroy();    \n          if (this.mCompositeSubscription != null) {                \n                this.mCompositeSubscription.unsubscribe();    \n          }\n    }\n\n在实际的Activity中的网络请求:\n\n    public class MyActivity extends BaseActivity {\n      \n        private void loadData() {\n            Subscription s = gankApi.getMeizhiList(10)                           \n                                         .subscribeOn(Schedulers.io())\n                                         .observeOn(AndroidSchedulers.mainThread())\n                                         .subscribe(...);\n            addSubscription(s);\n        }\n    }\n\n## 三、改进及总结\n本文通过对开源项目[Meizhi Android](https://github.com/drakeet/Meizhi)进行分析，了解了`Retrofit`，`RxJava`的实际应用场景，也对于二者有了更加深入的认识。\n\n不过本人认为该项目还有一些可以改善的地方，比如`Retrofit`中利用`DrakeetFactory`工厂来生成`GankApi`的单例，但是`new DrakeetRetrofit().getGankApi();`也是一个可以生成`GankApi`的方法，而且是`public`的，那么如果新的开发者忘记调用`DrakeetFactory`来生成`GankApi`的实例，而是采用后者，那么工厂模式就达不到预期的目的了。我认为可以把`new DrakeetRetrofit().getGankApi();`这个操作内容放在`DrakeetFactory`工厂内部，并且设置为`private`属性，这样的话如果想要获得`GankApi`实例，就必须依靠`DrakeetFactory`来生成，从而真正保证了`单例`的优势。\n\n最后，如果读者有意见欢迎评论，本人后续还会挑选优质的开源项目，分析其精髓，供读者学习领悟。\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n","source":"_posts/带你学开源项目：Meizhi-Android之RxJava-Retrofit最佳实践.md","raw":"title: '带你学开源项目：Meizhi Android之RxJava & Retrofit最佳实践'\ndate: 2016-04-13 00:17:28\ncategories:\n  - Android\n  - 带你学开源项目\ntags:\n\t- Android\n  - 带你学开源项目\ncommentIssueId: 16  \n---\n> 私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。\n此次来分享下 Meizhi Android 源码的分析。\n\n<!-- more -->\n\n## 零、背景\n比起阅读枯燥的技术文档，独自苦苦摸索新技术的基本用法，还有一种更好更快速也更有效的提高自身技术的方法，那就是阅读学习优质的开源项目，通过仿写、练习最终达到理解，潜移默化提升自身编程技能。\n\n《带你学开源项目》系列将带领你深入阅读及分析当前流行的一些开源项目，并针对其中采用的新技术与精妙之处进行细致的阐述，以期让你快速掌握Android开发中的多种强大技能点。\n\n\n## 一、本期开源项目Meizhi Android\n本次的开源项目选择了[Meizhi Android](https://github.com/drakeet/Meizhi)，本文主要介绍该项目中采用的`RxJava`、`Retrofit`两种技术，这二者在Android开发者中非常流行，不仅能够`优美地处理异步回调`，而且能`提高代码的性能和稳定性`。而Meizhi Android中较好的覆盖了二者的多种应用场景，能够给多数开发者一个全面的学习。\n\n下面本人会`对原项目的代码进行详细的介绍`，同时为了读者看的清楚其中的逻辑关系，可能会做一定调整以帮助读者理解，比如把lambda表达式还原成普通java函数形式，以避免很多读者对lambda并不熟悉。\n\n## 二、原项目分析\n### 0. clone项目到本地\n第一步当然是把项目clone下来，编译，运行。有兴趣的同学可以执行这一步。\n### 1. 添加`Stetho`抓包工具\n首先，由于我们要分析retrofit，所以为了查看app的网络请求，有兴趣的同学可以手动在代码里添加[Stetho](http://facebook.github.io/stetho/)。`Stetho`是Facebook推出的一款黑科技，能够在chrome里轻松查看app所有的网络请求，比起iOS需要装个[Charles](https://www.charlesproxy.com/)查看http请求方便多咯。\n\n![Stetho使用场景](http://upload-images.jianshu.io/upload_images/281665-50854bb575db05f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 2. Retrofit结构\n从下图我们可以看到，首页里有很多card，每一个card里有两个元素：`妹纸图片`， `描述文字`，具体UI实现我们不在乎，只要明白一点，这两个元素数据是来自于两个不同的api。其中，`妹纸图片`来自于`http://gank.io/api/data/福利/10`;`描述文字`来自于`http://gank.io/api/data/休息视频/10`。\n\napp中为了请求网络数据，采用了[Retrofit](http://square.github.io/retrofit/)。具体关于retrofit如何配置请各位参考官网，这里只讲解如何使用`Retrofit`。\n\n该项目中主要创建了以下几个类来实现`Retrofit`结构，大家可以作为参考用于自己的项目中。\n\n ##### i. `GankApi`：这个类用来定义相关的`http`接口，这是符合retrofit规范的定义形式，每一个api返回的为`Observable<T>`格式结果，方便`RxJava`进行进一步处理。\n    @GET(\"/data/福利/{page}\") Observable<MeizhiList> getMeizhiList(@Path(\"page\") int page);\n    @GET(\"/data/休息视频/{page}\") Observable<GankVideoList> getGankVideoList(@Path(\"page\") int page);\n##### ii. `DrakeetRetrofit`：这个类用来对`Retrofit`进行相关配置并生成`GankApi`实例`gankApi`\n    OkHttpClient client = new OkHttpClient();\n    RestAdapter.Builder builder = new RestAdapter.Builder();\n    builder.setClient(new OkClient(client))\n          .setLogLevel(RestAdapter.LogLevel.FULL) \n          .setEndpoint(\"http://gank.io/api\")\n          .setConverter(new GsonConverter(gson));\n    RestAdapter gankRestAdapter = builder.build();\n    GankApi gankApi = gankRestAdapter.create(GankApi.class);\n\n    public GankApi getGankApi() {    \n        return gankApi;\n    }\n##### iii. `DrakeetFactory`： 这个类用来对外生成单例`GankApi`实例，为确保`GankApi`实例只生成一次。\n    public static GankApi getGankApi() {    \n        if (sGankApi == null) {\n            synchronized (monitor) {        \n               if (sGankApi == null) {            \n                  sGankApi = new DrakeetRetrofit().getGankApi();        \n               }       \n               return sGankApi;    \n            }\n        }\n    }\n\n所以，在实际应用场景中，比如我们想要发起一个http请求来获取`福利`数据，那么我们可以采用以下方式：\n\n    GankApi gankApi = DrakeetFactory.getGankApi();\n    Observable<MeizhiList> meizhiList = gankApi. getMeizhiList(10);\n\n\n![首页.png](http://upload-images.jianshu.io/upload_images/281665-2129d871aff9a884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 3. 首页的RxJava的实现\n既然我们已经把网络框架搭建好了，那么可以开始从服务器获取数据并显示了。我们首先看首页的数据。下面，我来对首页数据进行分析，一步步推出所需要的RxJava表达式。\n\n上面已经介绍过，每一个card里有两部分数据：`妹纸图片`(红色方框)和`描述文本`(绿色方框)。\n\n- `妹纸图片`数据来自于`\"/data/福利/{page}\"`这个api，该api会返回妹纸图片的url；\n- `描述文本`来自于`\"/data/休息视频/{page}\"`这个api，该api会返回休息视频及相关描述信息，card里会把描述信息显示出来；\n- 两个api均可以携带`page`字段，即一次请求可以获得多个数据。如我们在`\"/data/福利/{page}\"`里设置`page=10`，那么我们一次请求可以得到10条`福利`数据，即`10张妹纸图片url`；\n- 由于我们一次可以获得多张妹纸图片url和多个视频信息，那我们就需要把`二者进行合并`，即`单拎出来一张妹纸图片和一个视频信息组装成一个card`。然后按这种方式生成其他的card。\n\n小结一下，根据以上描述，假如我们把两个api的page都设置为`10`，那么两个请求同时发出去后，我们能得到`10张妹纸图片url`（如`http://img.com/1.png`, `http://img.com/2.png`, ...）和`10个视频信息`(如`舌尖上的中国`, `星际穿越`， ...)，然后我们将二者组装成`10个card所需要的数据`，放入每个card里显示即可。\n\n好，终于可以开始动手写代码了。上面的分析看似复杂，然后只要你学会了如何分析，很快就能写出对应的RxJava代码。下面我结合RxJava的`数据流思想`和`具体操作符`来介绍实现代码。\n\n##### i. 在网络请求数据之前，我们要创建几个数据entry对象来将获取回来的json字符串转化为object\n    public class Meizhi {\n        public String url;\n        public Date publishDate;\n    } //这是一个Meizhi对象，存储妹纸图片的url，图片描述信息和创建日期\n\n    public class Video {\n      public String desc;\n      public Date publishDate;\n    } //这是一个视频对象，存储视频描述信息和创建日期\n\n    public class MeizhiList {\n      public List<Meizhi> meizhiList;\n    } //由于我们一次请求能获取到10个(根据`page`设置)，所以我们用MeizhiList来存储结果\n\n    public class VideoList {\n      public List<Video> videoList;\n    } //原理同上，存储多个video对象\n\n    public class MeizhiWithVideo {\n      public String url;\n      public String desc;\n      public Date publishDate;\n    }//将video信息合并入meizhi对象中\n    \n    public class MeizhiWithVideoList {\n      public List<MeizhiWithVideoList> data;\n    }\n  \n##### ii. zip: 将两个retrofit接口请求后得到的两个数据源Observable<MeizhiList>  Observable<VideoList>进行合并\n我们需要把这两个数据源的数据拼接起来，所以我们可以考虑使用[zip操作符](http://reactivex.io/documentation/operators/zip.html)，该操作符可以将两个数据源发射出来的数据依次组装在一起。\n\n比如一个`Observable数据源`依次发射出`1, 3, 5, 7`, 另一个`Observable数据源`依次发射出`a, b, c, d`，那么`zip操作符`组装后会对外发射出`1a, 3b, 5c, 7d`这样的数据。\n\n而我们需要的正是这样。\n\n`Observable<MeizhiList>`一次对外发射一个`MeizhiList`对象，`Observable<VideoList>`一次对外发射一个`VideoList`对象，我们将二者合并成一个`MeizhiWithVideoList`对象。然后把`MeizhiWithVideoList`对象拿给UI去进行显示即可。\n\n所以，我们可以得到：\n\n    Observable<MeizhiList> meizhiListObservable = gankApi.getMeizhiList(10);\n    Observable<VideoList> videoListObservable = gankApi.getVideoList(10);\n    Observable<MeizhiWithVideoList> meizhiWithVideoListObservable = \n    Observable.zip(meizhiListObservable, videoListObservable, this::mergeVideoWithMeizhi)\n\n其中`mergeVideoWithMeizhi`是一个合并函数，把`video`信息与`meizhi`信息合并成新的`MeizhiWithVideo对象`。\n\n    public MeizhiWithVideoList\n    mergeVideoWithMeizhi(MeizhiList meizhiList, VideoList videoList) {//省略...}\n\n![RxJava - zip](http://upload-images.jianshu.io/upload_images/281665-91320f2cce108a8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n##### iii. 对MeizhiWithVideo对象进行排序。\n在上面，我们通过合并，得到了  `Observable<MeizhiWithVideoList>`数据源，这个数据源对外发射出一个`MeizhiWithVideoList`对象，这个对象里有10个`MeizhiWithVideo`数据，我们可以对这10个数据利用它们的发布日期进行排序。\n\n所以我们要实现以下几步：\n- 先把`Observable<MeizhiWithVideoList>`数据源转化为`Observable<List<MeizhiWithVideo>>`，从对外发一个`MeizhiWithVideoList`对象变成对外发射一个`List<MeizhiWithVideo>`对象；\n\n- 再把`Observale<List<MeizhiWithVideo>>`转化为`Observable<MeizhiWithVideo>`数据源，变成了对外发射出10个`MeizhiWithVideo`对象;\n\n- 对这10个`MeizhiWithVideo`对象基于`publishDate`进行排序；\n\n- 其中比较操作很耗cpu，所以我们放在`Schedulers.computation()`线程中做\n\n代码实现：\n    \n    meizhiWithVideoListObservable.map(new Func1<MeizhiWithVideoList, List<MeizhiWithVideo>>() {    \n          @Override    \n          public List<Meizhi> call(MeizhiList meizhiList) {                \n                return MeizhiWithVideoList.data;    \n          }\n    })\n    .flatMap(new Func1<List<MeizhiWithVideo>, Observable<MeizhiWithVideo>>() {    \n          @Override    \n          public Observable<MeizhiWithVideo> call(List<MeizhiWithVideo> meizhiWithVideos) {        \n                return Observable.from(meizhiWithVideos);    \n          }\n    })\n    .toSortedList(new Func2<MeizhiWithVideo, MeizhiWithVideo, Integer>() {    \n          @Override    \n          public Integer call(MeizhiWithVideo meizhiWithVideo1, MeizhiWithVideo meizhiWithVideo2) {        \n                return meizhiWithVideo2.publishedAt.compareTo(meizhiWithVideo1.publishedAt);    \n          }\n    })\n    .subscribeOn(Schedulers.computation());\n\n##### iv. 排序后，我们得到`Observable<List<MeizhiWithVideo>>`数据源，传给adapter去更新UI\n上面的`toSortedList(xxx)`方法会把`Observable<MeizhiWithVideo>`排序后重新组装成`Observable<List<MeizhiWithVideo>>`对象`sortedMVListObservable`，该对象对外发射一个`有序的List<MeizhiWithVideo>`。我们将该数据源提供给adapter供显示。\n\n代码如下：\n\n    sortedMVListObservable.observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new Subscriber<List<MeizhiWithVideo>>() {    \n        @Override    \n        public void onCompleted() {            \n            setRefresh(false); // stop refreshing data.                 \n        }    \n        @Override    \n        public void onError(Throwable e) {    \n\n        }\n        @Override    \n        public void onNext(List<MeizhiWithVideo> meizhiWithVideoList) {    \n            adapter.setData(meizhiWithVideoList);\n            adapter.notifyDataSetChanged(); // update UI\n        }\n    })\n\n### 4. 利用`Subscription`来管理异步处理与Activity生命周期\n对于异步我们知道一直存在一个问题，假设一个页面要同时发出很多个http请求，如http1, http2, http3...，然后这些请求会被放在一个队列里依次发出，而且每个请求发出后需要等待一段时间才能得到返回数据。\n\n那么问题就来了，假设在A页面发出了多个网络请求，在这些网络请求还在等待响应时用户就跳转到了B页面，在以前的情况下是，A页面的网络请求仍然进行直到所有数据返回，而且当数据返回时会尝试去调用A页面的UI进行修改，而此时已经进入了B页面，所以，这不仅造成了网络资源的浪费，也存在一定的风险。\n\n有了RxJava，我们可以把每一个网络请求转化为一个`Subscription`对象，这个`Subscription`对象可以被手动`unsubscribe`，即停止订阅所请求的数据源，这样就可以暂定数据请求，而且即使数据返回回来，由于我已经取消订阅了，所以不会再接收到这些数据了。\n\n代码实现：\n在`BaseActivity`中，创建一个`CompositeSubscription`对象来进行管理\n\n    `BaseActivity`\n    private CompositeSubscription mCompositeSubscription;\n    protected void addSubscription(Subscription s) {   \n       if (this.mCompositeSubscription == null) {                \n            this.mCompositeSubscription = new CompositeSubscription();    \n        }    \n        this.mCompositeSubscription.add(s);\n    }\n\n    @Override \n    protected void onDestroy() {    \n          super.onDestroy();    \n          if (this.mCompositeSubscription != null) {                \n                this.mCompositeSubscription.unsubscribe();    \n          }\n    }\n\n在实际的Activity中的网络请求:\n\n    public class MyActivity extends BaseActivity {\n      \n        private void loadData() {\n            Subscription s = gankApi.getMeizhiList(10)                           \n                                         .subscribeOn(Schedulers.io())\n                                         .observeOn(AndroidSchedulers.mainThread())\n                                         .subscribe(...);\n            addSubscription(s);\n        }\n    }\n\n## 三、改进及总结\n本文通过对开源项目[Meizhi Android](https://github.com/drakeet/Meizhi)进行分析，了解了`Retrofit`，`RxJava`的实际应用场景，也对于二者有了更加深入的认识。\n\n不过本人认为该项目还有一些可以改善的地方，比如`Retrofit`中利用`DrakeetFactory`工厂来生成`GankApi`的单例，但是`new DrakeetRetrofit().getGankApi();`也是一个可以生成`GankApi`的方法，而且是`public`的，那么如果新的开发者忘记调用`DrakeetFactory`来生成`GankApi`的实例，而是采用后者，那么工厂模式就达不到预期的目的了。我认为可以把`new DrakeetRetrofit().getGankApi();`这个操作内容放在`DrakeetFactory`工厂内部，并且设置为`private`属性，这样的话如果想要获得`GankApi`实例，就必须依靠`DrakeetFactory`来生成，从而真正保证了`单例`的优势。\n\n最后，如果读者有意见欢迎评论，本人后续还会挑选优质的开源项目，分析其精髓，供读者学习领悟。\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n","slug":"带你学开源项目：Meizhi-Android之RxJava-Retrofit最佳实践","published":1,"updated":"2017-06-23T04:09:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm1j001wmoyx87jlpunn","sticky":0},{"title":"带你学开源项目：LeakCanary- 如何检测 Activity 是否泄漏","date":"2017-05-14T11:29:33.000Z","commentIssueId":3,"_content":">OOM 是 Android 开发中常见的问题，而内存泄漏往往是罪魁祸首。\n\n>为了简单方便的检测内存泄漏，Square 开源了 [`LeakCanary`](https://github.com/square/leakcanary)，它可以实时监测 Activity 是否发生了泄漏，一旦发现就会自动弹出提示及相关的泄漏信息供分析。\n\n>本文的目的是试图通过分析 `LeakCanary` 源码来探讨它的 Activity 泄漏检测机制。\n\n<!-- more -->\n\n## `LeakCanary` 使用方式\n为了将 `LeakCanary` 引入到我们的项目里，我们只需要做以下两步：\n```\ndependencies {\n debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5.1'\n releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.1'\n testCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.1'\n}\n\npublic class ExampleApplication extends Application {\n  @Override public void onCreate() {\n    super.onCreate();\n    if (LeakCanary.isInAnalyzerProcess(this)) {\n      // This process is dedicated to LeakCanary for heap analysis.\n      // You should not init your app in this process.\n      return;\n    }\n    LeakCanary.install(this);\n  }\n}\n```\n\n可以看出，最关键的就是 `LeakCanary.install(this);` 这么一句话，正式开启了 `LeakCanary` 的大门，未来它就会自动帮我们检测内存泄漏，并在发生泄漏是弹出通知信息。\n\n##  从 `LeakCanary.install(this);` 开始\n下面我们来看下它做了些什么？\n```\n  public static RefWatcher install(Application application) {\n    return install(application, DisplayLeakService.class,\n        AndroidExcludedRefs.createAppDefaults().build());\n  }\n\n  public static RefWatcher install(Application application,\n      Class<? extends AbstractAnalysisResultService> listenerServiceClass,\n      ExcludedRefs excludedRefs) {\n    if (isInAnalyzerProcess(application)) {\n      return RefWatcher.DISABLED;\n    }\n    enableDisplayLeakActivity(application);\n    HeapDump.Listener heapDumpListener =\n        new ServiceHeapDumpListener(application, listenerServiceClass);\n    RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);\n    ActivityRefWatcher.installOnIcsPlus(application, refWatcher);\n    return refWatcher;\n  }\n```\n\n首先，我们先看最重要的部分，就是：\n```\nRefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);\nActivityRefWatcher.installOnIcsPlus(application, refWatcher);\t\n```\n先生成了一个 `RefWatcher`，这个东西非常关键，从名字可以看出，它是用来 `watch Reference` 的，也就是用来一个监控引用的工具。然后再把 `refWatcher` 和我们自己提供的 `application` 传入到 `ActivityRefWatcher.installOnIcsPlus(application, refWatcher);` 这句里面，继续看。\n\n```\npublic static void installOnIcsPlus(Application application, RefWatcher refWatcher) {\n    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);\n    activityRefWatcher.watchActivities();\n}\n```\n\n创建了一个 `ActivityRefWatcher`，大家应该能感受到，这个东西就是用来监控我们的 `Activity` 泄漏状况的，它调用`watchActivities()` 方法，就可以开始进行监控了。下面就是它监控的核心原理：\n\n```\npublic void watchActivities() {\n  application.registerActivityLifecycleCallbacks(lifecycleCallbacks);\n}\n```\n\n它向 `application` 里注册了一个 `ActivitylifecycleCallbacks` 的回调函数，可以用来监听 `Application` 整个生命周期所有 `Activity` 的 lifecycle 事件。再看下这个 `lifecycleCallbacks` 是什么？\n```\n  private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =\n      new Application.ActivityLifecycleCallbacks() {\n        @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n        }\n\n        @Override public void onActivityStarted(Activity activity) {\n        }\n\n        @Override public void onActivityResumed(Activity activity) {\n        }\n\n        @Override public void onActivityPaused(Activity activity) {\n        }\n\n        @Override public void onActivityStopped(Activity activity) {\n        }\n\n        @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {\n        }\n\n        @Override public void onActivityDestroyed(Activity activity) {\n          ActivityRefWatcher.this.onActivityDestroyed(activity);\n        }\n      };\n```\n\n原来它只监听了所有 `Activity` 的 `onActivityDestroyed` 事件，当 `Activity` 被 `Destory` 时，调用 `ActivityRefWatcher.this.onActivityDestroyed(activity);` 函数。\n\n猜测下，正常情况下，当一个这个函数应该 `activity` 被 `Destory` 时，那这个 `activity` 对象应该变成 null 才是正确的。如果没有变成null，那么就意味着发生了内存泄漏。\n\n因此我们向，这个函数 `ActivityRefWatcher.this.onActivityDestroyed(activity);` 应该是用来监听 `activity` 对象是否变成了 null。继续看。\n\n```\n  void onActivityDestroyed(Activity activity) {\n    refWatcher.watch(activity);\n  }\n  RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);\n```\n\n可以看出，这个函数把目标 `activity` 对象传给了 `RefWatcher`，让它去监控这个 `activity` 是否被正常回收了，若未被回收，则意味着发生了内存泄漏。\n\n## RefWatcher 如何监控 activity 是否被正常回收呢？\n我们先来看看这个 `RefWatcher` 究竟是个什么东西？\n```\n  public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,\n      ExcludedRefs excludedRefs) {\n    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context, leakDirectoryProvider);\n    heapDumper.cleanup();\n\n    int watchDelayMillis = 5000;\n    AndroidWatchExecutor executor = new AndroidWatchExecutor(watchDelayMillis);\n\n    return new RefWatcher(executor, debuggerControl, GcTrigger.DEFAULT, heapDumper,\n        heapDumpListener, excludedRefs);\n  }\n```\n\n这里面涉及到两个新的对象：`AndroidHeapDumper` 和 `AndroidWatchExecutor`，前者用来 dump 堆内存状态的，后者则是用来 watch 一个引用的监听器。具体原理后面再看。总之，这里已经生成好了一个 `RefWatcher` 对象了。\n\n现在再看上面 `onActivityDestroyed(Activity activity)` 里调用的 `refWatcher.watch(activity);`，下面来看下这个最为核心的 `watch(activity)` 方法，了解它是如何监控 `activity` 是否被回收的。\n\n```\n  private final Set<String> retainedKeys;\n  public void watch(Object activity, String referenceName) {\n    String key = UUID.randomUUID().toString();\n    retainedKeys.add(key);\n\n    final KeyedWeakReference reference =\n        new KeyedWeakReference(activity, key, referenceName, queue);\n\n    watchExecutor.execute(new Runnable() {\n      @Override public void run() {\n        ensureGone(reference, watchStartNanoTime);\n      }\n    });\n  }\n\n  final class KeyedWeakReference extends WeakReference<Object> {\n    public final String key;\n    public final String name;\n  }\n```\n可以看到，它首先把我们传入的 `activity` 包装成了一个 `KeyedWeakReference`（可以暂时看成一个普通的 WeakReference），然后 `watchExecutor` 会去执行一个 Runnable，这个 Runnable 会调用 `ensureGone(reference, watchStartNanoTime)` 函数。\n\n看这个函数之前猜测下，我们知道 `watch` 函数本身就是用来监听 `activity` 是否被正常回收，这就涉及到两个问题：\n\n1. 何时去检查它是否回收？\n2. 如何有效地检查它真的被回收？\n\n所以我们觉得 `ensureGone` 函数本身要做的事正如它的名字，就是确保 `reference` 被回收掉了，否则就意味着内存泄漏。\n\n#### 核心函数：ensureGone(reference) 检测回收 \n下面来看这个函数实现：\n```\n  void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {\n    removeWeaklyReachableReferences();\n    if (gone(reference) || debuggerControl.isDebuggerAttached()) {\n      return;\n    }\n    gcTrigger.runGc();\n    removeWeaklyReachableReferences();\n    if (!gone(reference)) {\n      File heapDumpFile = heapDumper.dumpHeap();\n      heapdumpListener.analyze(\n          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,\n              gcDurationMs, heapDumpDurationMs));\n    }\n  }\n\n  private boolean gone(KeyedWeakReference reference) {\n    return !retainedKeys.contains(reference.key);\n  }\n\n  private void removeWeaklyReachableReferences() {\n    KeyedWeakReference ref;\n    while ((ref = (KeyedWeakReference) queue.poll()) != null) {\n      retainedKeys.remove(ref.key);\n    }\n  }\n```\n\n这里先来解释下 `WeakReference` 和 `ReferenceQueue` 的工作原理。\n\n1. 弱引用 WeakReference\n被强引用的对象就算发生 OOM 也永远不会被垃圾回收机回收；被弱引用的对象，只要被垃圾回收器发现就会立即被回收；被软引用的对象，具备内存敏感性，只有内存不足时才会被回收，常用来做内存敏感缓存器；虚引用则任意时刻都可能被回收，使用较少。\n2. 引用队列 ReferenceQueue\n我们常用一个 `WeakReference<Activity> reference = new WeakReference(activity);`，这里我们创建了一个 `reference` 来弱引用到某个 `activity`，当这个 `activity` 被垃圾回收器回收后，这个 `reference` 会被放入内部的 `ReferenceQueue` 中。也就是说，从队列 `ReferenceQueue` 取出来的所有 `reference`，它们指向的真实对象都已经成功被回收了。\n\n然后再回到上面的代码。\n\n在一个 activity 传给 RefWatcher 时会创建一个唯一的 key 对应这个 activity，该key存入一个集合 `retainedKeys` 中。也就是说，所有我们想要观测的 `activity` 对应的唯一 key 都会被放入 `retainedKeys` 集合中。\n\n基于我们对 `ReferenceQueue` 的了解，只要把队列中所有的 reference 取出来，并把对应 retainedKeys 里的key移除，剩下的 key 对应的对象都没有被回收。\n\n1. ensureGone 首先调用 `removeWeaklyReachableReferences` 把已被回收的对象的 key 从 retainedKeys 移除，剩下的 key 都是未被回收的对象；\n2. if (gone(reference)) 用来判断某个 reference 的key是否仍在 retainedKeys 里，若不在，表示已回收，否则继续；\n3. gcTrigger.runGc(); 手动出发 GC，立即把所有 WeakReference 引用的对象回收；\n4. removeWeaklyReachableReferences(); 再次清理 retainedKeys，如果该 reference 还在 retainedKeys里 (if (!gone(reference)))，表示泄漏；\n5. 利用 heapDumper 把内存情况 dump 成文件，并调用 heapdumpListener 进行内存分析，进一步确认是否发生内存泄漏。\n6. 如果确认发生内存泄漏，调用 `DisplayLeakService` 发送通知。\n\n至此，核心的内存泄漏检测机制便看完了。\n\n## 内存泄漏检测小结\n从上面我们大概了解了内存泄漏检测机制，大概是以下几个步骤：\n1. 利用 `application.registerActivityLifecycleCallbacks(lifecycleCallbacks)` 来监听整个生命周期内的 Activity `onDestoryed` 事件;\n2. 当某个 `Activity` 被 destory 后，将它传给 RefWatcher 去做观测，确保其后续会被正常回收；\n3. RefWatcher 首先把 `Activity` 使用 KeyedWeakReference 引用起来，并使用一个 ReferenceQueue 来记录该 KeyedWeakReference 指向的对象是否已被回收；\n4. `AndroidWatchExecutor` 会在 5s 后，开始检查这个弱引用内的 `Activity` 是否被正常回收。判断条件是：若 `Activity` 被正常回收，那么引用它的 KeyedWeakReference 会被自动放入 ReferenceQueue 中。\n5. 判断方式是：先看 `Activity` 对应的 `KeyedWeakReference` 是否已经放入 `ReferenceQueue` 中；如果没有，则手动GC：`gcTrigger.runGc();`；然后再一次判断 `ReferenceQueue` 是否已经含有对应的 `KeyedWeakReference`。若还未被回收，则认为可能发生内存泄漏。\n6. 利用 HeapAnalyzer 对 dump 的内存情况进行分析并进一步确认，若确定发生泄漏，则利用 `DisplayLeakService` 发送通知。\n\n## 探讨一些关于 `LeakCanary` 有趣的问题\n在学习了 `LeakCanary` 的源码之后，我想再提几个有趣的问题做些探讨。\n\n### `LeakCanary` 项目目录结构为什么这样分？\n下面是整个 `LeakCanary` 的项目结构：\n![](/img/leakcanary/project.png)\n\n对于开发者而言，只需要使用到 `LeakCanary.install(this);` 这一句即可。那整个项目为什么要分成这么多个 module 呢？\n\n实际上，这里面每一个 module 都有自己的角色。\n\n- `leakcanary-watcher`: 这是一个通用的内存检测器，对外提供一个 RefWatcher#watch(Object watchedReference)，可以看出，它不仅能够检测 `Activity`，还能监测任意常规的 Java Object 的泄漏情况。\n\n- `leakcanary-android`: 这个 module 是与 `Android` 世界的接入点，用来专门监测 `Activity` 的泄漏情况，内部使用了 application#registerActivityLifecycleCallbacks 方法来监听 onDestory 事件，然后利用 `leakcanary-watcher` 来进行弱引用＋手动 GC 机制进行监控。\n\n- `leakcanary-analyzer`: 这个 module 提供了 `HeapAnalyzer`，用来对 dump 出来的内存进行分析并返回内存分析结果 `AnalysisResult`，内部包含了泄漏发生的路径等信息供开发者寻找定位。\n\n- `leakcanary-android-no-op`: 这个 module 是专门给 release 的版本用的，内部只提供了两个完全空白的类 `LeakCanary` 和 `RefWatcher`，这两个类不会做任何内存泄漏相关的分析。为什么？因为 `LeakCanary` 本身会由于不断 gc 影响到 app 本身的运行，而且主要用于开发阶段的内存泄漏检测。因此对于 release 则可以 disable 所有泄漏分析。\n\n- `leakcanary-sample`: 这个很简单，就是提供了一个用法 sample。\n\n### 当 Activity 被 destory 后，LeakCanary 多久后会去进行检查其是否泄漏呢？\n在源码中可以看到，LeakCanary 并不会在 destory 后立即去检查，而是让一个 `AndroidWatchExecutor` 去进行检查。它会做什么呢？\n```\n  @Override public void execute(final Runnable command) {\n    if (isOnMainThread()) {\n      executeDelayedAfterIdleUnsafe(command);\n    } else {\n      mainHandler.post(new Runnable() {\n        @Override public void run() {\n          executeDelayedAfterIdleUnsafe(command);\n        }\n      });\n    }\n  }\n\n  void executeDelayedAfterIdleUnsafe(final Runnable runnable) {\n    // This needs to be called from the main thread.\n    Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {\n      @Override public boolean queueIdle() {\n        backgroundHandler.postDelayed(runnable, delayMillis);\n        return false;\n      }\n    });\n  }\n```\n\n可以看到，它首先会向主线程的 MessageQueue 添加一个 `IdleHandler`。\n\n什么是 `IdleHandler`？我们知道 Looper 会不断从 MessageQueue 里取出 Message 并执行。当没有新的 Message 执行时，Looper 进入 Idle 状态时，就会取出 `IdleHandler` 来执行。\n\n换句话说，`IdleHandler`就是`优先级别较低的 Message`，只有当 Looper 没有消息要处理时才得到处理。而且，内部的 `queueIdle()` 方法若返回 `true`，表示该任务一直存活，每次 Looper 进入 Idle 时就执行；反正，如果返回 `false`，则表示只会执行一次，执行完后丢弃。\n\n那么，这件优先级较低的任务是什么呢？`backgroundHandler.postDelayed(runnable, delayMillis);`，runnable 就是之前 `ensureGone()`。\n\n也就是说，当主线程空闲了，没事做了，开始向后台线程发送一个延时消息，告诉后台线程，5s(delayMillis)后开始检查 `Activity` 是否被回收了。\n\n所以，当 `Activity` 发生 `destory` 后，首先要等到主线程空闲，然后再延时 5s(delayMillis)，才开始执行泄漏检查。\n\n##### 知识点：\n1. 如何创建一个优先级低的主线程任务，它只会在主线程空闲时才执行，不会影响到app的性能？\n```\nLooper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {\n      @Override public boolean queueIdle() {\n        // do task\n        return false; // only once\n      }\n    });\n```\n2. 如何快速创建一个主／子线程handler？\n```\n//主线程handler\nmainHandler = new Handler(Looper.getMainLooper());\n\n//子线程handler\nHandlerThread handlerThread = new HandlerThread(“子线程任务”);\nhandlerThread.start();\nHandler backgroundHandler = new Handler(handlerThread.getLooper());\n```\n3. 如何快速判断当前是否运行在主线程？\n```\nLooper.getMainLooper().getThread() == Thread.currentThread();\n```\n\n### System.gc() 可以触发立即 gc 吗？如果不行那怎么才能触发即时 gc 呢？\n在 LeakCanary 里，需要立即触发 gc，并在之后立即判断弱引用是否被回收。这意味着该 gc 必须能够立即同步执行。\n\n常用的触发 gc 方法是 `System.gc()`，那它能达到我们的要求吗？\n\n我们来看下其实现方式：\n```\n    /**\n     * Indicates to the VM that it would be a good time to run the\n     * garbage collector. Note that this is a hint only. There is no guarantee\n     * that the garbage collector will actually be run.\n     */\n    public static void gc() {\n        boolean shouldRunGC;\n        synchronized(lock) {\n            shouldRunGC = justRanFinalization;\n            if (shouldRunGC) {\n                justRanFinalization = false;\n            } else {\n                runGC = true;\n            }\n        }\n        if (shouldRunGC) {\n            Runtime.getRuntime().gc();\n        }\n    }\n```\n\n注释里清楚说了，`System.gc()`只是建议垃圾回收器来执行回收，但是`不能保证真的去回收`。从代码也能看出，必须先判断 `shouldRunGC` 才能决定是否真的要 gc。\n\n##### 知识点：\n那要怎么实现 即时 GC 呢？\n\n`LeakCanary` 参考了一段 [AOSP 的代码](https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/java/lang/ref/FinalizationTester.java)\n```\n// System.gc() does not garbage collect every time. Runtime.gc() is\n// more likely to perfom a gc.\nRuntime.getRuntime().gc();\nenqueueReferences();\nSystem.runFinalization();\npublic static void enqueueReferences() {\n    /*\n     * Hack. We don't have a programmatic way to wait for the reference queue\n     * daemon to move references to the appropriate queues.\n     */\n    try {\n        Thread.sleep(100);\n    } catch (InterruptedException e) {\n        throw new AssertionError();\n    }\n}\n```\n\n### 可以怎样来改造 LeakCanary 呢？\n##### 忽略某些已知泄漏的类或Activity\nLeakCanary 提供了 ExcludedRefs 类，可以向里面添加某些主动忽略的类。比如已知 Android 源代码里有某些内存泄漏，不属于我们 App 的泄漏，那么就可以 exclude 掉。\n\n另外，如果不想监控某些特殊的 Activity，那么可以在 `onActivityDestroyed(Activity activity)` 里，过滤掉特殊的 Activity，只对其它 Activity 调用 `refWatcher.watch(activity)` 监控。\n\n##### 把内存泄漏数据上传至服务器\n在 LeakCanary 提供了 `AbstractAnalysisResultService`，它是一个 intentService，接收到的 intent 内包含了 `HeapDump` 数据和 `AnalysisResult` 结果，我们只要继承这个类，实现自己的 `listenerServiceClass`，就可以将堆数据和分析结果上传到我们自己的服务器上。\n\n## 小结\n本文通过源代码分析了 LeakCanary 的原理，并提出了一些有趣的问题，学习了一些实用的知识点。希望对读者有所启发，欢迎与我讨论。\n\n之后会继续挑选优质开源项目进行分析，欢迎提意见。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n","source":"_posts/带你学开源项目：LeakCanary-如何检测-Activity-发生泄漏.md","raw":"title: 带你学开源项目：LeakCanary-如何检测 Activity 是否泄漏\ndate: 2017-05-14 19:29:33\npermalink: dig_into_leakcanary\ncategories:\n  - Android\n  - 带你学开源项目\ntags:\n    - Android\n    - 带你学开源项目\n    - 内存泄漏\n    - 性能优化\ncommentIssueId: 3    \n---\n>OOM 是 Android 开发中常见的问题，而内存泄漏往往是罪魁祸首。\n\n>为了简单方便的检测内存泄漏，Square 开源了 [`LeakCanary`](https://github.com/square/leakcanary)，它可以实时监测 Activity 是否发生了泄漏，一旦发现就会自动弹出提示及相关的泄漏信息供分析。\n\n>本文的目的是试图通过分析 `LeakCanary` 源码来探讨它的 Activity 泄漏检测机制。\n\n<!-- more -->\n\n## `LeakCanary` 使用方式\n为了将 `LeakCanary` 引入到我们的项目里，我们只需要做以下两步：\n```\ndependencies {\n debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5.1'\n releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.1'\n testCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.1'\n}\n\npublic class ExampleApplication extends Application {\n  @Override public void onCreate() {\n    super.onCreate();\n    if (LeakCanary.isInAnalyzerProcess(this)) {\n      // This process is dedicated to LeakCanary for heap analysis.\n      // You should not init your app in this process.\n      return;\n    }\n    LeakCanary.install(this);\n  }\n}\n```\n\n可以看出，最关键的就是 `LeakCanary.install(this);` 这么一句话，正式开启了 `LeakCanary` 的大门，未来它就会自动帮我们检测内存泄漏，并在发生泄漏是弹出通知信息。\n\n##  从 `LeakCanary.install(this);` 开始\n下面我们来看下它做了些什么？\n```\n  public static RefWatcher install(Application application) {\n    return install(application, DisplayLeakService.class,\n        AndroidExcludedRefs.createAppDefaults().build());\n  }\n\n  public static RefWatcher install(Application application,\n      Class<? extends AbstractAnalysisResultService> listenerServiceClass,\n      ExcludedRefs excludedRefs) {\n    if (isInAnalyzerProcess(application)) {\n      return RefWatcher.DISABLED;\n    }\n    enableDisplayLeakActivity(application);\n    HeapDump.Listener heapDumpListener =\n        new ServiceHeapDumpListener(application, listenerServiceClass);\n    RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);\n    ActivityRefWatcher.installOnIcsPlus(application, refWatcher);\n    return refWatcher;\n  }\n```\n\n首先，我们先看最重要的部分，就是：\n```\nRefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);\nActivityRefWatcher.installOnIcsPlus(application, refWatcher);\t\n```\n先生成了一个 `RefWatcher`，这个东西非常关键，从名字可以看出，它是用来 `watch Reference` 的，也就是用来一个监控引用的工具。然后再把 `refWatcher` 和我们自己提供的 `application` 传入到 `ActivityRefWatcher.installOnIcsPlus(application, refWatcher);` 这句里面，继续看。\n\n```\npublic static void installOnIcsPlus(Application application, RefWatcher refWatcher) {\n    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);\n    activityRefWatcher.watchActivities();\n}\n```\n\n创建了一个 `ActivityRefWatcher`，大家应该能感受到，这个东西就是用来监控我们的 `Activity` 泄漏状况的，它调用`watchActivities()` 方法，就可以开始进行监控了。下面就是它监控的核心原理：\n\n```\npublic void watchActivities() {\n  application.registerActivityLifecycleCallbacks(lifecycleCallbacks);\n}\n```\n\n它向 `application` 里注册了一个 `ActivitylifecycleCallbacks` 的回调函数，可以用来监听 `Application` 整个生命周期所有 `Activity` 的 lifecycle 事件。再看下这个 `lifecycleCallbacks` 是什么？\n```\n  private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =\n      new Application.ActivityLifecycleCallbacks() {\n        @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n        }\n\n        @Override public void onActivityStarted(Activity activity) {\n        }\n\n        @Override public void onActivityResumed(Activity activity) {\n        }\n\n        @Override public void onActivityPaused(Activity activity) {\n        }\n\n        @Override public void onActivityStopped(Activity activity) {\n        }\n\n        @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) {\n        }\n\n        @Override public void onActivityDestroyed(Activity activity) {\n          ActivityRefWatcher.this.onActivityDestroyed(activity);\n        }\n      };\n```\n\n原来它只监听了所有 `Activity` 的 `onActivityDestroyed` 事件，当 `Activity` 被 `Destory` 时，调用 `ActivityRefWatcher.this.onActivityDestroyed(activity);` 函数。\n\n猜测下，正常情况下，当一个这个函数应该 `activity` 被 `Destory` 时，那这个 `activity` 对象应该变成 null 才是正确的。如果没有变成null，那么就意味着发生了内存泄漏。\n\n因此我们向，这个函数 `ActivityRefWatcher.this.onActivityDestroyed(activity);` 应该是用来监听 `activity` 对象是否变成了 null。继续看。\n\n```\n  void onActivityDestroyed(Activity activity) {\n    refWatcher.watch(activity);\n  }\n  RefWatcher refWatcher = androidWatcher(application, heapDumpListener, excludedRefs);\n```\n\n可以看出，这个函数把目标 `activity` 对象传给了 `RefWatcher`，让它去监控这个 `activity` 是否被正常回收了，若未被回收，则意味着发生了内存泄漏。\n\n## RefWatcher 如何监控 activity 是否被正常回收呢？\n我们先来看看这个 `RefWatcher` 究竟是个什么东西？\n```\n  public static RefWatcher androidWatcher(Context context, HeapDump.Listener heapDumpListener,\n      ExcludedRefs excludedRefs) {\n    AndroidHeapDumper heapDumper = new AndroidHeapDumper(context, leakDirectoryProvider);\n    heapDumper.cleanup();\n\n    int watchDelayMillis = 5000;\n    AndroidWatchExecutor executor = new AndroidWatchExecutor(watchDelayMillis);\n\n    return new RefWatcher(executor, debuggerControl, GcTrigger.DEFAULT, heapDumper,\n        heapDumpListener, excludedRefs);\n  }\n```\n\n这里面涉及到两个新的对象：`AndroidHeapDumper` 和 `AndroidWatchExecutor`，前者用来 dump 堆内存状态的，后者则是用来 watch 一个引用的监听器。具体原理后面再看。总之，这里已经生成好了一个 `RefWatcher` 对象了。\n\n现在再看上面 `onActivityDestroyed(Activity activity)` 里调用的 `refWatcher.watch(activity);`，下面来看下这个最为核心的 `watch(activity)` 方法，了解它是如何监控 `activity` 是否被回收的。\n\n```\n  private final Set<String> retainedKeys;\n  public void watch(Object activity, String referenceName) {\n    String key = UUID.randomUUID().toString();\n    retainedKeys.add(key);\n\n    final KeyedWeakReference reference =\n        new KeyedWeakReference(activity, key, referenceName, queue);\n\n    watchExecutor.execute(new Runnable() {\n      @Override public void run() {\n        ensureGone(reference, watchStartNanoTime);\n      }\n    });\n  }\n\n  final class KeyedWeakReference extends WeakReference<Object> {\n    public final String key;\n    public final String name;\n  }\n```\n可以看到，它首先把我们传入的 `activity` 包装成了一个 `KeyedWeakReference`（可以暂时看成一个普通的 WeakReference），然后 `watchExecutor` 会去执行一个 Runnable，这个 Runnable 会调用 `ensureGone(reference, watchStartNanoTime)` 函数。\n\n看这个函数之前猜测下，我们知道 `watch` 函数本身就是用来监听 `activity` 是否被正常回收，这就涉及到两个问题：\n\n1. 何时去检查它是否回收？\n2. 如何有效地检查它真的被回收？\n\n所以我们觉得 `ensureGone` 函数本身要做的事正如它的名字，就是确保 `reference` 被回收掉了，否则就意味着内存泄漏。\n\n#### 核心函数：ensureGone(reference) 检测回收 \n下面来看这个函数实现：\n```\n  void ensureGone(KeyedWeakReference reference, long watchStartNanoTime) {\n    removeWeaklyReachableReferences();\n    if (gone(reference) || debuggerControl.isDebuggerAttached()) {\n      return;\n    }\n    gcTrigger.runGc();\n    removeWeaklyReachableReferences();\n    if (!gone(reference)) {\n      File heapDumpFile = heapDumper.dumpHeap();\n      heapdumpListener.analyze(\n          new HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,\n              gcDurationMs, heapDumpDurationMs));\n    }\n  }\n\n  private boolean gone(KeyedWeakReference reference) {\n    return !retainedKeys.contains(reference.key);\n  }\n\n  private void removeWeaklyReachableReferences() {\n    KeyedWeakReference ref;\n    while ((ref = (KeyedWeakReference) queue.poll()) != null) {\n      retainedKeys.remove(ref.key);\n    }\n  }\n```\n\n这里先来解释下 `WeakReference` 和 `ReferenceQueue` 的工作原理。\n\n1. 弱引用 WeakReference\n被强引用的对象就算发生 OOM 也永远不会被垃圾回收机回收；被弱引用的对象，只要被垃圾回收器发现就会立即被回收；被软引用的对象，具备内存敏感性，只有内存不足时才会被回收，常用来做内存敏感缓存器；虚引用则任意时刻都可能被回收，使用较少。\n2. 引用队列 ReferenceQueue\n我们常用一个 `WeakReference<Activity> reference = new WeakReference(activity);`，这里我们创建了一个 `reference` 来弱引用到某个 `activity`，当这个 `activity` 被垃圾回收器回收后，这个 `reference` 会被放入内部的 `ReferenceQueue` 中。也就是说，从队列 `ReferenceQueue` 取出来的所有 `reference`，它们指向的真实对象都已经成功被回收了。\n\n然后再回到上面的代码。\n\n在一个 activity 传给 RefWatcher 时会创建一个唯一的 key 对应这个 activity，该key存入一个集合 `retainedKeys` 中。也就是说，所有我们想要观测的 `activity` 对应的唯一 key 都会被放入 `retainedKeys` 集合中。\n\n基于我们对 `ReferenceQueue` 的了解，只要把队列中所有的 reference 取出来，并把对应 retainedKeys 里的key移除，剩下的 key 对应的对象都没有被回收。\n\n1. ensureGone 首先调用 `removeWeaklyReachableReferences` 把已被回收的对象的 key 从 retainedKeys 移除，剩下的 key 都是未被回收的对象；\n2. if (gone(reference)) 用来判断某个 reference 的key是否仍在 retainedKeys 里，若不在，表示已回收，否则继续；\n3. gcTrigger.runGc(); 手动出发 GC，立即把所有 WeakReference 引用的对象回收；\n4. removeWeaklyReachableReferences(); 再次清理 retainedKeys，如果该 reference 还在 retainedKeys里 (if (!gone(reference)))，表示泄漏；\n5. 利用 heapDumper 把内存情况 dump 成文件，并调用 heapdumpListener 进行内存分析，进一步确认是否发生内存泄漏。\n6. 如果确认发生内存泄漏，调用 `DisplayLeakService` 发送通知。\n\n至此，核心的内存泄漏检测机制便看完了。\n\n## 内存泄漏检测小结\n从上面我们大概了解了内存泄漏检测机制，大概是以下几个步骤：\n1. 利用 `application.registerActivityLifecycleCallbacks(lifecycleCallbacks)` 来监听整个生命周期内的 Activity `onDestoryed` 事件;\n2. 当某个 `Activity` 被 destory 后，将它传给 RefWatcher 去做观测，确保其后续会被正常回收；\n3. RefWatcher 首先把 `Activity` 使用 KeyedWeakReference 引用起来，并使用一个 ReferenceQueue 来记录该 KeyedWeakReference 指向的对象是否已被回收；\n4. `AndroidWatchExecutor` 会在 5s 后，开始检查这个弱引用内的 `Activity` 是否被正常回收。判断条件是：若 `Activity` 被正常回收，那么引用它的 KeyedWeakReference 会被自动放入 ReferenceQueue 中。\n5. 判断方式是：先看 `Activity` 对应的 `KeyedWeakReference` 是否已经放入 `ReferenceQueue` 中；如果没有，则手动GC：`gcTrigger.runGc();`；然后再一次判断 `ReferenceQueue` 是否已经含有对应的 `KeyedWeakReference`。若还未被回收，则认为可能发生内存泄漏。\n6. 利用 HeapAnalyzer 对 dump 的内存情况进行分析并进一步确认，若确定发生泄漏，则利用 `DisplayLeakService` 发送通知。\n\n## 探讨一些关于 `LeakCanary` 有趣的问题\n在学习了 `LeakCanary` 的源码之后，我想再提几个有趣的问题做些探讨。\n\n### `LeakCanary` 项目目录结构为什么这样分？\n下面是整个 `LeakCanary` 的项目结构：\n![](/img/leakcanary/project.png)\n\n对于开发者而言，只需要使用到 `LeakCanary.install(this);` 这一句即可。那整个项目为什么要分成这么多个 module 呢？\n\n实际上，这里面每一个 module 都有自己的角色。\n\n- `leakcanary-watcher`: 这是一个通用的内存检测器，对外提供一个 RefWatcher#watch(Object watchedReference)，可以看出，它不仅能够检测 `Activity`，还能监测任意常规的 Java Object 的泄漏情况。\n\n- `leakcanary-android`: 这个 module 是与 `Android` 世界的接入点，用来专门监测 `Activity` 的泄漏情况，内部使用了 application#registerActivityLifecycleCallbacks 方法来监听 onDestory 事件，然后利用 `leakcanary-watcher` 来进行弱引用＋手动 GC 机制进行监控。\n\n- `leakcanary-analyzer`: 这个 module 提供了 `HeapAnalyzer`，用来对 dump 出来的内存进行分析并返回内存分析结果 `AnalysisResult`，内部包含了泄漏发生的路径等信息供开发者寻找定位。\n\n- `leakcanary-android-no-op`: 这个 module 是专门给 release 的版本用的，内部只提供了两个完全空白的类 `LeakCanary` 和 `RefWatcher`，这两个类不会做任何内存泄漏相关的分析。为什么？因为 `LeakCanary` 本身会由于不断 gc 影响到 app 本身的运行，而且主要用于开发阶段的内存泄漏检测。因此对于 release 则可以 disable 所有泄漏分析。\n\n- `leakcanary-sample`: 这个很简单，就是提供了一个用法 sample。\n\n### 当 Activity 被 destory 后，LeakCanary 多久后会去进行检查其是否泄漏呢？\n在源码中可以看到，LeakCanary 并不会在 destory 后立即去检查，而是让一个 `AndroidWatchExecutor` 去进行检查。它会做什么呢？\n```\n  @Override public void execute(final Runnable command) {\n    if (isOnMainThread()) {\n      executeDelayedAfterIdleUnsafe(command);\n    } else {\n      mainHandler.post(new Runnable() {\n        @Override public void run() {\n          executeDelayedAfterIdleUnsafe(command);\n        }\n      });\n    }\n  }\n\n  void executeDelayedAfterIdleUnsafe(final Runnable runnable) {\n    // This needs to be called from the main thread.\n    Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {\n      @Override public boolean queueIdle() {\n        backgroundHandler.postDelayed(runnable, delayMillis);\n        return false;\n      }\n    });\n  }\n```\n\n可以看到，它首先会向主线程的 MessageQueue 添加一个 `IdleHandler`。\n\n什么是 `IdleHandler`？我们知道 Looper 会不断从 MessageQueue 里取出 Message 并执行。当没有新的 Message 执行时，Looper 进入 Idle 状态时，就会取出 `IdleHandler` 来执行。\n\n换句话说，`IdleHandler`就是`优先级别较低的 Message`，只有当 Looper 没有消息要处理时才得到处理。而且，内部的 `queueIdle()` 方法若返回 `true`，表示该任务一直存活，每次 Looper 进入 Idle 时就执行；反正，如果返回 `false`，则表示只会执行一次，执行完后丢弃。\n\n那么，这件优先级较低的任务是什么呢？`backgroundHandler.postDelayed(runnable, delayMillis);`，runnable 就是之前 `ensureGone()`。\n\n也就是说，当主线程空闲了，没事做了，开始向后台线程发送一个延时消息，告诉后台线程，5s(delayMillis)后开始检查 `Activity` 是否被回收了。\n\n所以，当 `Activity` 发生 `destory` 后，首先要等到主线程空闲，然后再延时 5s(delayMillis)，才开始执行泄漏检查。\n\n##### 知识点：\n1. 如何创建一个优先级低的主线程任务，它只会在主线程空闲时才执行，不会影响到app的性能？\n```\nLooper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {\n      @Override public boolean queueIdle() {\n        // do task\n        return false; // only once\n      }\n    });\n```\n2. 如何快速创建一个主／子线程handler？\n```\n//主线程handler\nmainHandler = new Handler(Looper.getMainLooper());\n\n//子线程handler\nHandlerThread handlerThread = new HandlerThread(“子线程任务”);\nhandlerThread.start();\nHandler backgroundHandler = new Handler(handlerThread.getLooper());\n```\n3. 如何快速判断当前是否运行在主线程？\n```\nLooper.getMainLooper().getThread() == Thread.currentThread();\n```\n\n### System.gc() 可以触发立即 gc 吗？如果不行那怎么才能触发即时 gc 呢？\n在 LeakCanary 里，需要立即触发 gc，并在之后立即判断弱引用是否被回收。这意味着该 gc 必须能够立即同步执行。\n\n常用的触发 gc 方法是 `System.gc()`，那它能达到我们的要求吗？\n\n我们来看下其实现方式：\n```\n    /**\n     * Indicates to the VM that it would be a good time to run the\n     * garbage collector. Note that this is a hint only. There is no guarantee\n     * that the garbage collector will actually be run.\n     */\n    public static void gc() {\n        boolean shouldRunGC;\n        synchronized(lock) {\n            shouldRunGC = justRanFinalization;\n            if (shouldRunGC) {\n                justRanFinalization = false;\n            } else {\n                runGC = true;\n            }\n        }\n        if (shouldRunGC) {\n            Runtime.getRuntime().gc();\n        }\n    }\n```\n\n注释里清楚说了，`System.gc()`只是建议垃圾回收器来执行回收，但是`不能保证真的去回收`。从代码也能看出，必须先判断 `shouldRunGC` 才能决定是否真的要 gc。\n\n##### 知识点：\n那要怎么实现 即时 GC 呢？\n\n`LeakCanary` 参考了一段 [AOSP 的代码](https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/java/lang/ref/FinalizationTester.java)\n```\n// System.gc() does not garbage collect every time. Runtime.gc() is\n// more likely to perfom a gc.\nRuntime.getRuntime().gc();\nenqueueReferences();\nSystem.runFinalization();\npublic static void enqueueReferences() {\n    /*\n     * Hack. We don't have a programmatic way to wait for the reference queue\n     * daemon to move references to the appropriate queues.\n     */\n    try {\n        Thread.sleep(100);\n    } catch (InterruptedException e) {\n        throw new AssertionError();\n    }\n}\n```\n\n### 可以怎样来改造 LeakCanary 呢？\n##### 忽略某些已知泄漏的类或Activity\nLeakCanary 提供了 ExcludedRefs 类，可以向里面添加某些主动忽略的类。比如已知 Android 源代码里有某些内存泄漏，不属于我们 App 的泄漏，那么就可以 exclude 掉。\n\n另外，如果不想监控某些特殊的 Activity，那么可以在 `onActivityDestroyed(Activity activity)` 里，过滤掉特殊的 Activity，只对其它 Activity 调用 `refWatcher.watch(activity)` 监控。\n\n##### 把内存泄漏数据上传至服务器\n在 LeakCanary 提供了 `AbstractAnalysisResultService`，它是一个 intentService，接收到的 intent 内包含了 `HeapDump` 数据和 `AnalysisResult` 结果，我们只要继承这个类，实现自己的 `listenerServiceClass`，就可以将堆数据和分析结果上传到我们自己的服务器上。\n\n## 小结\n本文通过源代码分析了 LeakCanary 的原理，并提出了一些有趣的问题，学习了一些实用的知识点。希望对读者有所启发，欢迎与我讨论。\n\n之后会继续挑选优质开源项目进行分析，欢迎提意见。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n","slug":"dig_into_leakcanary","published":1,"updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm1m0021moyxhj40xmps","sticky":0},{"title":"对未来个人技术博客的一些思考","date":"2017-03-29T10:16:25.000Z","commentIssueId":9,"_content":"\n> 2016年自己的博客产出并不多，主要原因是自己希望在博客中只分享技术干货，而非泛泛而谈，所以一直克制自己写文的想法。不过这里其实存在一个漏洞，那就是平常的开发过程中并没有那么多的难题要解决，也就导致工作中并不能提供那么多干货素材。因此，我才来重新考虑自己2017年的博客计划和方向。\n\n<!-- more -->\n\n## 回顾\n目前我在 Glow 工作了快两年时间，这两年我的技术成长主要在：\n\n1. Android 应用层开发，能够写出更加简洁、封装性更好的代码，对于常见的第三方框架 OkHttp, Dagger, RxJava 等一定的实践了解，并在这些框架的基础上进行二次封装到底层公共库里，在 Android 性能优化方面积累了一些经验，熟悉了不少 App 运维监控的工具如 Fabric；\n2. Python 服务端业务逻辑开发，学习了 Python 语言和 Flask 框架，对于后台的微服务化有一些了解，熟悉后台的架构设计、缓存设计，熟悉 Redis 这款优秀的数据库，业余时间自己开发的简诗服务端也算是自己的一个实践。\n\n## 博客规划\n### Java深入学习\n1. 读完 Effective Java，整理相关代码到 GitHub 上；\n2. 深入研究多线程编程，从基础概念着手，学会使用，再了解原理；\n3. 学习 JVM 工作原理，如何优化；\n4. 阿里发布的 Java 文档可以挑一些点分析下；\n\n### Android深入学习\n1. 写代码来实验进程间通信；\n2. 了解组件化；\n3. 了解multidex，打包，热修复等技术；\n\n### 效率工具\n分享一些能够较大提高工作效率的工具。\n\n### 阅读\n从别人的博客里找灵感 \nhttps://qifuguang.me/archives/page/8/\nhttps://blog.dreamtobe.cn/\nhttp://droidyue.com/blog/archives/index.html\nhttp://kaedea.com/archives/\nhttp://blog.zhaiyifan.cn/\nhttp://liwenkun.me/\nhttp://gavinliu.cn/archives/\n\n\n## 一些题目\n下面列出一些有意思的题目，之后要逐次完成。\n\n好了，准备开始我的2017填坑之旅了。\n\n## 已完成\n- [Java] [equals() 和 hashcode() 对比分析](http://wingjay.com/2017/03/29/Java%E7%9A%84equals%E4%B8%8Ehashcode%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/)\n- [Java] [Java 里如何实现线程间通信？](http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/)\n- [Java] [Java 技术之反射](http://wingjay.com/2017/04/26/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%8F%8D%E5%B0%84/)\n- [Java] [Java 技术之注解 Annotation](http://wingjay.com/2017/05/03/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%B3%A8%E8%A7%A3-Annotation/)\n- [Java] [Java 技术之类加载机制](http://wingjay.com/2017/05/08/java_classloader/)\n- [Java] [Java 技术之垃圾回收机制](http://wingjay.com/2017/05/24/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)\n- [Android] [带你学开源项目：LeakCanary- 如何检测 Activity 是否泄漏](http://wingjay.com/2017/05/14/dig\\_into\\_leakcanary/)\n- [Tool] [自己动手改造个人博客](http://wingjay.com/2017/06/08/rebuild-personal-blog/)\n\n\n## 待完成\n#### 近期\n- [Glow] React Native 数据通信方式 http://www.lcode.org/react-native-android/ 集成到已有app，back button如何handle，native navigation，pubsub模式，数据传递，reactcontext是什么，native module\n- [源码] Gson解析\n- [Java] 进程间通信\n- [效率] 多行编辑模式(sublime + Android studio), handy 的一些命令，terminal-notifier\n- [Java] Java 编译执行流程\n- [Android] 代码混淆机制\n- [Java] 多线程同步安全机制\n- [Android] Android提供的注解 http://droidyue.com/blog/2016/08/14/android-annnotation/\n- [Android] apk 打包流程\n- [Android] 多线程比较：AsyncTask, HandlerThread, ThreadPool, IntentService。（普通Thread 运行完就自动关闭了，而HandlerThread则会有一个looper在内部，调用handlerThread.start()后它就会一直在后台运行，需要它时用handler发一个message过去就行，随时都可以发message让它在后台干活。相比之下，AsyncTask也类似一次性的，后台执行完，回到UI线程运行下，就彻底结束了，不能一直在后台运行且随时与UI交互。）\n\n\n\n\n#### 后期\n- [Java] Java 如何实现字符串拼接 （http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/）\n- [Tool] 使用 iterm 和 tmux\n- [效率] 用Python脚本来格式化你的文章，英文自动前后空格\n- [Android] window Activity 的关系，启动一个 Activity 会发生什么，什么是 DecorView PhoneWindow\n- [Android] Binder 如何充当中间者来传输数据\n- [Android] 谈谈 Monkey test 有什么用\n- [Tool] slack 发微博，terminal-notifier 工具\n- [Android] 为什么需要 multi-dex，为什么是65535\n- [Android] 什么是 aar 文件，与 apk jar 的区别\n- [Android] Davlik Jvm 的区别，什么更适合移动端\n- [Android] adb shell 进入后的世界，如何查看 cache，lurcache\n- [java]java性能优化的数据结构 CopyOnWrite\n- [Java] final 关键字, Lock与synchrnoize 区别,  不可变类\n\n\n","source":"_posts/对未来个人技术博客的一些思考.md","raw":"title: 对未来个人技术博客的一些思考\ndate: 2017-03-29 18:16:25\ncategories:\n  - Blog\ntags: 随笔\ncommentIssueId: 9\n---\n\n> 2016年自己的博客产出并不多，主要原因是自己希望在博客中只分享技术干货，而非泛泛而谈，所以一直克制自己写文的想法。不过这里其实存在一个漏洞，那就是平常的开发过程中并没有那么多的难题要解决，也就导致工作中并不能提供那么多干货素材。因此，我才来重新考虑自己2017年的博客计划和方向。\n\n<!-- more -->\n\n## 回顾\n目前我在 Glow 工作了快两年时间，这两年我的技术成长主要在：\n\n1. Android 应用层开发，能够写出更加简洁、封装性更好的代码，对于常见的第三方框架 OkHttp, Dagger, RxJava 等一定的实践了解，并在这些框架的基础上进行二次封装到底层公共库里，在 Android 性能优化方面积累了一些经验，熟悉了不少 App 运维监控的工具如 Fabric；\n2. Python 服务端业务逻辑开发，学习了 Python 语言和 Flask 框架，对于后台的微服务化有一些了解，熟悉后台的架构设计、缓存设计，熟悉 Redis 这款优秀的数据库，业余时间自己开发的简诗服务端也算是自己的一个实践。\n\n## 博客规划\n### Java深入学习\n1. 读完 Effective Java，整理相关代码到 GitHub 上；\n2. 深入研究多线程编程，从基础概念着手，学会使用，再了解原理；\n3. 学习 JVM 工作原理，如何优化；\n4. 阿里发布的 Java 文档可以挑一些点分析下；\n\n### Android深入学习\n1. 写代码来实验进程间通信；\n2. 了解组件化；\n3. 了解multidex，打包，热修复等技术；\n\n### 效率工具\n分享一些能够较大提高工作效率的工具。\n\n### 阅读\n从别人的博客里找灵感 \nhttps://qifuguang.me/archives/page/8/\nhttps://blog.dreamtobe.cn/\nhttp://droidyue.com/blog/archives/index.html\nhttp://kaedea.com/archives/\nhttp://blog.zhaiyifan.cn/\nhttp://liwenkun.me/\nhttp://gavinliu.cn/archives/\n\n\n## 一些题目\n下面列出一些有意思的题目，之后要逐次完成。\n\n好了，准备开始我的2017填坑之旅了。\n\n## 已完成\n- [Java] [equals() 和 hashcode() 对比分析](http://wingjay.com/2017/03/29/Java%E7%9A%84equals%E4%B8%8Ehashcode%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90/)\n- [Java] [Java 里如何实现线程间通信？](http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/)\n- [Java] [Java 技术之反射](http://wingjay.com/2017/04/26/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%8F%8D%E5%B0%84/)\n- [Java] [Java 技术之注解 Annotation](http://wingjay.com/2017/05/03/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E6%B3%A8%E8%A7%A3-Annotation/)\n- [Java] [Java 技术之类加载机制](http://wingjay.com/2017/05/08/java_classloader/)\n- [Java] [Java 技术之垃圾回收机制](http://wingjay.com/2017/05/24/Java-%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)\n- [Android] [带你学开源项目：LeakCanary- 如何检测 Activity 是否泄漏](http://wingjay.com/2017/05/14/dig\\_into\\_leakcanary/)\n- [Tool] [自己动手改造个人博客](http://wingjay.com/2017/06/08/rebuild-personal-blog/)\n\n\n## 待完成\n#### 近期\n- [Glow] React Native 数据通信方式 http://www.lcode.org/react-native-android/ 集成到已有app，back button如何handle，native navigation，pubsub模式，数据传递，reactcontext是什么，native module\n- [源码] Gson解析\n- [Java] 进程间通信\n- [效率] 多行编辑模式(sublime + Android studio), handy 的一些命令，terminal-notifier\n- [Java] Java 编译执行流程\n- [Android] 代码混淆机制\n- [Java] 多线程同步安全机制\n- [Android] Android提供的注解 http://droidyue.com/blog/2016/08/14/android-annnotation/\n- [Android] apk 打包流程\n- [Android] 多线程比较：AsyncTask, HandlerThread, ThreadPool, IntentService。（普通Thread 运行完就自动关闭了，而HandlerThread则会有一个looper在内部，调用handlerThread.start()后它就会一直在后台运行，需要它时用handler发一个message过去就行，随时都可以发message让它在后台干活。相比之下，AsyncTask也类似一次性的，后台执行完，回到UI线程运行下，就彻底结束了，不能一直在后台运行且随时与UI交互。）\n\n\n\n\n#### 后期\n- [Java] Java 如何实现字符串拼接 （http://droidyue.com/blog/2014/08/30/java-details-string-concatenation/）\n- [Tool] 使用 iterm 和 tmux\n- [效率] 用Python脚本来格式化你的文章，英文自动前后空格\n- [Android] window Activity 的关系，启动一个 Activity 会发生什么，什么是 DecorView PhoneWindow\n- [Android] Binder 如何充当中间者来传输数据\n- [Android] 谈谈 Monkey test 有什么用\n- [Tool] slack 发微博，terminal-notifier 工具\n- [Android] 为什么需要 multi-dex，为什么是65535\n- [Android] 什么是 aar 文件，与 apk jar 的区别\n- [Android] Davlik Jvm 的区别，什么更适合移动端\n- [Android] adb shell 进入后的世界，如何查看 cache，lurcache\n- [java]java性能优化的数据结构 CopyOnWrite\n- [Java] final 关键字, Lock与synchrnoize 区别,  不可变类\n\n\n","slug":"对未来个人技术博客的一些思考","published":1,"updated":"2017-06-23T04:05:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm1p002amoyxwbmslbx5","sticky":0},{"title":"如何在一天之内搭建以你自己名字为域名又具备 cool 属性的个人博客","date":"2015-12-07T12:03:33.000Z","commentIssueId":20,"_content":">对程序员而言，最好的简历就是个人博客和GitHub。\n\n<!-- more -->\n\n\n![个人博客](/img/myblog.png)\n\n\n## 个人博客\n每个优秀的程序员都会有个人独占的一方网络空间，那里是他个人的舞台，听说过他的人会逐渐汇聚进来，认识他，熟悉他，鼓励他，赞扬他。而对他个人而言，他有了一个可以畅所欲言的小房间，他可以专研学术，聊聊情怀。同时和喜爱他的读者成为好友，共同成长。\n\n这难道不是一件很cool的事情吗？\n\n## 先看成果\n教方法前先来看看最终的效果吧。[http://wingjay.com](http://wingjay.com)是本人搭建的个人博客，主要有以下几点：\n\n    1. 个人域名: wingjay.com\n    2. 无需购置服务器，本站同时挂载在Github Pages 和 GitCafe Pages上，免服务器费的同时还能做负载均衡，想想还有点小激动\n    3. 在GitHub上同时管理你的博客和相应代码，再也不用担心博客遗失\n    4. SSL支持，即\"http://\" -> \"https://\"，更安全也更高大上\n\n## 再看兵器\n - 博客框架：[Hexo 3](https://hexo.io)，这是一款能快速、简洁且高效的博客框架，支持[Markdown编辑](https://help.github.com/articles/markdown-basics/)，自动渲染出漂亮的静态页面。\n - 前端主题：[Next](https://github.com/iissnan/hexo-theme-next)，效果参考[http://wingjay.com](http://wingjay.com)\n - 域名购买：[万网](http://wanwang.aliyun.com/)，你可以选购自己名字的域名，一年几十元左右，两杯咖啡的钱。\n - SSL：[CloudFlare](https://www.cloudflare.com)\n\n\n## 抄起家伙\n本文写作方式是`安装流程主线` + `优质参考文章`。由于网络上关于Hexo搭建博客的教程玲琅满目，若读者完全自己动手则要一篇篇找，浪费时间走弯路；相反，若作者悉数摘抄进来，反倒未必符合各人情况，且不利阅读。\n\n所以，`主线`讲解思路，`参考`深入阅读。\n\n下文以搭建 http://wingjay.com 个人博客为例。\n\n### GitHub Pages\n在不购买服务器的前提下，我们的网站需要挂在GitHub Pages上。GitHub Pages是面向用户、组织和项目开放的公共静态页面搭建托管服务，可用于搭建个人博客。\n\n0. 你需要拥有一个[GitHub账号](https://github.com)，去完成新手任务吧。\n1. 进入[GitHub Pages](https://pages.github.com/)，一步步做，完成后就能在浏览器打开[http://wingjay.github.io](http://wingjay.github.io)了。\n\n至此，我们已经利用GitHub Pages搭建好了个人博客雏形了。下面要做的，就是个性化了。\n\n### 安装Hexo博客框架\n经过上面步骤，我们已经拥有了一个初步域名：http://username.github.io 加一个免费网络空间了。好比房间有了，但还没有任何家具。所以下面我们需要把空白的博客丰富起来。\n\n放心，不需要你手写一大堆html、css文件，也不用找jQuery来实现酷炫的页面效果。[Hexo](https://hexo.io)是一款博客框架，它会帮我们搭建。\n\n#### 安装Hexo\n参考[中文文档](https://hexo.io/docs/)或[英文文档](https://hexo.io/zh-cn/docs/index.html)。完成该步后，你的电脑便拥有了Git、Node.js和Hexo。\n\n#### GitHub管理\n为了让自己未来的博客和代码处在git管理之下，我们要把刚刚在Github上博客项目拉到本地。如本人创建的[https://github.com/wingjay/wingjay.github.io](https://github.com/wingjay/wingjay.github.io)，在本地创建文件夹，名字任意，此处设为`myblog`，进入该文件夹，把项目代码clone下来。\n```\ngit clone https://github.com/wingjay/wingjay.github.io\n```\n好了，此时会自动在`myblog`目录下创建子文件夹`wingjay.github.io`,那里就是我们博客的代码，以后的操作都在git的管理之下了，此时默认的branch为`master`。\n\n#### 初始化Hexo\n请参考[文档](https://hexo.io/docs/setup.html)。init命令中的`<folder>`就是文件夹`wingjay.github.io`。初始化后，`wingjay.github.io`里面就已经有完整的Hexo框架了。\n\n#### 熟悉Hexo\n为了让读者快速了解`Hexo`，我作几个简单介绍吧。当然，更多的还是需要仔细阅读[文档](https://hexo.io/docs/writing.html)才能了解更详细。\n\n![hexo目录结构](/img/hexo-directory.png)\n\n - `_config.yml`是整体的配置文件，很多基础配置、插件配置等都需要在里面进行。要注意的是，该文件格式要求极为严格，缺少一个空格都会导致运行错误。小提示：不要用Tab缩进，用两个空格符。\n - `layout`，包括`draft(草稿)、page(页面)、post(文章)`。这个就是三种文件的基本格式，其中`post`是你发表的文章，会显示在你的网站里，一篇post会包括`title标题、date日期、tags标签`等信息；`draft`是草稿，只有你在本地能看到，必须要`publish`后才能成为`post`，draft和post差别是date，因为draft没有发表，所以不需要指定日期。`page`是一个页面，对应一个新的html页面，比如[博客内容展示页](http://wingjay.com/2015/12/06/%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%8D%9A%E5%AE%A2/)是一个页面，[留言本](http://wingjay.com/guestbook/)也是一个页面。\n - `public文件夹`，这个文件夹是最终会发布到网站上的真实内容。怎么理解呢？我们可以把`public`文件夹当作是真正的被用户看到的，而其他的`source、themes`等都是为`public`服务的。Hexo里有一个很重要的指令`hexo generate`，这个指令就是利用所有代码里的配置信息、source里写的文章、themes里的样式，共同生成最终的`静态html文件`，存入`public`文件夹内。在我们执行了发布指令`hexo deploy`后，就会把`public`的内容部署到`GitHub Pages`上。当用户在访问我们的博客时，他们会看到public里生成的html文件。这个概念非常重要，即`代码和真实静态页面是独立的`。\n - `generate和deploy`，`generate`会把我们的配置、文章和主题结合起来生成一堆酷炫的html静态文件放在public里面。但此时用户还看不到`本地public文件`里的页面，我们必须用后一个指令`deploy`才能把静态文件部署到`GitHub Pages`上。不过，在部署前，需要配置让它自动部署到我们前面创建的[Github项目](https://github.com/wingjay/wingjay.github.io)中。\n - `deploy`相关配置。为了能够让项目自动把public文件夹的内容部署到[GitHub项目](https://github.com/wingjay/wingjay.github.io)中，我们可以按[部署文档](https://hexo.io/docs/deployment.html)进行配置，其中选择的`branch`为`master`。此后，每次运行deploy后，项目就会自动把public文件夹内容全部覆盖到[当前的GitHub项目master分支上](https://github.com/wingjay/wingjay.github.io/tree/master)。\n - `代码`和`静态文件`分开管理。根据上面知道，每次部署后，public文件内容会`覆盖`掉项目整个master分支。这样可以实现网站`静态文件`的版本控制，但是，仔细对比这个master分支，我们会发现里面**只剩下静态文件**了，我们的代码比如source、themes统统没有了，这就导致无法对代码进行版本管理了。这意味着我换一台电脑，我就再也找不到`代码`了，只剩下一堆之前编译出来的静态文件。所以，为了对代码也进行版本控制，我们创建一个[新的分支：code](https://github.com/wingjay/wingjay.github.io/tree/code)，然后在这个分支里进行代码控制，master里则保存部署的新的静态文件。大家可以自行比对这两个branch的内容差异。\n\n#### 配置Hexo\n做一些基础配置即可，请参考[配置文档](https://hexo.io/docs/configuration.html)\n\n#### 小结\n到这里，我们已经完成了hexo的配置，我们可以在GitHub用不同branch分别管理代码和静态文件。执行deploy操作后，刷新你的网页 http://username.github.io 你就能看到默认的内容了。\n\n但此时还是默认主题，不够美观，所以下一步要配置Next主题。\n\n### 配置主题Next\nHexo主题非常多，可以参考[丰富多彩的Hexo主题](https://hexo.io/themes/)，本文选Next为主题，样式参考[我的博客](http://wingjay.com)。\n\n进入配置阶段，最好的文档还是[官方文档](http://theme-next.iissnan.com/)，简单得不能再细致了。下面只提几点注意：\n\n- 第三方评论系统。评论系统很重要，你可以与读者进行更多交流，配置也简单，建议采用[DISQUS](https://disqus.com/)，更国际化一点，[配置见此](http://theme-next.iissnan.com/third-party-services.html#DISUQS)。另外，前期建议开启`不登陆评论`，即在Disqus的`Comment Rule`里允许`Guest comment`。\n- 创建留言板。熟悉`page`的创建与使用，[参考这里](http://www.arao.me/2015/hexo-next-theme-optimize-base/#为你的hexo网站NexT主题增加留言页)\n- 给自己博客做`SEO`。有好的SEO便于搜索引擎索引你的网站，随着以后读者增多，他们可以更好搜索到你的网站。[具体方法见此](http://www.arao.me/2015/hexo-next-theme-optimize-seo/)\n\n<!-- ![Disqus评论系统](/img/Disqus评论系统.png) -->\n\n### 替换自己的域名\n好了，经过上面的步骤，博客已经拥有了一个全新的主题啦。\n\n下面，我们要对域名 http://wingjay.github.io 下手啦。\n\n#### 购买域名\n速速前往[万网](http://wanwang.aliyun.com/)，支付宝刷的一声，你就拥有了一个闪闪发光的个人域名啦\n\n#### 域名解析_1\n以购买的域名`wingjay.com`为例，我们希望在访问这个域名时能自动进入Github Pages，所以我们要在万网建立一个CNAME纪录来帮我们做一个域名跳转：`wingjay.com` -> `wingjay.github.io`，`www.wingjay.com` -> `wingjay.github.io`。添加方法[参考这里](http://www.sudu.cn/service/detail/1/0/0/3/10036.html)，添加后可以看到两条记录：![域名解析](/img/host.png)。然后万网会在世界各地的DNS服务器上添加这两条记录，当用户访问`wingjay.com`时会自动去访问`wingjay.github.io`。\n\n#### 域名解析_2\n但是，此时并不能成功访问，因为github pages是有限制的，它不允许任意域名都跳转过来，而是只限制一个域名，而且这个域名必须声明在CNAME文件中。\n\n所以，我们需要添加一个CNAME文件到项目的master中才行，[参考这里](https://help.github.com/articles/adding-a-cname-file-to-your-repository/)。读者可以参考本人的[CNAME文件内容](https://github.com/wingjay/wingjay.github.io/blob/master/CNAME)。\n\n不过，对于`Hexo 3`，**这里有一个坑要注意**：大家应该还记得上文说的，master分支里的内容都是自动生成的，而且会完全覆盖之前的内容。如果我们直接创建一个新文件CNAME，填好域名。但会发现在下一次部署后这个文件就消失了。不用惊讶，因为hexo并不会自动生成CNAME文件，所以在部署时被覆盖删除了。\n\n所以，我们就需要这个CNAME工具[hexo-generator-cname](https://github.com/leecrossley/hexo-generator-cname)，这时会自动在public里生成一个CNAME文件，把你的域名加进去再部署一下吧！\n\n### HTTP -> HTTPS\nHTTPS是安全版的HTTP协议，它在http协议与TCP之间加入SSL层，采用端口443，不仅会对传输数据加密，还会进行身份验证。当然个人博客并没有强制性要求采用该协议，这也只是本人的好奇而为。\n\n[Update] 目前，我的博客采用了[Kloudsec](https://kloudsec.com/github-pages)来做的https，大家可以点进去看。通过与服务商联系后，我了解到目前这项服务是免费的，不仅做https还能做负载均衡。\n\n\n### 疑难杂症\n1. 本地deploy成功，但是github上的master并没有收到该commit。\n目前不知道是什么原因，本人感觉是two-factor的开启，使得本地不具备权限直接push。比较无语。\n解决方法：\n在code分支上，创建一个.deploy的文件夹，在该文件夹内把master clone下来；\n当有新的改动后，generate后把public文件夹的内容拷入进上面clone的文件夹内；\n进入上面clone下来的文件夹，手动push到master上来更新。\n该思路就是自己维护一个master文件夹，手动把生成的public内容复制进去，再push上去。\n\n快捷命令：\nalias hexodeploy='cd ~/Documents/blog/wingjay.github.io;hexo generate;cp -R public/ .deploy/wingjay.github.io;cd .deploy/wingjay.github.io;git add .;git commit -m \"update\";    git push origin master; cd -; git add .; git commit -m \"source code\"; git push origin code'\n\n\n## 总结\n经过上面的步骤，我们已经能够通过访问自己的域名进入自己酷炫的博客了。本文的任务也就告一段落。\n\n除了上面的功能，本人还完成了`支持双域名同时登陆`，其中，支持双域名的解决思路是考虑到[Github Pages的CNAME纪录只允许添加一个域名](https://help.github.com/articles/adding-a-cname-file-to-your-repository/)，所以本人又在[Gitcafe](https://gitcafe.com)上部署了一套。不过考虑到这点大家不一定能用的上，就没有做介绍，有需要的话可以看下文的联系方式联系我。\n\n## 一天变cool系列文章\n[如何在一天之内完成一款具备cool属性的Android产品<简诗>](http://www.jianshu.com/p/cf496fc408b2)\n\n[如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客](http://www.jianshu.com/p/99665608d295)\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/如何在一天之内搭建以你自己名字为域名的很cool的个人博客.md","raw":"title: 如何在一天之内搭建以你自己名字为域名又具备cool属性的个人博客\ncategories:\n  - cool stuff\ncategories:\n  - 个人博客\n  - 一天变cool  \ntags:\n  - 一天变cool\n  - 个人博客\ndate: 2015-12-07 20:03:33\ncommentIssueId: 20\n---\n>对程序员而言，最好的简历就是个人博客和GitHub。\n\n<!-- more -->\n\n\n![个人博客](/img/myblog.png)\n\n\n## 个人博客\n每个优秀的程序员都会有个人独占的一方网络空间，那里是他个人的舞台，听说过他的人会逐渐汇聚进来，认识他，熟悉他，鼓励他，赞扬他。而对他个人而言，他有了一个可以畅所欲言的小房间，他可以专研学术，聊聊情怀。同时和喜爱他的读者成为好友，共同成长。\n\n这难道不是一件很cool的事情吗？\n\n## 先看成果\n教方法前先来看看最终的效果吧。[http://wingjay.com](http://wingjay.com)是本人搭建的个人博客，主要有以下几点：\n\n    1. 个人域名: wingjay.com\n    2. 无需购置服务器，本站同时挂载在Github Pages 和 GitCafe Pages上，免服务器费的同时还能做负载均衡，想想还有点小激动\n    3. 在GitHub上同时管理你的博客和相应代码，再也不用担心博客遗失\n    4. SSL支持，即\"http://\" -> \"https://\"，更安全也更高大上\n\n## 再看兵器\n - 博客框架：[Hexo 3](https://hexo.io)，这是一款能快速、简洁且高效的博客框架，支持[Markdown编辑](https://help.github.com/articles/markdown-basics/)，自动渲染出漂亮的静态页面。\n - 前端主题：[Next](https://github.com/iissnan/hexo-theme-next)，效果参考[http://wingjay.com](http://wingjay.com)\n - 域名购买：[万网](http://wanwang.aliyun.com/)，你可以选购自己名字的域名，一年几十元左右，两杯咖啡的钱。\n - SSL：[CloudFlare](https://www.cloudflare.com)\n\n\n## 抄起家伙\n本文写作方式是`安装流程主线` + `优质参考文章`。由于网络上关于Hexo搭建博客的教程玲琅满目，若读者完全自己动手则要一篇篇找，浪费时间走弯路；相反，若作者悉数摘抄进来，反倒未必符合各人情况，且不利阅读。\n\n所以，`主线`讲解思路，`参考`深入阅读。\n\n下文以搭建 http://wingjay.com 个人博客为例。\n\n### GitHub Pages\n在不购买服务器的前提下，我们的网站需要挂在GitHub Pages上。GitHub Pages是面向用户、组织和项目开放的公共静态页面搭建托管服务，可用于搭建个人博客。\n\n0. 你需要拥有一个[GitHub账号](https://github.com)，去完成新手任务吧。\n1. 进入[GitHub Pages](https://pages.github.com/)，一步步做，完成后就能在浏览器打开[http://wingjay.github.io](http://wingjay.github.io)了。\n\n至此，我们已经利用GitHub Pages搭建好了个人博客雏形了。下面要做的，就是个性化了。\n\n### 安装Hexo博客框架\n经过上面步骤，我们已经拥有了一个初步域名：http://username.github.io 加一个免费网络空间了。好比房间有了，但还没有任何家具。所以下面我们需要把空白的博客丰富起来。\n\n放心，不需要你手写一大堆html、css文件，也不用找jQuery来实现酷炫的页面效果。[Hexo](https://hexo.io)是一款博客框架，它会帮我们搭建。\n\n#### 安装Hexo\n参考[中文文档](https://hexo.io/docs/)或[英文文档](https://hexo.io/zh-cn/docs/index.html)。完成该步后，你的电脑便拥有了Git、Node.js和Hexo。\n\n#### GitHub管理\n为了让自己未来的博客和代码处在git管理之下，我们要把刚刚在Github上博客项目拉到本地。如本人创建的[https://github.com/wingjay/wingjay.github.io](https://github.com/wingjay/wingjay.github.io)，在本地创建文件夹，名字任意，此处设为`myblog`，进入该文件夹，把项目代码clone下来。\n```\ngit clone https://github.com/wingjay/wingjay.github.io\n```\n好了，此时会自动在`myblog`目录下创建子文件夹`wingjay.github.io`,那里就是我们博客的代码，以后的操作都在git的管理之下了，此时默认的branch为`master`。\n\n#### 初始化Hexo\n请参考[文档](https://hexo.io/docs/setup.html)。init命令中的`<folder>`就是文件夹`wingjay.github.io`。初始化后，`wingjay.github.io`里面就已经有完整的Hexo框架了。\n\n#### 熟悉Hexo\n为了让读者快速了解`Hexo`，我作几个简单介绍吧。当然，更多的还是需要仔细阅读[文档](https://hexo.io/docs/writing.html)才能了解更详细。\n\n![hexo目录结构](/img/hexo-directory.png)\n\n - `_config.yml`是整体的配置文件，很多基础配置、插件配置等都需要在里面进行。要注意的是，该文件格式要求极为严格，缺少一个空格都会导致运行错误。小提示：不要用Tab缩进，用两个空格符。\n - `layout`，包括`draft(草稿)、page(页面)、post(文章)`。这个就是三种文件的基本格式，其中`post`是你发表的文章，会显示在你的网站里，一篇post会包括`title标题、date日期、tags标签`等信息；`draft`是草稿，只有你在本地能看到，必须要`publish`后才能成为`post`，draft和post差别是date，因为draft没有发表，所以不需要指定日期。`page`是一个页面，对应一个新的html页面，比如[博客内容展示页](http://wingjay.com/2015/12/06/%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%8D%9A%E5%AE%A2/)是一个页面，[留言本](http://wingjay.com/guestbook/)也是一个页面。\n - `public文件夹`，这个文件夹是最终会发布到网站上的真实内容。怎么理解呢？我们可以把`public`文件夹当作是真正的被用户看到的，而其他的`source、themes`等都是为`public`服务的。Hexo里有一个很重要的指令`hexo generate`，这个指令就是利用所有代码里的配置信息、source里写的文章、themes里的样式，共同生成最终的`静态html文件`，存入`public`文件夹内。在我们执行了发布指令`hexo deploy`后，就会把`public`的内容部署到`GitHub Pages`上。当用户在访问我们的博客时，他们会看到public里生成的html文件。这个概念非常重要，即`代码和真实静态页面是独立的`。\n - `generate和deploy`，`generate`会把我们的配置、文章和主题结合起来生成一堆酷炫的html静态文件放在public里面。但此时用户还看不到`本地public文件`里的页面，我们必须用后一个指令`deploy`才能把静态文件部署到`GitHub Pages`上。不过，在部署前，需要配置让它自动部署到我们前面创建的[Github项目](https://github.com/wingjay/wingjay.github.io)中。\n - `deploy`相关配置。为了能够让项目自动把public文件夹的内容部署到[GitHub项目](https://github.com/wingjay/wingjay.github.io)中，我们可以按[部署文档](https://hexo.io/docs/deployment.html)进行配置，其中选择的`branch`为`master`。此后，每次运行deploy后，项目就会自动把public文件夹内容全部覆盖到[当前的GitHub项目master分支上](https://github.com/wingjay/wingjay.github.io/tree/master)。\n - `代码`和`静态文件`分开管理。根据上面知道，每次部署后，public文件内容会`覆盖`掉项目整个master分支。这样可以实现网站`静态文件`的版本控制，但是，仔细对比这个master分支，我们会发现里面**只剩下静态文件**了，我们的代码比如source、themes统统没有了，这就导致无法对代码进行版本管理了。这意味着我换一台电脑，我就再也找不到`代码`了，只剩下一堆之前编译出来的静态文件。所以，为了对代码也进行版本控制，我们创建一个[新的分支：code](https://github.com/wingjay/wingjay.github.io/tree/code)，然后在这个分支里进行代码控制，master里则保存部署的新的静态文件。大家可以自行比对这两个branch的内容差异。\n\n#### 配置Hexo\n做一些基础配置即可，请参考[配置文档](https://hexo.io/docs/configuration.html)\n\n#### 小结\n到这里，我们已经完成了hexo的配置，我们可以在GitHub用不同branch分别管理代码和静态文件。执行deploy操作后，刷新你的网页 http://username.github.io 你就能看到默认的内容了。\n\n但此时还是默认主题，不够美观，所以下一步要配置Next主题。\n\n### 配置主题Next\nHexo主题非常多，可以参考[丰富多彩的Hexo主题](https://hexo.io/themes/)，本文选Next为主题，样式参考[我的博客](http://wingjay.com)。\n\n进入配置阶段，最好的文档还是[官方文档](http://theme-next.iissnan.com/)，简单得不能再细致了。下面只提几点注意：\n\n- 第三方评论系统。评论系统很重要，你可以与读者进行更多交流，配置也简单，建议采用[DISQUS](https://disqus.com/)，更国际化一点，[配置见此](http://theme-next.iissnan.com/third-party-services.html#DISUQS)。另外，前期建议开启`不登陆评论`，即在Disqus的`Comment Rule`里允许`Guest comment`。\n- 创建留言板。熟悉`page`的创建与使用，[参考这里](http://www.arao.me/2015/hexo-next-theme-optimize-base/#为你的hexo网站NexT主题增加留言页)\n- 给自己博客做`SEO`。有好的SEO便于搜索引擎索引你的网站，随着以后读者增多，他们可以更好搜索到你的网站。[具体方法见此](http://www.arao.me/2015/hexo-next-theme-optimize-seo/)\n\n<!-- ![Disqus评论系统](/img/Disqus评论系统.png) -->\n\n### 替换自己的域名\n好了，经过上面的步骤，博客已经拥有了一个全新的主题啦。\n\n下面，我们要对域名 http://wingjay.github.io 下手啦。\n\n#### 购买域名\n速速前往[万网](http://wanwang.aliyun.com/)，支付宝刷的一声，你就拥有了一个闪闪发光的个人域名啦\n\n#### 域名解析_1\n以购买的域名`wingjay.com`为例，我们希望在访问这个域名时能自动进入Github Pages，所以我们要在万网建立一个CNAME纪录来帮我们做一个域名跳转：`wingjay.com` -> `wingjay.github.io`，`www.wingjay.com` -> `wingjay.github.io`。添加方法[参考这里](http://www.sudu.cn/service/detail/1/0/0/3/10036.html)，添加后可以看到两条记录：![域名解析](/img/host.png)。然后万网会在世界各地的DNS服务器上添加这两条记录，当用户访问`wingjay.com`时会自动去访问`wingjay.github.io`。\n\n#### 域名解析_2\n但是，此时并不能成功访问，因为github pages是有限制的，它不允许任意域名都跳转过来，而是只限制一个域名，而且这个域名必须声明在CNAME文件中。\n\n所以，我们需要添加一个CNAME文件到项目的master中才行，[参考这里](https://help.github.com/articles/adding-a-cname-file-to-your-repository/)。读者可以参考本人的[CNAME文件内容](https://github.com/wingjay/wingjay.github.io/blob/master/CNAME)。\n\n不过，对于`Hexo 3`，**这里有一个坑要注意**：大家应该还记得上文说的，master分支里的内容都是自动生成的，而且会完全覆盖之前的内容。如果我们直接创建一个新文件CNAME，填好域名。但会发现在下一次部署后这个文件就消失了。不用惊讶，因为hexo并不会自动生成CNAME文件，所以在部署时被覆盖删除了。\n\n所以，我们就需要这个CNAME工具[hexo-generator-cname](https://github.com/leecrossley/hexo-generator-cname)，这时会自动在public里生成一个CNAME文件，把你的域名加进去再部署一下吧！\n\n### HTTP -> HTTPS\nHTTPS是安全版的HTTP协议，它在http协议与TCP之间加入SSL层，采用端口443，不仅会对传输数据加密，还会进行身份验证。当然个人博客并没有强制性要求采用该协议，这也只是本人的好奇而为。\n\n[Update] 目前，我的博客采用了[Kloudsec](https://kloudsec.com/github-pages)来做的https，大家可以点进去看。通过与服务商联系后，我了解到目前这项服务是免费的，不仅做https还能做负载均衡。\n\n\n### 疑难杂症\n1. 本地deploy成功，但是github上的master并没有收到该commit。\n目前不知道是什么原因，本人感觉是two-factor的开启，使得本地不具备权限直接push。比较无语。\n解决方法：\n在code分支上，创建一个.deploy的文件夹，在该文件夹内把master clone下来；\n当有新的改动后，generate后把public文件夹的内容拷入进上面clone的文件夹内；\n进入上面clone下来的文件夹，手动push到master上来更新。\n该思路就是自己维护一个master文件夹，手动把生成的public内容复制进去，再push上去。\n\n快捷命令：\nalias hexodeploy='cd ~/Documents/blog/wingjay.github.io;hexo generate;cp -R public/ .deploy/wingjay.github.io;cd .deploy/wingjay.github.io;git add .;git commit -m \"update\";    git push origin master; cd -; git add .; git commit -m \"source code\"; git push origin code'\n\n\n## 总结\n经过上面的步骤，我们已经能够通过访问自己的域名进入自己酷炫的博客了。本文的任务也就告一段落。\n\n除了上面的功能，本人还完成了`支持双域名同时登陆`，其中，支持双域名的解决思路是考虑到[Github Pages的CNAME纪录只允许添加一个域名](https://help.github.com/articles/adding-a-cname-file-to-your-repository/)，所以本人又在[Gitcafe](https://gitcafe.com)上部署了一套。不过考虑到这点大家不一定能用的上，就没有做介绍，有需要的话可以看下文的联系方式联系我。\n\n## 一天变cool系列文章\n[如何在一天之内完成一款具备cool属性的Android产品<简诗>](http://www.jianshu.com/p/cf496fc408b2)\n\n[如何在一天之内搭建以你自己名字为域名且具备cool属性的个人博客](http://www.jianshu.com/p/99665608d295)\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"如何在一天之内搭建以你自己名字为域名的很cool的个人博客","published":1,"updated":"2017-06-23T04:12:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm1t002dmoyx9q4r3br6","sticky":0},{"title":"写给移动开发者的 React Native 指南","date":"2017-03-14T04:07:06.000Z","commentIssueId":10,"_content":"\n> React Native 所代表的跨平台、动态更新技术已经引起了全世界开发者关注，而且这种技术势必会是未来的需求和潮流。React Native 不一定会成功，但至少目前 React Native 已经是这一领域的领跑者。\n\n<!-- more -->\n\n\n### 前言\nReact Native 诞生于 2015 年，名副其实的富二代，主要使命是为父出征，与 Apple 和 Google 抗衡，为开发者带去一套跨平台、动态更新的 Javascript 框架，口号是：Learn once, write anywhere：Build mobile apps with React。在试图推翻 Android 和 iOS 压制的同时，还提携了一把自家兄弟：React。\n\n从诞生之日 React Native 就充满了期待和争议。期待是无数开发者希望不用忍受频繁发版的噩梦，也不用同时为两个平台开发业务逻辑几无差别的两个 App；争议是 React Native 真的能以一己之力救大众于水火吗？React Native 在跨平台时还能保持良好的用户体验吗？\n\n当然我们知道，这种问题向来都是仁者见仁，智者见智。比起一味的疑惑、争论，还不如来好好看看这货究竟是个啥？甚至自己动手来玩一把。\n\n本文主要针对两类读者：\n- 想要入门 RN 的人，在阅读官方文档前先对 RN 形成一个整体的印象\n- 对 RN 心存好奇，在犹豫是否要入坑的开发者，可以通过本文对 RN 更客观全面的认识\n\n\n### 目录\n- React Native 好在哪\n  - 跨平台＋动态更新\n  - 代码复用\n  - RN vs Weex\n  - RN vs Hybrid\n  - RN 劣势\n- React Native 运行机制\n- RN 开发环境搭建\n- 引入 React Native\n  - Build from Scratch\n  - 集成到已有项目\n- Javascript、React 及 ES6、JSX 语法\n- UI 层\n- 网络请求层\n- Debugging 调试\n  - In-App 报错\n  - Console.log\n  - 大杀器：Chrome 逐行调试\n- 从 JS 调用 Native 方法或显示自定义 Native View\n  - Native Modules：JS 里直接调用 Native(Java/Swift) 方法\n  - Native UI Component：JS 里直接调用自定义的 Native View\n- React Native 适合你吗？\n- 为什么要写这篇文章\n\n### React Native 好在哪\n下面我们来看下 Hybrid 及 React Native 等开发模式包含了哪些常规移动开发所不具备的优势。\n\n##### 1. 跨平台＋动态更新\n传统的客户端开发模式是怎样的呢？\n\nAndroid 与 iOS Team 分别编写客户端代码，打包，分发到 Play Store 和 Apple Store，通过更新 JSON 数据来更新页面。\n\n不过，当客户端发生严重问题而服务器上无法 quick fix 时，就不得不重新发版。\n\n对国外 Android 市场而言还好，因为能通过 Play Store 快速更新；国内 Android 市场则由于分发渠道太杂，很难及时把新版本立即推送给所有用户，当然这也是为何热修复技术在国内盛行而国外冷清的原因；而 Apple Store 则需要一定的审核时间，而且最近又在抓 iOS 热修复框架如 JsPatch、Rollout 等。\n\n相比而言，Hybrid 和 RN/Weex 模式除了能下发 Json 数据来刷新界面内容，更能直接下发业务逻辑代码，直接实现整体 App 的更新。而且，它们不用在乎 Android 和 iOS 两个平台，因为一份 JS 代码写好后，把 JS Bundle 放在服务器上，所有的客户端立即更新。\n\n##### 2. 代码复用\n一般而言，同一款产品的 Android 和 iOS 两端除 UI 有些许不同外，多数业务逻辑几乎完全一致，这便造成了人力的浪费。\n\n而最近 Instagram 的官博 [React Native at Instagram](https://engineering.instagram.com/react-native-at-instagram-dd828a9a90c7#.ugk9ncjyz) 一文中已经提到，利用 RN (React Native 缩写，下同) 开发的 feature 可以实现 `85% - 99%` 的代码复用率。这意味着我们可以用更少的人力成本来达到相同的效果。\n\n##### 3. RN  vs Weex \n实现上面的效果有两种开发框架：混合开发框架 Cordova 和基于 Javascript 的 React-Native、Weex 框架。\n\n下面我从自己的实践经验出发做些比较，也欢迎读者提出自己看法。\n\n最开始觉得 RN 的学习成本比较大，所以首先考虑了 [Weex 框架](https://github.com/alibaba/weex)，据说是阿里巴巴良心出品。不过在尝试后不得不选择了放弃，原因有这几点：\n- Bug 较多。我们最先测试了`最基本`的 ListView，在 iOS 运行良好，而同样的 Demo 代码到了 Android 这边的`下拉刷新`就出现了问题，这使得我们开始警惕；\n- 社区、文档弱，GitHub Issue 基本是中文。当然我毫无歧视中文之意。我认为，**一套项目开源是真正意义是希望借助开源社区的力量，一起来完善改进，因此要优先推崇英文，使项目国际化，得到全世界开发者的共同支持，这样才是可持续的模式。**而 Weex 的 [Issue](https://github.com/alibaba/weex/issues) 里放眼望去基本 90% 都是中文，无论提问者还是**项目维护者**。这一点直接把国外优秀的开发者拒之门外，也很难让我看到多么长远的未来。\n下面是摘取的 RN 里的一则中文 issue：\n\n![**Issue is for bug report, not for Q&A**](http://upload-images.jianshu.io/upload_images/281665-fdd239b44898ea4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- Contributor 差别。因为上面一点，[Weex 的 Contributor](https://github.com/apache/incubator-weex/graphs/contributors) 只有 91 个人，而 [React-Native 的 Contributor](https://github.com/facebook/react-native/graphs/contributors) 有 1214 人。Contributor 是用来干嘛的？除了支持新功能，还有就是修复 bug 啊。Weex/RN 都是希望一统 Android + iOS 的，这么伟大的目标，这么艰巨的工程，不是几个人可以轻轻松松搞定的。 \n- 公司背景（来自YY）。大家都知道 RN 来自 Facebook，Weex 来自阿里巴巴。如果想一窥它们的未来，需要先想一下这种技术对他们各自的意义。大家都清楚，Facebook、Google、Apple 是当今当之无愧的巨头，在移动互联网这波浪潮里，Google 掌握了 Android 法器，Apple 控制了 iOS 神器，Facebook 呢？并没有这些系统级入口。当然 Windows 的经历也让 Facebook 并不那么倾向去开发一个新的移动操作系统来竞争。那怎么办？React Native 应运而生，打出的口号就是： **Learn once, write anywhere**。什么意思，没错，就是明确告诉你学一次就可以同时开发两个平台了。这一点可一直都是移动端开发人员和创业公司的理想。有人说了，Apple 这么强势，RN 要是太嚣张，分分钟把你禁掉。这时我们就要来看看 RN 的 [Showcase](http://facebook.github.io/react-native/showcase.html) 了，哪些 App 应用了 RN 呢？Facebook, Instagram, Airbnb, Walmart, QQ, 京东等，这回 Apple 要禁 RN 就要稍微掂量下这些大厂的意见吧。\n\n当然，我是很希望国内也能推出优质的开源项目来和国外大厂抗衡的，不过真正优质的大型开源项目往往除了开发者的个人能力，和公司的战略和制度关系也很大。\n\n\n##### 4. RN vs Hybrid\n这里的 Hybrid 开发主要针对 Cordova 框架，其实在放弃 Weex 之后我们还是没考虑 RN，而是转过去了解 Cordova，不过做了大致了解后也放弃了。主要硬伤有两点：\n- 性能短板。大家知道 Hybrid 是基于 WebView 的，在 Android 上的性能缺陷非常明显；而 RN 是利用 JSCore 转化成 Native 运行的，性能相对而言好不少；\n- 用户体验。了解移动产品的人都知道用户体验的重要性，RN 的体验和原生的几乎没有差别，而 Webview 的实现是网页开发思路，体验会相差很大。\n\n**性能和用户体验是移动 App 的命根子。**\n\n因此，综合考虑下来，我们还是决定相信 Facebook 并采用 RN。\n\n##### 5. RN 劣势\n上面我提到了 RN 的一些优势，不过作为开发者更加需要明确其劣势，我总结了下大概有以下几点劣势：\n- 学习成本。Weex 的写法就是类似常规的 Html/JS，对于前端人员来说很容易上手，就算了非前端人员来说也花不了多久。而 RN 是在 React.js 上进行改进形成的一套语法，和常规前端差别较大，因此需要好几天的学习适应。当然我觉得优秀的程序员的基本素质之一就是能快速学习、练习并熟练一种新语言的。我个人的话大概花了两三天的时间已经能完成一套涵盖网络、JS与Native通信的页面了，对于 React.js 语法也上手很快。\n- 安装包 Size。对于 iOS 而言影响不算很大，对于 Android 来说，我尝试后发现引入 RN 会给 apk 带来 6MB 左右的增幅，不过利用 `split apk` 的技术就能缩小到到 1MB 左右的增幅。\n- 首次加载耗时。大家知道 RN 需要从服务器下载 JS bundle，然后在本地转化成 Native code 运行的，所以在第一次打开 App 时需要花费一些时间进行下载和刷新。当然我们可以在发布 client 时内置一个写好的 js 文件在本地作缓存用。\n\n\n### 二、React Native 运行机制\n对于一个用 RN 搭建的移动 App，在启动后会从服务器下载最新的 JS Bundle 文件，然后由本地 JavascriptCore 引擎对 JS 文件进行解析，并利用 Bridge 映射到对应的 Native 方法和 UI 控件。得到的效果是：\n1. 同样的 RN 代码，下发到 Android 和 iOS 不同平台中，会自动调用对应 Native 的 UI 控件，保证了各平台用户体验的连贯性；\n2. 开发者就算是移动端小白，只要有 Web 基础，通过编写一套 RN 端代码就可以同时完成 Android 与 iOS App 的开发；\n3. 由于可以利用 JS bundle 同时下发数据和业务逻辑，这意味着你可以像 Web 开发一样，实时迭代更新你的移动端 App，无需在了解各自平台的热修复技术；\n4. Native Modules，这是 RN 强大的一个扩展性，允许你通过简单的代码就能实现在 JS 里直接调用你自己的 Native 方法；\n5. Native Components，如果你自己实现了一些复杂的 Native UI 组件，而这些组件尚未被 RN 支持，你可以利用 Native Components 快速把原生组件引入到 RN 中并可以直接在 JS 里更新这些组件的状态。\n\n\n\n### 三、RN 开发环境搭建\n首先 IDE 方面，RN 推荐了一些工具：\n- [Nuclide](https://nuclide.io/) 是 Facebook 内部用来开发 RN 的工具，Debug 功能强大。只不过这是一款 [Atom](https://github.com/atom/atom) 的插件，意味着你必须先安装 Atom，再来安装这款开发插件；\n- [Deco](https://www.decosoftware.com/) 是专为开发 RN 诞生的工具，可以快速搜索开源的第三方 RN 组件并直接插入到代码中，用 MacOS 的同学可以尝试下。我本人最开始也是试用这个，上手简单、小巧简洁。不足的是功能有点简单，无论是 Debug 功能还是代码检查之类的都不具备；\n- [Sublime](https://www.sublimetext.com/) 可以通过第三方包来达到不错的开发效率，各方面还算可圈可点；\n- [Visual Studio](https://code.visualstudio.com/) 这款也是蛮强大的 IDE，之前有用过的小伙伴可以试一下。\n\n本人的话目前采用的是 `Sublime`，因为个人常用 Sublime，而且第三方插件很丰富，轻量方便。下面简单说下配置，感兴趣的小伙伴可以看下。\n1. [Babel](https://packagecontrol.io/packages/Babel) 用来高亮 React JSX 语法，支持 ES6，而 React-Native 就是搭建在 [React.js](https://facebook.github.io/react/) 基础上的；\n2. [React-Native-Snippets](https://github.com/Shrugs/react-native-snippets) 可以快速生成 RN 的一些模版代码；\n3. [ESLint](http://eslint.cn/docs/user-guide/configuring) 超级强大的 Lint 工具，支持 ES6、JSX 语法检查，而且还有 React 和 RN 的插件，比纯粹的 JSXHint/JSLint 都强大；\n\n当然，用 Atom 的小伙伴自然要首先考虑 [Nuclide](https://nuclide.io/)。\n\n### 四、引入 React Native\n引入 RN 有两种方法：从零构建；集成到已有项目。\n\n##### 1. Build from Scratch \n先说第一种，从零开始构建，比较简单，遵循官方文档 [Getting Started](http://facebook.github.io/react-native/releases/0.42/docs/getting-started.html) 基于你自己的操作系统和平台一步步安装相关的依赖，然后利用如下命令：\n```\nreact-native init AwesomeProject\n```\n你就创建好一个 RN 工程项目了，结构如下：\n\n![RN 目录结构](http://upload-images.jianshu.io/upload_images/281665-8691544719a34a57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n里面有四个文件夹：\n- `android` / `ios`：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行，对于移动端小白而言可以不用管里面的具体实现；\n- `node_modules`：里面是自动生成的 `node` 依赖之类的文件，通过读取 `package.json` 里的配置来生成；\n- `js`：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 `js` 文件打包下发给 client 就会自动生效。\n\n\n##### 2. 集成到已有项目\n有很多公司是希望在现有 App 的基础上集成 `RN` 来开发一些特定的 Feature，这种情况就不能参考上面的方法了。在 RN 的官方文档里有一节 [Integration with Existing Apps](http://facebook.github.io/react-native/releases/0.42/docs/integration-with-existing-apps.html) , 只需要按照一步步做即可。\n\n以 Android 为例，大概要做以下几步：\n1. 添加 `gradle` 依赖：`compile \"com.facebook.react:react-native:+\" // From node_modules.`；\n2. 创建空的 `Activity` ，指定 `JS bundle` 和入口 `Component` 名字即会自动在这个 `Activity` 里去加载 `JS bundle` 文件；\n3. 在 Activity 里监听 onBackPressed 事件，用来与 JS 端协作处理返回键点击事件。\n4. 启动 server，运行 App 即可。\n\n总之需要说明的是，即使是移动端小白，也可以遵循文档里的指示完成这一步。接下来的大部分时间只要关心 JS 端开发就行了。\n\n### 五、Javascript、React 及 ES6、JSX 语法\n我们知道 RN 采用了 React 和 ES6 的语法，所以我们必须先对这些语法有一定了解才能去读 RN 的代码。\n\n关于 `Javascript`，我推荐 W3School 里的 [JS语法](http://www.w3school.com.cn/js/) 和 MDN 里的 [JS手册](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)，大家只要对一些基础语法做些了解就可以。\n\n关于 `React`，我推荐 [阮一峰](http://www.ruanyifeng.com/) 写的 [React 入门实例教程](http://www.ruanyifeng.com/blog/2015/03/react.html)，基本上把文章读一遍，再自己动手写一遍，就能理会到 React 的大致用法了。\n\n关于 `ES6`、`ES7`、`JSX`等，感兴趣的可以看一下 RN 文档中 [Javascript Environment](http://facebook.github.io/react-native/releases/0.42/docs/javascript-environment.html) 里提到的支持的方法，需要时再来查询也可以。也可以看 `Babel` 出的 [Learn ES2015 手册](https://babeljs.io/learn-es2015/)。\n\n\n这里有一个很不错的 GitHub 项目，帮助你通过交互性的例子来快速上手语法知识：[React Native Express](http://www.reactnativeexpress.com/)。\n\n### 六、UI 层\n简单熟悉了 `React` 语法后，基本能正常阅读 RN 的示例代码了。\n\n正式开发 App 的第一步当然就是写 UI 界面了，由于 RN 已经封装好了一套 JS 的 UI 组件，这些组件会自动在 Android/iOS 端调用对应的原生 UI 组件，因此我们只需要熟悉这些 UI 组件的用法及属性、回调方法即可。\n\n我们可以在文档的 [Components](http://facebook.github.io/react-native/releases/0.42/docs/getting-started.html) 看到不少组件，比如`View, Text, Button, Image, Switch`, 还有我们用的最多的 `ScrollView` 和 `ListView`。\n\n在读文档时，我们可以先通过一边写代码一边读文档的方式进行，RN 非常贴心，直接在 Web 里嵌入了模拟器，我们只要修改编辑框里的代码，立即就能在右边的模拟器看到效果。这极大的降低了我们的学习成本。\n![Text Component](http://upload-images.jianshu.io/upload_images/281665-09965625af9b3a49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n另外，在学习一个组件时，我们要区分哪个属性是某个平台特有的。比如下面两个 Text 的属性：`textBreakStrategy` 只会在 Android 上生效，而 `adjustsFontSizeToFit` 只可以用在 iOS 上。\n\n![Platform Specific Properties](http://upload-images.jianshu.io/upload_images/281665-c8f4990d8334f3ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后，如果你希望在 Android 和 iOS 里显示不同的内容怎么办呢？RN 里有一节是[Platform Specific Code](http://facebook.github.io/react-native/releases/0.42/docs/platform-specific-code.html)，可以有如下几种形式来进行区分：\n```\nif (Platform.OS === 'ios') {\n  // stuff for ios\n} else {\n  // stuff for android\n}\n```\n\n除此之外，UI 组件的用法学习就很类似常规的 Html 标签了，只要知道其使用方式即可，甚至需要用的时候再来查文档也行。\n\n### 七、网络请求层 \n学完上面的我们已经能够写出 UI 界面了，而且这套界面已经能够在不同平台上转化成各自平台的 Native UI 了。然后，我们就需要去网络层请求真实数据了。\n\nRN 里提供了 [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) 来进行实现。举个例子，你想要通过 GET 方法去请求数据并转化成 JSON，可以通过如下代码实现：\n```\nfetch('https://facebook.github.io/react-native/movies.json')\n      .then((response) => response.json())\n      .then((responseJson) => {\n        return responseJson.movies;\n      })\n      .catch((error) => {\n        console.error(error);\n      });\n```\n熟悉 Reactive 编程的伙伴应该对这样的语法不陌生，比如 Android 上的 [RxJava](https://github.com/ReactiveX/RxJava)； iOS 上的 [RxSwift](https://github.com/ReactiveX/RxSwift)；Web 上的 [RxJS](https://github.com/Reactive-Extensions/RxJS)。上面 function 的功能就是：请求网址 `https://facebook.github.io/react-native/movies.json`，把返回的 Response 转化成 JSON object，取出 JSON object 里的 `movies` 字段。同时，如果发生 error 会被 catch 住。\n\n当然，上面是最基本的 GET 请求，Fetch API 还支持自定义 Headers，更换 Method，添加 Body 等。\n```\nfetch('https://mywebsite.com/endpoint/', {\n  method: 'POST',\n  headers: {\n    'Accept': 'application/json',\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({\n    firstParam: 'yourValue',\n    secondParam: 'yourOtherValue',\n  })\n})\n```\n上面构建了一个基本的 POST 请求，添加了自己的 Headers:`Accept`和`Content-Type`，添加了 Body。\n\n因此看下来，RN 里的网络请求不仅具备了 Reactive 编程的简洁，也能自定义常规的 Http 请求，写法简单。\n\n除了 Fetch API 之外，RN 还内置了 [XMLHttpRequest API(俗称 AJAX)](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)，而且支持[TCP 全双工通信方式 WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)。\n\n### 八、Debugging 调试\n调试是很多程序员非常关注的一个环节，因为 RN 是用 JS 写完后到 Native 解释成 Native 方法来执行的，因此如果能快速调试 JS 代码是非常重要的一环。\n\n最开始 RN 的调试功能比较弱，不过现在的 Debugging 功能在我看来还是很不错的。一般来讲可以有以下几个调试方式：\n\n#####1. In-App 报错\nRN 里默认集成了 In-App 的错误提示方式，即在 App 运行过程中会弹出全屏的报错信息呈现给你，而你也可以通过阅读具体的错误信息快速找到错误原因。通过点击这个错误信息里的某一行，会立即自动打开对应的代码。\n![In-App Error](http://upload-images.jianshu.io/upload_images/281665-6531d24c41982690.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#####2. Console.log\n在开发 Client 时，我们一般都会用 `Log.log()` 来打印一些运行时变量的值，然后实时查看打印出来的 log 来调试，在 RN 也一样，你只要在 JS 里写一句 `console.log('this is log data')`，就会自动在 Client 的常规 log 里能看到，比如 Android 的 `adb logcat` 里就会自动打印出`'this is log data'`一行。\n\n#####3. 大杀器：Chrome 逐行调试\n这个杀器的最牛逼之处就是可以像 Client 一样，逐行调试代码！\n\n我们来看下面一张图。从左往右。先是文件目录，我们选中了 `index.js` 文件夹，然后第二个 Tab，是 `index.js` 的内容。这里关键的是我可以直接选中某一行代码设断点。当 Client 运行到这一行时，就会在第三个 Tab 里打印出运行时环境及变量。我们可以看到 `props` 里就有我们传进去的变量值。\n\n![Chrome Debug](http://upload-images.jianshu.io/upload_images/281665-d2fb4470d8ae27b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n有了以上几种调试方式，我们几乎可以和常规的 Native 开发一样来调试 RN 代码了，不得不说 RN Team 确实牛 x 啊！\n\n### 九、从 JS 调用 Native 方法或显示自定义 Native View\n这又是另一个牛 x 之处啊。\n\n很多人觉得 RN 限制太多，只能支持有限的 View 组件和有限的方法，难以发挥 Client 的最大性能。简单点说，在 Client 可以绘制复杂的 View，可以调用高性能 C++ 等底层代码，但 RN 却做不到。\n\n于是，RN 里提出了 `Native Modules` 和 `Native UI Component` 两种技术。\n\n#####Native Modules：JS 里直接调用 Native(Java/Swift) 方法\n所谓 Native Modules，就是自己在 Client 写好了某些方法，由于某些原因这些方法不太方便或者无法搬到 RN 里面，那么，我们可以在 Client 把这些方法暴露出来给 RN，然后在 JS 里可以像 import 普通的 module 一样把这些 Native Modules 引入进去，直接调用。\n\n具体的实现方法可以参考文档 [iOS Native Modules](http://facebook.github.io/react-native/releases/0.42/docs/native-modules-ios.html) 和 [Android Native Modules](http://facebook.github.io/react-native/releases/0.42/docs/native-modules-android.html)。\n\n\n#####Native UI Component：JS 里直接调用自定义的 Native View\n很多时候我们在写 Client 时，为了实现 Designer 天马行空的设计，常常需要自定义 View，即自己绘制某些系统并不提供的特定 UI。可想而知，这些 View 肯定不会出现在 RN 的 UI Component 里。\n\n那么，我们就需要首先在 Native 层自己写好一个自定义 View，然后利用`Native UI Component` 技术把这个 View 及其中某些 public 方法暴露给 RN，那么 RN 就能直接 import 进来并显示了。\n\n具体的实现方法可以参考文档 [iOS Native UI Component](http://facebook.github.io/react-native/releases/0.42/docs/native-components-ios.html) 和 [Android Native UI Component](http://facebook.github.io/react-native/releases/0.42/docs/native-components-android.html)。\n\n**如果读过文档不是很理解的小伙伴可以留言，我再 post 一些 demo 代码上来**\n\n### 十、React Native 适合你吗？\n这里借鉴下前段时间旧金山的 React Native 会议上的一些优劣总结给读者以参考。当然不一定对，仅供参考。\n\nRN 的优点：\n- 跨平台\n- 原生的用户体验\n- 开发者体验好\n- 动态更新代码逻辑\n- 社区强大\n- 有个好爹\n\nRN 的缺点：\n- 不够成熟\n- 不够稳定\n- 生态系统在搭建中\n- 优质的 App 需要时间打磨\n- 偶尔需要写 Native 代码(也就是 JS + Swift + Java)\n\n适合下面这些人/公司：\n- 你对 JS/React 有一定了解\n- Web 开发人员比 Mobile 开发人员多\n- 有意愿投资精力给 RN\n- App 设计不是特别区分 Android 和 iOS\n- 希望热更新\n\n下面这些人要稍微考虑下：\n- 完全不了解 JS/React\n- 已经有现成的 Android/iOS team\n- App 设计严格遵守 Android、iOS各自设计规范\n- 不想要投入时间／金钱给 RN\n\n### 十一、为什么要写这篇文章\n几个月前我对 React Native 也非常不看好，当然现在也没有说非常看好。或者说，写这篇文章毫无为 React Native 布道之意。\n\n接触 React Native 主要是因为业务需要，PM 希望能够随时改动某块变化较大的模块，常规的开发提交流程往往需要较长的时间，而热修复技术本身并未得到 Google 和 Apple 的官方认可，也就是随时可能因破坏生态安全之名被取缔。\n\n因此才考虑去了解 Hybrid 开发和 JS Native 开发模式，在了解过程中，又由于性能差、用户体验不好而放弃 Hybrid，由于社区不完善、Bug 较多等原因放弃 Weex，最终才选择了 React Native，开始学习 React、JSX等语法。\n\n目前使用下来对 React Native 的一些个人感受：\n1. 学习门槛并没有开始想象那么高。大概只花了两三天时间就熟悉了 Javascript、React 框架、JSX语法，然后就开始着手业务开发。\n2. 对 Android App 的影响。React Native 会给 Android 端带来 `6MB` 左右的 size 增幅，不过在采用了 `split apk` 后就只有 `1MB` 左右增幅。\n3. Debug 功能比较完善，至少不用担心发生问题后不知从哪下手。\n4. 性能还行。最初担心的是 React Native 性能不好，但自己上手后，并没有明显感觉到很明显的 React Native 对 App 性能的负面影响，无论是 iOS 还是 Android，当然，这一点还在继续考察中。\n5. 动态部署真的很不错。以前每次写好代码都要花不少时间来编译运行，而现在只要写一份代码，就可以同时在 Android 和 iOS 实时更新了，这无疑节省了生命。\n5. 有待完善。当然，React Native 中确实还存在着不少问题，生态系统也还不够完善。不过我相信，这只是时间问题。\n\n关于React Native一直以来都有很多争议。\n\n不过我想说的是，**React Native 所代表的跨平台、动态更新技术已经引起了全世界开发者关注，而且这种技术势必会是未来的需求和潮流。React Native 不一定会成功，但至少目前 React Native 已经是这一领域的领跑者。**\n\n而写这篇文章的目的，就是希望告诉更多开发者，**React Native 并不完美，但值得一试。**\n\n谢谢。\n\nwingjay\n\n\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>","source":"_posts/写给移动开发者的-React-Native-指南.md","raw":"title: 写给移动开发者的 React Native 指南\ndate: 2017-03-14 12:07:06\ncategories:\n  - React Native\ntags: React Native\ncommentIssueId: 10\n---\n\n> React Native 所代表的跨平台、动态更新技术已经引起了全世界开发者关注，而且这种技术势必会是未来的需求和潮流。React Native 不一定会成功，但至少目前 React Native 已经是这一领域的领跑者。\n\n<!-- more -->\n\n\n### 前言\nReact Native 诞生于 2015 年，名副其实的富二代，主要使命是为父出征，与 Apple 和 Google 抗衡，为开发者带去一套跨平台、动态更新的 Javascript 框架，口号是：Learn once, write anywhere：Build mobile apps with React。在试图推翻 Android 和 iOS 压制的同时，还提携了一把自家兄弟：React。\n\n从诞生之日 React Native 就充满了期待和争议。期待是无数开发者希望不用忍受频繁发版的噩梦，也不用同时为两个平台开发业务逻辑几无差别的两个 App；争议是 React Native 真的能以一己之力救大众于水火吗？React Native 在跨平台时还能保持良好的用户体验吗？\n\n当然我们知道，这种问题向来都是仁者见仁，智者见智。比起一味的疑惑、争论，还不如来好好看看这货究竟是个啥？甚至自己动手来玩一把。\n\n本文主要针对两类读者：\n- 想要入门 RN 的人，在阅读官方文档前先对 RN 形成一个整体的印象\n- 对 RN 心存好奇，在犹豫是否要入坑的开发者，可以通过本文对 RN 更客观全面的认识\n\n\n### 目录\n- React Native 好在哪\n  - 跨平台＋动态更新\n  - 代码复用\n  - RN vs Weex\n  - RN vs Hybrid\n  - RN 劣势\n- React Native 运行机制\n- RN 开发环境搭建\n- 引入 React Native\n  - Build from Scratch\n  - 集成到已有项目\n- Javascript、React 及 ES6、JSX 语法\n- UI 层\n- 网络请求层\n- Debugging 调试\n  - In-App 报错\n  - Console.log\n  - 大杀器：Chrome 逐行调试\n- 从 JS 调用 Native 方法或显示自定义 Native View\n  - Native Modules：JS 里直接调用 Native(Java/Swift) 方法\n  - Native UI Component：JS 里直接调用自定义的 Native View\n- React Native 适合你吗？\n- 为什么要写这篇文章\n\n### React Native 好在哪\n下面我们来看下 Hybrid 及 React Native 等开发模式包含了哪些常规移动开发所不具备的优势。\n\n##### 1. 跨平台＋动态更新\n传统的客户端开发模式是怎样的呢？\n\nAndroid 与 iOS Team 分别编写客户端代码，打包，分发到 Play Store 和 Apple Store，通过更新 JSON 数据来更新页面。\n\n不过，当客户端发生严重问题而服务器上无法 quick fix 时，就不得不重新发版。\n\n对国外 Android 市场而言还好，因为能通过 Play Store 快速更新；国内 Android 市场则由于分发渠道太杂，很难及时把新版本立即推送给所有用户，当然这也是为何热修复技术在国内盛行而国外冷清的原因；而 Apple Store 则需要一定的审核时间，而且最近又在抓 iOS 热修复框架如 JsPatch、Rollout 等。\n\n相比而言，Hybrid 和 RN/Weex 模式除了能下发 Json 数据来刷新界面内容，更能直接下发业务逻辑代码，直接实现整体 App 的更新。而且，它们不用在乎 Android 和 iOS 两个平台，因为一份 JS 代码写好后，把 JS Bundle 放在服务器上，所有的客户端立即更新。\n\n##### 2. 代码复用\n一般而言，同一款产品的 Android 和 iOS 两端除 UI 有些许不同外，多数业务逻辑几乎完全一致，这便造成了人力的浪费。\n\n而最近 Instagram 的官博 [React Native at Instagram](https://engineering.instagram.com/react-native-at-instagram-dd828a9a90c7#.ugk9ncjyz) 一文中已经提到，利用 RN (React Native 缩写，下同) 开发的 feature 可以实现 `85% - 99%` 的代码复用率。这意味着我们可以用更少的人力成本来达到相同的效果。\n\n##### 3. RN  vs Weex \n实现上面的效果有两种开发框架：混合开发框架 Cordova 和基于 Javascript 的 React-Native、Weex 框架。\n\n下面我从自己的实践经验出发做些比较，也欢迎读者提出自己看法。\n\n最开始觉得 RN 的学习成本比较大，所以首先考虑了 [Weex 框架](https://github.com/alibaba/weex)，据说是阿里巴巴良心出品。不过在尝试后不得不选择了放弃，原因有这几点：\n- Bug 较多。我们最先测试了`最基本`的 ListView，在 iOS 运行良好，而同样的 Demo 代码到了 Android 这边的`下拉刷新`就出现了问题，这使得我们开始警惕；\n- 社区、文档弱，GitHub Issue 基本是中文。当然我毫无歧视中文之意。我认为，**一套项目开源是真正意义是希望借助开源社区的力量，一起来完善改进，因此要优先推崇英文，使项目国际化，得到全世界开发者的共同支持，这样才是可持续的模式。**而 Weex 的 [Issue](https://github.com/alibaba/weex/issues) 里放眼望去基本 90% 都是中文，无论提问者还是**项目维护者**。这一点直接把国外优秀的开发者拒之门外，也很难让我看到多么长远的未来。\n下面是摘取的 RN 里的一则中文 issue：\n\n![**Issue is for bug report, not for Q&A**](http://upload-images.jianshu.io/upload_images/281665-fdd239b44898ea4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- Contributor 差别。因为上面一点，[Weex 的 Contributor](https://github.com/apache/incubator-weex/graphs/contributors) 只有 91 个人，而 [React-Native 的 Contributor](https://github.com/facebook/react-native/graphs/contributors) 有 1214 人。Contributor 是用来干嘛的？除了支持新功能，还有就是修复 bug 啊。Weex/RN 都是希望一统 Android + iOS 的，这么伟大的目标，这么艰巨的工程，不是几个人可以轻轻松松搞定的。 \n- 公司背景（来自YY）。大家都知道 RN 来自 Facebook，Weex 来自阿里巴巴。如果想一窥它们的未来，需要先想一下这种技术对他们各自的意义。大家都清楚，Facebook、Google、Apple 是当今当之无愧的巨头，在移动互联网这波浪潮里，Google 掌握了 Android 法器，Apple 控制了 iOS 神器，Facebook 呢？并没有这些系统级入口。当然 Windows 的经历也让 Facebook 并不那么倾向去开发一个新的移动操作系统来竞争。那怎么办？React Native 应运而生，打出的口号就是： **Learn once, write anywhere**。什么意思，没错，就是明确告诉你学一次就可以同时开发两个平台了。这一点可一直都是移动端开发人员和创业公司的理想。有人说了，Apple 这么强势，RN 要是太嚣张，分分钟把你禁掉。这时我们就要来看看 RN 的 [Showcase](http://facebook.github.io/react-native/showcase.html) 了，哪些 App 应用了 RN 呢？Facebook, Instagram, Airbnb, Walmart, QQ, 京东等，这回 Apple 要禁 RN 就要稍微掂量下这些大厂的意见吧。\n\n当然，我是很希望国内也能推出优质的开源项目来和国外大厂抗衡的，不过真正优质的大型开源项目往往除了开发者的个人能力，和公司的战略和制度关系也很大。\n\n\n##### 4. RN vs Hybrid\n这里的 Hybrid 开发主要针对 Cordova 框架，其实在放弃 Weex 之后我们还是没考虑 RN，而是转过去了解 Cordova，不过做了大致了解后也放弃了。主要硬伤有两点：\n- 性能短板。大家知道 Hybrid 是基于 WebView 的，在 Android 上的性能缺陷非常明显；而 RN 是利用 JSCore 转化成 Native 运行的，性能相对而言好不少；\n- 用户体验。了解移动产品的人都知道用户体验的重要性，RN 的体验和原生的几乎没有差别，而 Webview 的实现是网页开发思路，体验会相差很大。\n\n**性能和用户体验是移动 App 的命根子。**\n\n因此，综合考虑下来，我们还是决定相信 Facebook 并采用 RN。\n\n##### 5. RN 劣势\n上面我提到了 RN 的一些优势，不过作为开发者更加需要明确其劣势，我总结了下大概有以下几点劣势：\n- 学习成本。Weex 的写法就是类似常规的 Html/JS，对于前端人员来说很容易上手，就算了非前端人员来说也花不了多久。而 RN 是在 React.js 上进行改进形成的一套语法，和常规前端差别较大，因此需要好几天的学习适应。当然我觉得优秀的程序员的基本素质之一就是能快速学习、练习并熟练一种新语言的。我个人的话大概花了两三天的时间已经能完成一套涵盖网络、JS与Native通信的页面了，对于 React.js 语法也上手很快。\n- 安装包 Size。对于 iOS 而言影响不算很大，对于 Android 来说，我尝试后发现引入 RN 会给 apk 带来 6MB 左右的增幅，不过利用 `split apk` 的技术就能缩小到到 1MB 左右的增幅。\n- 首次加载耗时。大家知道 RN 需要从服务器下载 JS bundle，然后在本地转化成 Native code 运行的，所以在第一次打开 App 时需要花费一些时间进行下载和刷新。当然我们可以在发布 client 时内置一个写好的 js 文件在本地作缓存用。\n\n\n### 二、React Native 运行机制\n对于一个用 RN 搭建的移动 App，在启动后会从服务器下载最新的 JS Bundle 文件，然后由本地 JavascriptCore 引擎对 JS 文件进行解析，并利用 Bridge 映射到对应的 Native 方法和 UI 控件。得到的效果是：\n1. 同样的 RN 代码，下发到 Android 和 iOS 不同平台中，会自动调用对应 Native 的 UI 控件，保证了各平台用户体验的连贯性；\n2. 开发者就算是移动端小白，只要有 Web 基础，通过编写一套 RN 端代码就可以同时完成 Android 与 iOS App 的开发；\n3. 由于可以利用 JS bundle 同时下发数据和业务逻辑，这意味着你可以像 Web 开发一样，实时迭代更新你的移动端 App，无需在了解各自平台的热修复技术；\n4. Native Modules，这是 RN 强大的一个扩展性，允许你通过简单的代码就能实现在 JS 里直接调用你自己的 Native 方法；\n5. Native Components，如果你自己实现了一些复杂的 Native UI 组件，而这些组件尚未被 RN 支持，你可以利用 Native Components 快速把原生组件引入到 RN 中并可以直接在 JS 里更新这些组件的状态。\n\n\n\n### 三、RN 开发环境搭建\n首先 IDE 方面，RN 推荐了一些工具：\n- [Nuclide](https://nuclide.io/) 是 Facebook 内部用来开发 RN 的工具，Debug 功能强大。只不过这是一款 [Atom](https://github.com/atom/atom) 的插件，意味着你必须先安装 Atom，再来安装这款开发插件；\n- [Deco](https://www.decosoftware.com/) 是专为开发 RN 诞生的工具，可以快速搜索开源的第三方 RN 组件并直接插入到代码中，用 MacOS 的同学可以尝试下。我本人最开始也是试用这个，上手简单、小巧简洁。不足的是功能有点简单，无论是 Debug 功能还是代码检查之类的都不具备；\n- [Sublime](https://www.sublimetext.com/) 可以通过第三方包来达到不错的开发效率，各方面还算可圈可点；\n- [Visual Studio](https://code.visualstudio.com/) 这款也是蛮强大的 IDE，之前有用过的小伙伴可以试一下。\n\n本人的话目前采用的是 `Sublime`，因为个人常用 Sublime，而且第三方插件很丰富，轻量方便。下面简单说下配置，感兴趣的小伙伴可以看下。\n1. [Babel](https://packagecontrol.io/packages/Babel) 用来高亮 React JSX 语法，支持 ES6，而 React-Native 就是搭建在 [React.js](https://facebook.github.io/react/) 基础上的；\n2. [React-Native-Snippets](https://github.com/Shrugs/react-native-snippets) 可以快速生成 RN 的一些模版代码；\n3. [ESLint](http://eslint.cn/docs/user-guide/configuring) 超级强大的 Lint 工具，支持 ES6、JSX 语法检查，而且还有 React 和 RN 的插件，比纯粹的 JSXHint/JSLint 都强大；\n\n当然，用 Atom 的小伙伴自然要首先考虑 [Nuclide](https://nuclide.io/)。\n\n### 四、引入 React Native\n引入 RN 有两种方法：从零构建；集成到已有项目。\n\n##### 1. Build from Scratch \n先说第一种，从零开始构建，比较简单，遵循官方文档 [Getting Started](http://facebook.github.io/react-native/releases/0.42/docs/getting-started.html) 基于你自己的操作系统和平台一步步安装相关的依赖，然后利用如下命令：\n```\nreact-native init AwesomeProject\n```\n你就创建好一个 RN 工程项目了，结构如下：\n\n![RN 目录结构](http://upload-images.jianshu.io/upload_images/281665-8691544719a34a57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n里面有四个文件夹：\n- `android` / `ios`：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行，对于移动端小白而言可以不用管里面的具体实现；\n- `node_modules`：里面是自动生成的 `node` 依赖之类的文件，通过读取 `package.json` 里的配置来生成；\n- `js`：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 `js` 文件打包下发给 client 就会自动生效。\n\n\n##### 2. 集成到已有项目\n有很多公司是希望在现有 App 的基础上集成 `RN` 来开发一些特定的 Feature，这种情况就不能参考上面的方法了。在 RN 的官方文档里有一节 [Integration with Existing Apps](http://facebook.github.io/react-native/releases/0.42/docs/integration-with-existing-apps.html) , 只需要按照一步步做即可。\n\n以 Android 为例，大概要做以下几步：\n1. 添加 `gradle` 依赖：`compile \"com.facebook.react:react-native:+\" // From node_modules.`；\n2. 创建空的 `Activity` ，指定 `JS bundle` 和入口 `Component` 名字即会自动在这个 `Activity` 里去加载 `JS bundle` 文件；\n3. 在 Activity 里监听 onBackPressed 事件，用来与 JS 端协作处理返回键点击事件。\n4. 启动 server，运行 App 即可。\n\n总之需要说明的是，即使是移动端小白，也可以遵循文档里的指示完成这一步。接下来的大部分时间只要关心 JS 端开发就行了。\n\n### 五、Javascript、React 及 ES6、JSX 语法\n我们知道 RN 采用了 React 和 ES6 的语法，所以我们必须先对这些语法有一定了解才能去读 RN 的代码。\n\n关于 `Javascript`，我推荐 W3School 里的 [JS语法](http://www.w3school.com.cn/js/) 和 MDN 里的 [JS手册](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)，大家只要对一些基础语法做些了解就可以。\n\n关于 `React`，我推荐 [阮一峰](http://www.ruanyifeng.com/) 写的 [React 入门实例教程](http://www.ruanyifeng.com/blog/2015/03/react.html)，基本上把文章读一遍，再自己动手写一遍，就能理会到 React 的大致用法了。\n\n关于 `ES6`、`ES7`、`JSX`等，感兴趣的可以看一下 RN 文档中 [Javascript Environment](http://facebook.github.io/react-native/releases/0.42/docs/javascript-environment.html) 里提到的支持的方法，需要时再来查询也可以。也可以看 `Babel` 出的 [Learn ES2015 手册](https://babeljs.io/learn-es2015/)。\n\n\n这里有一个很不错的 GitHub 项目，帮助你通过交互性的例子来快速上手语法知识：[React Native Express](http://www.reactnativeexpress.com/)。\n\n### 六、UI 层\n简单熟悉了 `React` 语法后，基本能正常阅读 RN 的示例代码了。\n\n正式开发 App 的第一步当然就是写 UI 界面了，由于 RN 已经封装好了一套 JS 的 UI 组件，这些组件会自动在 Android/iOS 端调用对应的原生 UI 组件，因此我们只需要熟悉这些 UI 组件的用法及属性、回调方法即可。\n\n我们可以在文档的 [Components](http://facebook.github.io/react-native/releases/0.42/docs/getting-started.html) 看到不少组件，比如`View, Text, Button, Image, Switch`, 还有我们用的最多的 `ScrollView` 和 `ListView`。\n\n在读文档时，我们可以先通过一边写代码一边读文档的方式进行，RN 非常贴心，直接在 Web 里嵌入了模拟器，我们只要修改编辑框里的代码，立即就能在右边的模拟器看到效果。这极大的降低了我们的学习成本。\n![Text Component](http://upload-images.jianshu.io/upload_images/281665-09965625af9b3a49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n另外，在学习一个组件时，我们要区分哪个属性是某个平台特有的。比如下面两个 Text 的属性：`textBreakStrategy` 只会在 Android 上生效，而 `adjustsFontSizeToFit` 只可以用在 iOS 上。\n\n![Platform Specific Properties](http://upload-images.jianshu.io/upload_images/281665-c8f4990d8334f3ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后，如果你希望在 Android 和 iOS 里显示不同的内容怎么办呢？RN 里有一节是[Platform Specific Code](http://facebook.github.io/react-native/releases/0.42/docs/platform-specific-code.html)，可以有如下几种形式来进行区分：\n```\nif (Platform.OS === 'ios') {\n  // stuff for ios\n} else {\n  // stuff for android\n}\n```\n\n除此之外，UI 组件的用法学习就很类似常规的 Html 标签了，只要知道其使用方式即可，甚至需要用的时候再来查文档也行。\n\n### 七、网络请求层 \n学完上面的我们已经能够写出 UI 界面了，而且这套界面已经能够在不同平台上转化成各自平台的 Native UI 了。然后，我们就需要去网络层请求真实数据了。\n\nRN 里提供了 [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) 来进行实现。举个例子，你想要通过 GET 方法去请求数据并转化成 JSON，可以通过如下代码实现：\n```\nfetch('https://facebook.github.io/react-native/movies.json')\n      .then((response) => response.json())\n      .then((responseJson) => {\n        return responseJson.movies;\n      })\n      .catch((error) => {\n        console.error(error);\n      });\n```\n熟悉 Reactive 编程的伙伴应该对这样的语法不陌生，比如 Android 上的 [RxJava](https://github.com/ReactiveX/RxJava)； iOS 上的 [RxSwift](https://github.com/ReactiveX/RxSwift)；Web 上的 [RxJS](https://github.com/Reactive-Extensions/RxJS)。上面 function 的功能就是：请求网址 `https://facebook.github.io/react-native/movies.json`，把返回的 Response 转化成 JSON object，取出 JSON object 里的 `movies` 字段。同时，如果发生 error 会被 catch 住。\n\n当然，上面是最基本的 GET 请求，Fetch API 还支持自定义 Headers，更换 Method，添加 Body 等。\n```\nfetch('https://mywebsite.com/endpoint/', {\n  method: 'POST',\n  headers: {\n    'Accept': 'application/json',\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({\n    firstParam: 'yourValue',\n    secondParam: 'yourOtherValue',\n  })\n})\n```\n上面构建了一个基本的 POST 请求，添加了自己的 Headers:`Accept`和`Content-Type`，添加了 Body。\n\n因此看下来，RN 里的网络请求不仅具备了 Reactive 编程的简洁，也能自定义常规的 Http 请求，写法简单。\n\n除了 Fetch API 之外，RN 还内置了 [XMLHttpRequest API(俗称 AJAX)](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)，而且支持[TCP 全双工通信方式 WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)。\n\n### 八、Debugging 调试\n调试是很多程序员非常关注的一个环节，因为 RN 是用 JS 写完后到 Native 解释成 Native 方法来执行的，因此如果能快速调试 JS 代码是非常重要的一环。\n\n最开始 RN 的调试功能比较弱，不过现在的 Debugging 功能在我看来还是很不错的。一般来讲可以有以下几个调试方式：\n\n#####1. In-App 报错\nRN 里默认集成了 In-App 的错误提示方式，即在 App 运行过程中会弹出全屏的报错信息呈现给你，而你也可以通过阅读具体的错误信息快速找到错误原因。通过点击这个错误信息里的某一行，会立即自动打开对应的代码。\n![In-App Error](http://upload-images.jianshu.io/upload_images/281665-6531d24c41982690.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#####2. Console.log\n在开发 Client 时，我们一般都会用 `Log.log()` 来打印一些运行时变量的值，然后实时查看打印出来的 log 来调试，在 RN 也一样，你只要在 JS 里写一句 `console.log('this is log data')`，就会自动在 Client 的常规 log 里能看到，比如 Android 的 `adb logcat` 里就会自动打印出`'this is log data'`一行。\n\n#####3. 大杀器：Chrome 逐行调试\n这个杀器的最牛逼之处就是可以像 Client 一样，逐行调试代码！\n\n我们来看下面一张图。从左往右。先是文件目录，我们选中了 `index.js` 文件夹，然后第二个 Tab，是 `index.js` 的内容。这里关键的是我可以直接选中某一行代码设断点。当 Client 运行到这一行时，就会在第三个 Tab 里打印出运行时环境及变量。我们可以看到 `props` 里就有我们传进去的变量值。\n\n![Chrome Debug](http://upload-images.jianshu.io/upload_images/281665-d2fb4470d8ae27b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n有了以上几种调试方式，我们几乎可以和常规的 Native 开发一样来调试 RN 代码了，不得不说 RN Team 确实牛 x 啊！\n\n### 九、从 JS 调用 Native 方法或显示自定义 Native View\n这又是另一个牛 x 之处啊。\n\n很多人觉得 RN 限制太多，只能支持有限的 View 组件和有限的方法，难以发挥 Client 的最大性能。简单点说，在 Client 可以绘制复杂的 View，可以调用高性能 C++ 等底层代码，但 RN 却做不到。\n\n于是，RN 里提出了 `Native Modules` 和 `Native UI Component` 两种技术。\n\n#####Native Modules：JS 里直接调用 Native(Java/Swift) 方法\n所谓 Native Modules，就是自己在 Client 写好了某些方法，由于某些原因这些方法不太方便或者无法搬到 RN 里面，那么，我们可以在 Client 把这些方法暴露出来给 RN，然后在 JS 里可以像 import 普通的 module 一样把这些 Native Modules 引入进去，直接调用。\n\n具体的实现方法可以参考文档 [iOS Native Modules](http://facebook.github.io/react-native/releases/0.42/docs/native-modules-ios.html) 和 [Android Native Modules](http://facebook.github.io/react-native/releases/0.42/docs/native-modules-android.html)。\n\n\n#####Native UI Component：JS 里直接调用自定义的 Native View\n很多时候我们在写 Client 时，为了实现 Designer 天马行空的设计，常常需要自定义 View，即自己绘制某些系统并不提供的特定 UI。可想而知，这些 View 肯定不会出现在 RN 的 UI Component 里。\n\n那么，我们就需要首先在 Native 层自己写好一个自定义 View，然后利用`Native UI Component` 技术把这个 View 及其中某些 public 方法暴露给 RN，那么 RN 就能直接 import 进来并显示了。\n\n具体的实现方法可以参考文档 [iOS Native UI Component](http://facebook.github.io/react-native/releases/0.42/docs/native-components-ios.html) 和 [Android Native UI Component](http://facebook.github.io/react-native/releases/0.42/docs/native-components-android.html)。\n\n**如果读过文档不是很理解的小伙伴可以留言，我再 post 一些 demo 代码上来**\n\n### 十、React Native 适合你吗？\n这里借鉴下前段时间旧金山的 React Native 会议上的一些优劣总结给读者以参考。当然不一定对，仅供参考。\n\nRN 的优点：\n- 跨平台\n- 原生的用户体验\n- 开发者体验好\n- 动态更新代码逻辑\n- 社区强大\n- 有个好爹\n\nRN 的缺点：\n- 不够成熟\n- 不够稳定\n- 生态系统在搭建中\n- 优质的 App 需要时间打磨\n- 偶尔需要写 Native 代码(也就是 JS + Swift + Java)\n\n适合下面这些人/公司：\n- 你对 JS/React 有一定了解\n- Web 开发人员比 Mobile 开发人员多\n- 有意愿投资精力给 RN\n- App 设计不是特别区分 Android 和 iOS\n- 希望热更新\n\n下面这些人要稍微考虑下：\n- 完全不了解 JS/React\n- 已经有现成的 Android/iOS team\n- App 设计严格遵守 Android、iOS各自设计规范\n- 不想要投入时间／金钱给 RN\n\n### 十一、为什么要写这篇文章\n几个月前我对 React Native 也非常不看好，当然现在也没有说非常看好。或者说，写这篇文章毫无为 React Native 布道之意。\n\n接触 React Native 主要是因为业务需要，PM 希望能够随时改动某块变化较大的模块，常规的开发提交流程往往需要较长的时间，而热修复技术本身并未得到 Google 和 Apple 的官方认可，也就是随时可能因破坏生态安全之名被取缔。\n\n因此才考虑去了解 Hybrid 开发和 JS Native 开发模式，在了解过程中，又由于性能差、用户体验不好而放弃 Hybrid，由于社区不完善、Bug 较多等原因放弃 Weex，最终才选择了 React Native，开始学习 React、JSX等语法。\n\n目前使用下来对 React Native 的一些个人感受：\n1. 学习门槛并没有开始想象那么高。大概只花了两三天时间就熟悉了 Javascript、React 框架、JSX语法，然后就开始着手业务开发。\n2. 对 Android App 的影响。React Native 会给 Android 端带来 `6MB` 左右的 size 增幅，不过在采用了 `split apk` 后就只有 `1MB` 左右增幅。\n3. Debug 功能比较完善，至少不用担心发生问题后不知从哪下手。\n4. 性能还行。最初担心的是 React Native 性能不好，但自己上手后，并没有明显感觉到很明显的 React Native 对 App 性能的负面影响，无论是 iOS 还是 Android，当然，这一点还在继续考察中。\n5. 动态部署真的很不错。以前每次写好代码都要花不少时间来编译运行，而现在只要写一份代码，就可以同时在 Android 和 iOS 实时更新了，这无疑节省了生命。\n5. 有待完善。当然，React Native 中确实还存在着不少问题，生态系统也还不够完善。不过我相信，这只是时间问题。\n\n关于React Native一直以来都有很多争议。\n\n不过我想说的是，**React Native 所代表的跨平台、动态更新技术已经引起了全世界开发者关注，而且这种技术势必会是未来的需求和潮流。React Native 不一定会成功，但至少目前 React Native 已经是这一领域的领跑者。**\n\n而写这篇文章的目的，就是希望告诉更多开发者，**React Native 并不完美，但值得一试。**\n\n谢谢。\n\nwingjay\n\n\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>","slug":"写给移动开发者的-React-Native-指南","published":1,"updated":"2017-06-23T04:05:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm1x002imoyx2t4pxplo","sticky":0},{"title":"今年之计－2017","date":"2017-02-05T14:17:23.000Z","_content":"> 2017年我的计划\n\n<!-- more -->\n\n按照习惯，每一年开初都要回顾过去，制定新一年的计划。\n\n## 回顾 2016\n2016年是我的一个大年，完成了毕业和入职的交替，从学生到职场人员。\n\n下面对 16 年提出的各个计划给个小结：\n\n#### 毕业\n虽然有惊有险，比较艰难，但最终还是顺利毕业，并把户口落在了魔都。\n\n#### Android技术\n公司：个人感觉对现有的 Android 技术还算熟练，在日常开发中也没有遇到很大困难和挑战，也对一些少见的 bug 有了一定的经验，并对性能优化有了更多的认识。\n\n研究：业余时间写了三篇开源项目分析的文章。有点少，新的一年要做更多技术方面的深入研究，比如分析 Android 系统某些机制的源码；分析优质开源项目的源码。\n\n开源：去年完成了全端的 简诗 v2.0 开发，https://github.com/wingjay/jianshi，目前有 1.4k 左右的 star。对于 Android 和服务器开发有了一个较为全面的认识吧。\n\n翻译：16年底重新维护了我的个人公众号：大公司技术博客。主要对一些大公司优质的官方技术博客或者 Medium 上的好文章进行翻译推送。目前已经推送了 6 篇翻译文章。\n\n#### 机器学习\n这一方面没有做很多工作，主要是因为其入门的门槛较高，而自己又没有找到一个合理的进入方式开始学习。\n\n#### 设计与艺术\n有适当阅读一些文章，浏览一些艺术设计来提高下自己这方面的修养。不过，并未投入足够的时间。\n\n#### 英语\n英语阅读：在平常搜索问题时以英文搜索为主，而且持续不断阅读英文技术文章、翻译等等，现在基本能达到不错阅读理解水平。\n\n口语：去年报名了在线口语提高班，进行了一个月左右的课程，口语方面虽没有很大飞跃，不过现在对常用句型基本上比较熟练了。而且，2017年还会继续口语课程。\n\n#### 生活\n这一点做的不够。\n\n去年和同事开玩笑说，我是个没有生活的人。没有合理利用自己的空闲时间，如周末偶尔会做做饭，其他时候就是看看剧打打游戏，并没有很好的去感受生活。\n\n#### 体育\n一年里除了偶尔打打羽毛球，非常缺乏体育锻炼。去年年底时去办了张一年的健身卡，目前已经持续了一个月左右的健身，平均两天一次健身：半小时跑步 ＋ 半小时无氧运行。\n\n#### 健康饮食\n由于整日坐着工作，颈椎有点毛病，而且出现了肥胖的问题，身体脂肪含量高，肌肉比例偏低。采取的措施是不吃太饱 ＋ 不吃夜宵。\n\n#### 阅读\n基本没有深入读什么书籍，不够。\n\n\n## 计划 2017\n下面对 2017 做一些计划。\n\n#### 技术\n1. Java + Android研究基础。基础知识是自己的弱项，必须对 Java 和 Android 很多基础的理论进行深入的学习了解，不要只会只用 API。\n\n2. 前沿进展。了解 Android 的最新的技术，作为一名 Android 工程师，必须对 Android 最新的技术保持实时更新了解。\n\n3. AI学习。在人工智能方面可以通过阅读文章、上在线课程来进行入门。\n\n#### 开源\n对 简诗 可以再做一些新的功能，尝试一些 Android 和 服务器开发的不同的技术点，拓宽自己的技术视野。\n\n#### 公众号\n继续保持 两日一更 的节奏，可以去阅读 Medium 上的文章，Hacker News 或者 Reddit 上的讨论，各大公司的新技术文章进行阅读翻译并推送。争取一年内达到上万读者。\n\n#### 理财、金融阅读学习\n对理财和金融方面进行了解学习，自己开始理财，学习基本的金融知识。\n\n除了技术方面，今年主要要多读一些经济金融方面的书籍。了解整个社会的经济是如何发展的。\n\n#### 个人盈利\n争取把我的业余工作转化出一定的收益。比如持续去维护简诗的开发、公众号的文章推送，如果能在做这些事情的时候得到一些金钱方面的回报，就能良性地提高我的内驱动力。这样才是一个理性的业余工作方式，毕竟一味的对外输出总是容易丧失动力。\n\n盈利方案：\n\n1. 简诗 首先要继续提高新用户数和用户留存，把简诗做成世界上最干净最好用的竖排古典写作工具。然后，通过提供一些付费功能如自定义印章等，或者定制简诗风格的笔记本来进行盈利。\n\n2. 公众号 方面，先尽可能吸引聚集较多的高质量读者，对国外技术、新闻、讨论感兴趣的一批人，然后再提供一些其它的推送服务给他们。\n\n#### 生活：旅游 ＋ 体育健身 ＋ 饮食 ＋ 早起\n1. 旅游\n今年，我要至少旅游国内五座城市。要了解城市的历史，整座城市的规划，城市的经济发展方式，这座城市人民特有的民风文化。每次旅行要做好足够的准备，去有意义的地方，旅行后要有一篇文章记录。\n\n2. 体育健身\n尽可能保持每周至少 三 次健身，改善自己的脂肪和肌肉的比例，必须要恢复到正常状态。 \n\n3. 饮食\n不要花太多时间在吃方面，只要吃饱、吃健康就行，不要花太多时间在好吃的食物上。\n\n4. 早起\n为了提高阅读量，我可以每天早起一个小时来阅读文章或者金融书籍。扩充知识面，同时可以维护好公众号。\n\n#### 驾照\n如果今年时间足够，可以去考虑报名参加上海这里的驾照考试。\n\n以上是 2017 年大体的计划，之后还要进行更加详细的规划，可以参考定制自己的季度目标和每月目标来进行督促。\n\n\n\n","source":"_posts/今年之计－2017.md","raw":"title: 今年之计－2017\ndate: 2017-02-05 22:17:23\ncategories:\n  - 年度计划\ntags:\n---\n> 2017年我的计划\n\n<!-- more -->\n\n按照习惯，每一年开初都要回顾过去，制定新一年的计划。\n\n## 回顾 2016\n2016年是我的一个大年，完成了毕业和入职的交替，从学生到职场人员。\n\n下面对 16 年提出的各个计划给个小结：\n\n#### 毕业\n虽然有惊有险，比较艰难，但最终还是顺利毕业，并把户口落在了魔都。\n\n#### Android技术\n公司：个人感觉对现有的 Android 技术还算熟练，在日常开发中也没有遇到很大困难和挑战，也对一些少见的 bug 有了一定的经验，并对性能优化有了更多的认识。\n\n研究：业余时间写了三篇开源项目分析的文章。有点少，新的一年要做更多技术方面的深入研究，比如分析 Android 系统某些机制的源码；分析优质开源项目的源码。\n\n开源：去年完成了全端的 简诗 v2.0 开发，https://github.com/wingjay/jianshi，目前有 1.4k 左右的 star。对于 Android 和服务器开发有了一个较为全面的认识吧。\n\n翻译：16年底重新维护了我的个人公众号：大公司技术博客。主要对一些大公司优质的官方技术博客或者 Medium 上的好文章进行翻译推送。目前已经推送了 6 篇翻译文章。\n\n#### 机器学习\n这一方面没有做很多工作，主要是因为其入门的门槛较高，而自己又没有找到一个合理的进入方式开始学习。\n\n#### 设计与艺术\n有适当阅读一些文章，浏览一些艺术设计来提高下自己这方面的修养。不过，并未投入足够的时间。\n\n#### 英语\n英语阅读：在平常搜索问题时以英文搜索为主，而且持续不断阅读英文技术文章、翻译等等，现在基本能达到不错阅读理解水平。\n\n口语：去年报名了在线口语提高班，进行了一个月左右的课程，口语方面虽没有很大飞跃，不过现在对常用句型基本上比较熟练了。而且，2017年还会继续口语课程。\n\n#### 生活\n这一点做的不够。\n\n去年和同事开玩笑说，我是个没有生活的人。没有合理利用自己的空闲时间，如周末偶尔会做做饭，其他时候就是看看剧打打游戏，并没有很好的去感受生活。\n\n#### 体育\n一年里除了偶尔打打羽毛球，非常缺乏体育锻炼。去年年底时去办了张一年的健身卡，目前已经持续了一个月左右的健身，平均两天一次健身：半小时跑步 ＋ 半小时无氧运行。\n\n#### 健康饮食\n由于整日坐着工作，颈椎有点毛病，而且出现了肥胖的问题，身体脂肪含量高，肌肉比例偏低。采取的措施是不吃太饱 ＋ 不吃夜宵。\n\n#### 阅读\n基本没有深入读什么书籍，不够。\n\n\n## 计划 2017\n下面对 2017 做一些计划。\n\n#### 技术\n1. Java + Android研究基础。基础知识是自己的弱项，必须对 Java 和 Android 很多基础的理论进行深入的学习了解，不要只会只用 API。\n\n2. 前沿进展。了解 Android 的最新的技术，作为一名 Android 工程师，必须对 Android 最新的技术保持实时更新了解。\n\n3. AI学习。在人工智能方面可以通过阅读文章、上在线课程来进行入门。\n\n#### 开源\n对 简诗 可以再做一些新的功能，尝试一些 Android 和 服务器开发的不同的技术点，拓宽自己的技术视野。\n\n#### 公众号\n继续保持 两日一更 的节奏，可以去阅读 Medium 上的文章，Hacker News 或者 Reddit 上的讨论，各大公司的新技术文章进行阅读翻译并推送。争取一年内达到上万读者。\n\n#### 理财、金融阅读学习\n对理财和金融方面进行了解学习，自己开始理财，学习基本的金融知识。\n\n除了技术方面，今年主要要多读一些经济金融方面的书籍。了解整个社会的经济是如何发展的。\n\n#### 个人盈利\n争取把我的业余工作转化出一定的收益。比如持续去维护简诗的开发、公众号的文章推送，如果能在做这些事情的时候得到一些金钱方面的回报，就能良性地提高我的内驱动力。这样才是一个理性的业余工作方式，毕竟一味的对外输出总是容易丧失动力。\n\n盈利方案：\n\n1. 简诗 首先要继续提高新用户数和用户留存，把简诗做成世界上最干净最好用的竖排古典写作工具。然后，通过提供一些付费功能如自定义印章等，或者定制简诗风格的笔记本来进行盈利。\n\n2. 公众号 方面，先尽可能吸引聚集较多的高质量读者，对国外技术、新闻、讨论感兴趣的一批人，然后再提供一些其它的推送服务给他们。\n\n#### 生活：旅游 ＋ 体育健身 ＋ 饮食 ＋ 早起\n1. 旅游\n今年，我要至少旅游国内五座城市。要了解城市的历史，整座城市的规划，城市的经济发展方式，这座城市人民特有的民风文化。每次旅行要做好足够的准备，去有意义的地方，旅行后要有一篇文章记录。\n\n2. 体育健身\n尽可能保持每周至少 三 次健身，改善自己的脂肪和肌肉的比例，必须要恢复到正常状态。 \n\n3. 饮食\n不要花太多时间在吃方面，只要吃饱、吃健康就行，不要花太多时间在好吃的食物上。\n\n4. 早起\n为了提高阅读量，我可以每天早起一个小时来阅读文章或者金融书籍。扩充知识面，同时可以维护好公众号。\n\n#### 驾照\n如果今年时间足够，可以去考虑报名参加上海这里的驾照考试。\n\n以上是 2017 年大体的计划，之后还要进行更加详细的规划，可以参考定制自己的季度目标和每月目标来进行督促。\n\n\n\n","slug":"今年之计－2017","published":1,"updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm21002nmoyx4r9tr6dw","sticky":0},{"title":"今年之计","date":"2016-02-19T08:39:37.000Z","_content":"> 2016年我的计划\n\n<!-- more -->\n\n![今年之计](https://drscdn.500px.org/photo/40352952/q%3D80_m%3D2000/b8ea73af7f5aef17d99af0e0bf1ee1b0)\n\n结束了家中热闹的腊月，提早返回校中，好好为今年做一番规划。\n\n俗话说得好：一年之计在于春。\n\n今年两件事：\n\n1. 毕业\n2. 步入职场\n\n## 毕业\n关于毕业之事此不多言，已尽最大努力，后望一切顺利。\n\n## 职业\n对于职业能力方面，下面几点是今年的重点：\n\n#### Android技术\n1. 公司。作为一家创业公司的Android developer，今年会花大量的时间在工作中不断提高自己的android技术水平。\n\n2. 研究。工作中的技术学习一般都是任务驱动型，即以解决实际问题为最终目标，这种做法的缺陷是很多时候难以对某个问题进行深入研究。所以，之后要加强这方面的研究，即在工作中解决实际问题后应抽时间来进行细细研究，整理入博客中。\n\n3. 开源。开源项目要保持下去。记录工作中自己开发的不错的组件等积极开源，并多多维护。\n\n4. 翻译。多翻译国外优秀文章，一方面扩展视野，另一方面提高英语。\n\n#### 机器学习\n作为一门互联网职业人员，我显然明白技术的日新月异和更新换代实属必然。\n所以，在夯实Android技术之外，还应该抽出时间来学习其它技术。此处本人选择机器学习作为一个方向来充实自己，准备通过对google提供的在线课程和TensorFlow工具进行较为深入的学习。\n\n[Udacity TensorFlow by Google](udacity.com/course/deep-learning--ud730)\n[Udacity博客](blog.udacity.com/2016/01/putting-deep-learning-to-work.html)\n\n#### 设计与艺术\n无论是为了产品开发或个人审美，都值得花时间提高自己的设计艺术方面的嗅觉与敏感度。\n另外，将设计与技术结合起来，更不失为一件妙事。\n这一步主要通过阅读书籍，浏览设计网站与app来感知。\n\n这里有一些不错的资源：\n[Processing资源](http://mp.weixin.qq.com/s?__biz=MzA5OTgyMDk3Mg==&mid=402850288&idx=1&sn=9bd2856a17128c857d2b864293d0f94d&scene=23&srcid=0216rQN75xcQeFJPiNvNHdin#rd)\n\n#### 英语\n这个就不多提了，无论阅读还是口语都需要提高！\n\n上面这四点，是今年的核心。每一点都还需要细化并渗入到以后的工作学习中，争取有实质性提高。\n\n## 生活\n一个不懂的享受生活的人是悲哀的，因为他会丧失很多的幸福感。\n因此，后面我会开始注重培养自己的爱好，参加一些有意思的活动，结交一些有想法的朋友。\n\n#### 体育\n篮球羽毛球爬山户外，都是我喜欢的，希望以后在周末多抽空参与相关活动。\n平日里可以参与跑步、健身等活动。\n\n只有拥有强健体魄才能更加乐观，更加懂得感悟生活的美。\n\n#### 健康饮食\n一方面注重营养均衡，不要像以前只为好吃。（当然，好吃还是很重要哒）\n另一方面要适量，保持好的体型，拒绝肥胖。\n\n## 阅读\n下面是今年要读书籍的大类，具体还待更新：\n\n1. 技术：Android、机器学习\n2. 艺术设计\n[Nature of Code online](http://natureofcode.com/book/introduction/)\n3. 历史\n\n\n\n\n","source":"_posts/今年之计.md","raw":"title: 今年之计\ndate: 2016-02-19 16:39:37\ncategories:\n  - 年度计划\ntags: \n\t- 学习计划\n---\n> 2016年我的计划\n\n<!-- more -->\n\n![今年之计](https://drscdn.500px.org/photo/40352952/q%3D80_m%3D2000/b8ea73af7f5aef17d99af0e0bf1ee1b0)\n\n结束了家中热闹的腊月，提早返回校中，好好为今年做一番规划。\n\n俗话说得好：一年之计在于春。\n\n今年两件事：\n\n1. 毕业\n2. 步入职场\n\n## 毕业\n关于毕业之事此不多言，已尽最大努力，后望一切顺利。\n\n## 职业\n对于职业能力方面，下面几点是今年的重点：\n\n#### Android技术\n1. 公司。作为一家创业公司的Android developer，今年会花大量的时间在工作中不断提高自己的android技术水平。\n\n2. 研究。工作中的技术学习一般都是任务驱动型，即以解决实际问题为最终目标，这种做法的缺陷是很多时候难以对某个问题进行深入研究。所以，之后要加强这方面的研究，即在工作中解决实际问题后应抽时间来进行细细研究，整理入博客中。\n\n3. 开源。开源项目要保持下去。记录工作中自己开发的不错的组件等积极开源，并多多维护。\n\n4. 翻译。多翻译国外优秀文章，一方面扩展视野，另一方面提高英语。\n\n#### 机器学习\n作为一门互联网职业人员，我显然明白技术的日新月异和更新换代实属必然。\n所以，在夯实Android技术之外，还应该抽出时间来学习其它技术。此处本人选择机器学习作为一个方向来充实自己，准备通过对google提供的在线课程和TensorFlow工具进行较为深入的学习。\n\n[Udacity TensorFlow by Google](udacity.com/course/deep-learning--ud730)\n[Udacity博客](blog.udacity.com/2016/01/putting-deep-learning-to-work.html)\n\n#### 设计与艺术\n无论是为了产品开发或个人审美，都值得花时间提高自己的设计艺术方面的嗅觉与敏感度。\n另外，将设计与技术结合起来，更不失为一件妙事。\n这一步主要通过阅读书籍，浏览设计网站与app来感知。\n\n这里有一些不错的资源：\n[Processing资源](http://mp.weixin.qq.com/s?__biz=MzA5OTgyMDk3Mg==&mid=402850288&idx=1&sn=9bd2856a17128c857d2b864293d0f94d&scene=23&srcid=0216rQN75xcQeFJPiNvNHdin#rd)\n\n#### 英语\n这个就不多提了，无论阅读还是口语都需要提高！\n\n上面这四点，是今年的核心。每一点都还需要细化并渗入到以后的工作学习中，争取有实质性提高。\n\n## 生活\n一个不懂的享受生活的人是悲哀的，因为他会丧失很多的幸福感。\n因此，后面我会开始注重培养自己的爱好，参加一些有意思的活动，结交一些有想法的朋友。\n\n#### 体育\n篮球羽毛球爬山户外，都是我喜欢的，希望以后在周末多抽空参与相关活动。\n平日里可以参与跑步、健身等活动。\n\n只有拥有强健体魄才能更加乐观，更加懂得感悟生活的美。\n\n#### 健康饮食\n一方面注重营养均衡，不要像以前只为好吃。（当然，好吃还是很重要哒）\n另一方面要适量，保持好的体型，拒绝肥胖。\n\n## 阅读\n下面是今年要读书籍的大类，具体还待更新：\n\n1. 技术：Android、机器学习\n2. 艺术设计\n[Nature of Code online](http://natureofcode.com/book/introduction/)\n3. 历史\n\n\n\n\n","slug":"今年之计","published":1,"updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm24002pmoyxtkvoiyb9","sticky":0},{"title":"sjtu","date":"2016-01-02T08:31:11.000Z","_content":"> 交大像个奋进的年轻人，我觉得和我挺像。\n\n<!-- more -->\n周六，元旦刚过。\n\n校园内空空荡荡，图书馆内座无虚席。\n\n<img src=\"/img/sjtu/library.jpg\" width=\"300\">\n\n也罢，找不到座位，就出去逛逛咱交大满园的秋色吧，顺便体验一把新入手6s的照相性能。\n\n\n![](/img/sjtu/library_outside.jpg)\n\n不得不说咱的图书馆融入了“天圆地方”的建筑理念，耐看。\n\n\n![](/img/sjtu/laker.jpg)\n\n下午斜斜夕阳和静静的湖水，真想找个椅子听听音乐休憩一番\n\n![](/img/sjtu/hehua.jpg)\n\n炎炎夏日的烂漫荷花如今也破败不堪。\n\n![](/img/sjtu/tuya.jpg)\n\n交大特色涂鸦墙，记载了多少岁月的印记，和青春的不羁。\n\n![](/img/sjtu/love.jpg)\n\n校园爱情，真美。一生若能遇到一个真爱，你不得不好好珍惜。\n\n![](/img/sjtu/huxiaohe.jpg)\n\n校园内静静流淌的护校河，让我想起曾在干旱的帝都，路上连水洼都难觅。\n\n![](/img/sjtu/dom.jpg)\n\n说实话交大的住宿条件不错，空调＋套间。唯一遗憾的是住在一楼的我们很需要阳光！\n\n交大很优美，很沉静。\n\n交大的同学们很聪明，很踏实。\n\n在交大的岁月很短暂，却很珍贵。\n","source":"_posts/交大－影.md","raw":"title: sjtu\ncategories:\n  - 摄影\ntags:\n  - 摄影\ndate: 2016-01-02 16:31:11\n---\n> 交大像个奋进的年轻人，我觉得和我挺像。\n\n<!-- more -->\n周六，元旦刚过。\n\n校园内空空荡荡，图书馆内座无虚席。\n\n<img src=\"/img/sjtu/library.jpg\" width=\"300\">\n\n也罢，找不到座位，就出去逛逛咱交大满园的秋色吧，顺便体验一把新入手6s的照相性能。\n\n\n![](/img/sjtu/library_outside.jpg)\n\n不得不说咱的图书馆融入了“天圆地方”的建筑理念，耐看。\n\n\n![](/img/sjtu/laker.jpg)\n\n下午斜斜夕阳和静静的湖水，真想找个椅子听听音乐休憩一番\n\n![](/img/sjtu/hehua.jpg)\n\n炎炎夏日的烂漫荷花如今也破败不堪。\n\n![](/img/sjtu/tuya.jpg)\n\n交大特色涂鸦墙，记载了多少岁月的印记，和青春的不羁。\n\n![](/img/sjtu/love.jpg)\n\n校园爱情，真美。一生若能遇到一个真爱，你不得不好好珍惜。\n\n![](/img/sjtu/huxiaohe.jpg)\n\n校园内静静流淌的护校河，让我想起曾在干旱的帝都，路上连水洼都难觅。\n\n![](/img/sjtu/dom.jpg)\n\n说实话交大的住宿条件不错，空调＋套间。唯一遗憾的是住在一楼的我们很需要阳光！\n\n交大很优美，很沉静。\n\n交大的同学们很聪明，很踏实。\n\n在交大的岁月很短暂，却很珍贵。\n","slug":"交大－影","published":1,"updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm27002tmoyxrh24uzko","sticky":0},{"title":"一种快速毛玻璃虚化效果实现","date":"2016-03-12T01:30:50.000Z","commentIssueId":18,"_content":"> 在 Android 上也能实现毛玻璃效果？性能如何？\n\n<!-- more -->\n<img src=\"http://wingjay.com/img/fastblur/iosblur.jpg\" width=\"300\">\n\n在iOS设备上我们随处可见毛玻璃效果，而且最近越来越多的场合应用到了这种美观的虚化效果，包括本人的一个开源项目[BlureImageView](https://github.com/wingjay/BlurImageView)也是受此启发。所以，恰到好处的虚化效果能很好的改善用户体验，而且也能让你的app显得更加优雅。\n\n不过，我们目前在android上很少见到毛玻璃效果，我认为很重要的原因是性能问题，虚化一张图片所需要的时间会因设备而异，如果为了虚化使得用户需要刻意等待，那么就是弊大于利。另外，Google官方提供的renderScript一般只是做一些小幅度的虚化，很难达到毛玻璃这类深度虚化效果。\n\n所以本文的角度是能够在android设备上快速实现毛玻璃效果。\n\n\n![blur1](/img/fastblur/androidblur_1.png)\n![blur2](/img/fastblur/androidblur_2.png)\n\n### StackBlur\n首先，为了实现毛玻璃效果，本文采用的是[`StackBlur`模糊算法](http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html)，这种算法应用非常广泛，能得到非常良好的毛玻璃效果。在这里，我们使用的是它的Java实现代码[FastBlur.java](https://github.com/wingjay/BlurImageView/blob/master/blurimageviewlib/src/main/java/com/wingjay/blurimageviewlib/FastBlurUtil.java)。\n\n\tpublic static Bitmap doBlur(Bitmap sentBitmap, int radius, boolean canReuseInBitmap)\n可以看出，使用方法非常简单，传入待虚化的bitmap、虚化程序(一般为8)、和是否重用flag。\n\n然后，如果要对上面这张图片进行虚化，我们可以通过把它转化成bitmap传入虚化，看起来很简单就解决了，但事实并非如此。\n\n### OOM\n如果直接把一张大图传入，很容易就会发生OOM内存溢出\n\n\t03-11 21:02:02.014 16727-16742/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.026 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.030 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.031 16727-16727/com.wingjay.jayandroid I/art: Forcing collection of SoftReferences for 30MB allocation\n\t03-11 21:02:02.035 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.036 16727-16727/com.wingjay.jayandroid E/art: Throwing OutOfMemoryError \"Failed to allocate a 32175012 byte allocation with 2648672 free bytes and 2MB until OOM\"\n\t03-11 21:02:02.036 16727-16727/com.wingjay.jayandroid D/AndroidRuntime: Shutting down VM\n这是我直接对原图进行虚化得到的log信息。可以看出当虚化开始时，虚拟机开始不断进行内存回收，包括把所有软引用的内存回收。然而，仍然导致了内存溢出。\n\n那就意味着我只能虚化小图，这样才能防止内存溢出。但是我并不想换其他图，那么，我们就应该把这张图`缩放`。\n\n### ReScale\n\n\tpublic static Bitmap createScaledBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter) {}\n我们可以利用这个function来进行bitmap的缩放。其中前三个参数很明显，其中宽高我们可以选择为原图尺寸的1/10；第四个filter是指缩放的效果，filter为true则会得到一个边缘平滑的bitmap，反之，则会得到边缘锯齿、pixelrelated的bitmap。这里我们要对缩放的图片进行虚化，所以无所谓边缘效果，`filter=false`。\n\n所以，我们要使用\n\n\tint scaleRatio = 10;\n\tint blurRadius = 8;\n\tBitmap scaledBitmap = Bitmap.createScaledBitmap(originBitmap,\n        originBitmap.getWidth() / scaleRatio,\n        originBitmap.getHeight() / scaleRatio,\n        false);\n\tBitmap blurBitmap = FastBlur.doBlur(scaledBitmap, blurRadius, true);\n    imageView.setScaleType(ImageView.ScaleType.CENTER_CROP);\n    imageView.setImageBitmap(blurBitmap);\n可以得到如下效果:\n![scaleRatio_10](/img/fastblur/fastblur_10.png)\n\n从图中可以看出，首先可以确定思路是对的；然后，可以看出毛玻璃效果还不是特别的明显。为了得到如iOS那样的虚化效果，我们有两种方法：\n\n- 增大scaleRatio缩放比，使用一样更小的bitmap去虚化可以得到更好的模糊效果，而且有利于占用内存的减小；\n- 增大blurRadius，可以得到更高程度的虚化，不过会导致CPU更加intensive\n\n这里本人通过`增大缩放比`来实验。\n\n- scaleRatio = 20\n![scaleRatio_20](/img/fastblur/fastblur_20.png)\n- scaleRatio = 35\n![scaleRatio_35](/img/fastblur/fastblur_35.png)\n- scaleRatio = 50\n![scaleRatio_50](/img/fastblur/fastblur_50.png)\n- scaleRatio = 100\n![scaleRatio_100](/img/fastblur/fastblur_100.png)\n\n通过上面对比图我们可以找出最适合自己的虚化效果。\n\n### Performance analysis\n那么，要实现这样的效果，是否具有损害用户体验的风险呢？下面，我们从`消耗时间`和`占据内存`的角度来进行分析。\n\n#### Time Consuming\n为了分析虚化一张图片所消耗的时间，本文通过同时虚化`100`来获取平均消耗时间。以期对虚化耗时和不同缩放比对耗时的影响得到一定的认识。\n\n\tlong start = System.currentTimeMillis();\n    Bitmap scaledBitmap, blurBitmap;\n    int scaleRatio = 10;\n    int loopCount = 100\n    for (int i=0; i<loopCount; i++) {\n      scaledBitmap = Bitmap.createScaledBitmap(originBitmap,\n          originBitmap.getWidth() / scaleRatio,\n          originBitmap.getHeight() / scaleRatio,\n          false);\n      blurBitmap = FastBlur.doBlur(scaledBitmap, 8, true);\n    }\n    Log.i(\"blurtime\", String.valueOf(System.currentTimeMillis() - start));\n\n- scaleRatio = 10: 耗时`887ms`，平均耗时`8.87ms`;\n- scaleRatio = 20: 耗时`224ms`，平均耗时`2.24ms`;\n- scaleRatio = 35: 耗时`99ms`，平均耗时`0.99ms`;\n- scaleRatio = 50: 耗时`55ms`，平均耗时`0.55ms`;\n- scaleRatio = 100: 耗时`29ms`，平均耗时`0.29ms`;\n\n为了方便读者了解效果，我通过多组数据拟合了下面的曲线：\n![](/img/fastblur/timeconsume_statisic.png)\n\n从该模拟图可以看出时间随着缩放比的增大而不断减小，当缩放比达到30以上时所消耗的时间不到1ms，因此，我认为应该是完全不会产生时延破坏用户体验的。\n\n#### Memory Consuming\n既然时间没问题，那么，主要问题：内存占用就来了，所以我们需要考察生成一张虚化图片所占用的内存。\n\n为了测试对一张图片进行虚化所占用内存的变化，我们改变虚化次数，即修改上面的`loopCount`并观察对内存的变化。其中scaleRatio = 10，以获得相对较大的内存消耗。\n\n- loopCount = 1\n![](/img/fastblur/memory_1.png)\n- loopCount = 10\n![](/img/fastblur/memory_10.png)\n- loopCount = 20\n![](/img/fastblur/memory_20.png)\n- loopCount = 50\n![](/img/fastblur/memory_50.png)\n- loopCount = 100\n![](/img/fastblur/memory_100.png)\n- loopCount = 300\n![](/img/fastblur/memory_300.png)\n\n从上面的内存消耗图，可以看出虚化的确会占用一定内存，如果大量的虚化同时发生，则会由于UI线程突然加载很多bitmap而导致内存抖动。\n\n#### Conclusion\n希望大家如果有其他测试方法或者意见多多留言，从而继续改进性能。\n\n附上本文所采用的![测试图](/img/fastblur/test_pic.jpeg)\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n","source":"_posts/一种快速毛玻璃虚化效果实现.md","raw":"title: 一种快速毛玻璃虚化效果实现\ndate: 2016-03-12 09:30:50\ncategories:\n  - Android\n  - Performance\ntags:\n\t- Android\ncommentIssueId: 18  \n---\n> 在 Android 上也能实现毛玻璃效果？性能如何？\n\n<!-- more -->\n<img src=\"http://wingjay.com/img/fastblur/iosblur.jpg\" width=\"300\">\n\n在iOS设备上我们随处可见毛玻璃效果，而且最近越来越多的场合应用到了这种美观的虚化效果，包括本人的一个开源项目[BlureImageView](https://github.com/wingjay/BlurImageView)也是受此启发。所以，恰到好处的虚化效果能很好的改善用户体验，而且也能让你的app显得更加优雅。\n\n不过，我们目前在android上很少见到毛玻璃效果，我认为很重要的原因是性能问题，虚化一张图片所需要的时间会因设备而异，如果为了虚化使得用户需要刻意等待，那么就是弊大于利。另外，Google官方提供的renderScript一般只是做一些小幅度的虚化，很难达到毛玻璃这类深度虚化效果。\n\n所以本文的角度是能够在android设备上快速实现毛玻璃效果。\n\n\n![blur1](/img/fastblur/androidblur_1.png)\n![blur2](/img/fastblur/androidblur_2.png)\n\n### StackBlur\n首先，为了实现毛玻璃效果，本文采用的是[`StackBlur`模糊算法](http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html)，这种算法应用非常广泛，能得到非常良好的毛玻璃效果。在这里，我们使用的是它的Java实现代码[FastBlur.java](https://github.com/wingjay/BlurImageView/blob/master/blurimageviewlib/src/main/java/com/wingjay/blurimageviewlib/FastBlurUtil.java)。\n\n\tpublic static Bitmap doBlur(Bitmap sentBitmap, int radius, boolean canReuseInBitmap)\n可以看出，使用方法非常简单，传入待虚化的bitmap、虚化程序(一般为8)、和是否重用flag。\n\n然后，如果要对上面这张图片进行虚化，我们可以通过把它转化成bitmap传入虚化，看起来很简单就解决了，但事实并非如此。\n\n### OOM\n如果直接把一张大图传入，很容易就会发生OOM内存溢出\n\n\t03-11 21:02:02.014 16727-16742/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.026 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.030 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.031 16727-16727/com.wingjay.jayandroid I/art: Forcing collection of SoftReferences for 30MB allocation\n\t03-11 21:02:02.035 16727-16727/com.wingjay.jayandroid I/art: Clamp target GC heap from 109MB to 96MB\n\t03-11 21:02:02.036 16727-16727/com.wingjay.jayandroid E/art: Throwing OutOfMemoryError \"Failed to allocate a 32175012 byte allocation with 2648672 free bytes and 2MB until OOM\"\n\t03-11 21:02:02.036 16727-16727/com.wingjay.jayandroid D/AndroidRuntime: Shutting down VM\n这是我直接对原图进行虚化得到的log信息。可以看出当虚化开始时，虚拟机开始不断进行内存回收，包括把所有软引用的内存回收。然而，仍然导致了内存溢出。\n\n那就意味着我只能虚化小图，这样才能防止内存溢出。但是我并不想换其他图，那么，我们就应该把这张图`缩放`。\n\n### ReScale\n\n\tpublic static Bitmap createScaledBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter) {}\n我们可以利用这个function来进行bitmap的缩放。其中前三个参数很明显，其中宽高我们可以选择为原图尺寸的1/10；第四个filter是指缩放的效果，filter为true则会得到一个边缘平滑的bitmap，反之，则会得到边缘锯齿、pixelrelated的bitmap。这里我们要对缩放的图片进行虚化，所以无所谓边缘效果，`filter=false`。\n\n所以，我们要使用\n\n\tint scaleRatio = 10;\n\tint blurRadius = 8;\n\tBitmap scaledBitmap = Bitmap.createScaledBitmap(originBitmap,\n        originBitmap.getWidth() / scaleRatio,\n        originBitmap.getHeight() / scaleRatio,\n        false);\n\tBitmap blurBitmap = FastBlur.doBlur(scaledBitmap, blurRadius, true);\n    imageView.setScaleType(ImageView.ScaleType.CENTER_CROP);\n    imageView.setImageBitmap(blurBitmap);\n可以得到如下效果:\n![scaleRatio_10](/img/fastblur/fastblur_10.png)\n\n从图中可以看出，首先可以确定思路是对的；然后，可以看出毛玻璃效果还不是特别的明显。为了得到如iOS那样的虚化效果，我们有两种方法：\n\n- 增大scaleRatio缩放比，使用一样更小的bitmap去虚化可以得到更好的模糊效果，而且有利于占用内存的减小；\n- 增大blurRadius，可以得到更高程度的虚化，不过会导致CPU更加intensive\n\n这里本人通过`增大缩放比`来实验。\n\n- scaleRatio = 20\n![scaleRatio_20](/img/fastblur/fastblur_20.png)\n- scaleRatio = 35\n![scaleRatio_35](/img/fastblur/fastblur_35.png)\n- scaleRatio = 50\n![scaleRatio_50](/img/fastblur/fastblur_50.png)\n- scaleRatio = 100\n![scaleRatio_100](/img/fastblur/fastblur_100.png)\n\n通过上面对比图我们可以找出最适合自己的虚化效果。\n\n### Performance analysis\n那么，要实现这样的效果，是否具有损害用户体验的风险呢？下面，我们从`消耗时间`和`占据内存`的角度来进行分析。\n\n#### Time Consuming\n为了分析虚化一张图片所消耗的时间，本文通过同时虚化`100`来获取平均消耗时间。以期对虚化耗时和不同缩放比对耗时的影响得到一定的认识。\n\n\tlong start = System.currentTimeMillis();\n    Bitmap scaledBitmap, blurBitmap;\n    int scaleRatio = 10;\n    int loopCount = 100\n    for (int i=0; i<loopCount; i++) {\n      scaledBitmap = Bitmap.createScaledBitmap(originBitmap,\n          originBitmap.getWidth() / scaleRatio,\n          originBitmap.getHeight() / scaleRatio,\n          false);\n      blurBitmap = FastBlur.doBlur(scaledBitmap, 8, true);\n    }\n    Log.i(\"blurtime\", String.valueOf(System.currentTimeMillis() - start));\n\n- scaleRatio = 10: 耗时`887ms`，平均耗时`8.87ms`;\n- scaleRatio = 20: 耗时`224ms`，平均耗时`2.24ms`;\n- scaleRatio = 35: 耗时`99ms`，平均耗时`0.99ms`;\n- scaleRatio = 50: 耗时`55ms`，平均耗时`0.55ms`;\n- scaleRatio = 100: 耗时`29ms`，平均耗时`0.29ms`;\n\n为了方便读者了解效果，我通过多组数据拟合了下面的曲线：\n![](/img/fastblur/timeconsume_statisic.png)\n\n从该模拟图可以看出时间随着缩放比的增大而不断减小，当缩放比达到30以上时所消耗的时间不到1ms，因此，我认为应该是完全不会产生时延破坏用户体验的。\n\n#### Memory Consuming\n既然时间没问题，那么，主要问题：内存占用就来了，所以我们需要考察生成一张虚化图片所占用的内存。\n\n为了测试对一张图片进行虚化所占用内存的变化，我们改变虚化次数，即修改上面的`loopCount`并观察对内存的变化。其中scaleRatio = 10，以获得相对较大的内存消耗。\n\n- loopCount = 1\n![](/img/fastblur/memory_1.png)\n- loopCount = 10\n![](/img/fastblur/memory_10.png)\n- loopCount = 20\n![](/img/fastblur/memory_20.png)\n- loopCount = 50\n![](/img/fastblur/memory_50.png)\n- loopCount = 100\n![](/img/fastblur/memory_100.png)\n- loopCount = 300\n![](/img/fastblur/memory_300.png)\n\n从上面的内存消耗图，可以看出虚化的确会占用一定内存，如果大量的虚化同时发生，则会由于UI线程突然加载很多bitmap而导致内存抖动。\n\n#### Conclusion\n希望大家如果有其他测试方法或者意见多多留言，从而继续改进性能。\n\n附上本文所采用的![测试图](/img/fastblur/test_pic.jpeg)\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n","slug":"一种快速毛玻璃虚化效果实现","published":1,"updated":"2017-06-23T04:10:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm2b002ymoyxwsslb9cs","sticky":0},{"title":"Walk in ShangHai","date":"2016-07-10T08:11:38.000Z","_content":" \n> 魔都是座有趣的城市，每条街道都有故事。\n\n<!-- more -->\n\n天气：阴\n目的地：淮海中路＋陕西南路\n\n<img src=\"http://wingjay.com/img/walk_in_sh/1.JPG\">\n\n\n<img src=\"http://wingjay.com/img/walk_in_sh/2.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/3.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/4.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/5.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/6.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/7.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/8.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/10.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/11.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/12.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/13.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/14.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/15.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/16.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/17.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/18.JPG\">\n\n每座城市，都有自己独特的魅力。","source":"_posts/Walk-in-ShangHai.md","raw":"title: Walk in ShangHai\ndate: 2016-07-10 16:11:38\ncategories:\n  - 摄影\ntags:\n\t- 摄影\n---\n \n> 魔都是座有趣的城市，每条街道都有故事。\n\n<!-- more -->\n\n天气：阴\n目的地：淮海中路＋陕西南路\n\n<img src=\"http://wingjay.com/img/walk_in_sh/1.JPG\">\n\n\n<img src=\"http://wingjay.com/img/walk_in_sh/2.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/3.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/4.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/5.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/6.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/7.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/8.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/10.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/11.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/12.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/13.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/14.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/15.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/16.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/17.JPG\">\n<img src=\"http://wingjay.com/img/walk_in_sh/18.JPG\">\n\n每座城市，都有自己独特的魅力。","slug":"Walk-in-ShangHai","published":1,"updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm2h0032moyx8v030xb1","sticky":0},{"title":"RxLifecycle 源码解析－当 Activity 被 destory 时自动停掉网络请求","date":"2016-07-14T12:50:37.000Z","commentIssueId":15,"_content":"\n> 私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。\n此次来分享下 RxLifecycle 源码的分析。\n\n<!-- more -->\n**此文需要读者对RxJava有一定了解**\n\n## 一、 介绍\n本文分析思路不是从源码里抽代码出来一步步跟踪，而是提出问题，一步步思考解决方法，从而学习到开源项目的思维精华，而不仅仅是了解该项目的具体实现。笔者认为这种方式更有利于读者提高自身思维方式和技术能力。\n\n## 二、 开源项目\n[RxLifecycle](https://github.com/trello/RxLifecycle) 地址：https://github.com/trello/RxLifecycle 。该项目是为了防止`RxJava`中`subscription`导致内存泄漏而诞生的，核心思想是通过监听`Activity`、`Fragment`的生命周期，来自动断开`subscription`以防止内存泄漏。\n\n基本用法如下：\n```java\nmyObservable\n    .compose(RxLifecycle.bindUntilEvent(lifecycle, ActivityEvent.DESTROY))\n    .subscribe();\n```\n此处`myObservable`可以看成一个耗时的网络请求，通过绑定到`ActivityEvent.DESTROY`，一旦Activity发生了`DESTORY`生命周期，数据就不会再流向`subscriber`，即不会对这些数据进行任何处理和UI绘制，从而提高安全性。\n\n\n\n## 三、 问题\nAndroid开发中常会有这样一个场景：\n1. 发送网络请求 -> 2. 服务器处理请求并返回数据 -> 3. client端接收数据，绘制UI。\n\n在前两步一般都是不会出现问题的，但是在第三步，当数据返回给client端时，如果页面已经不在了，那么就无法去绘制UI，很有可能会导致意向不到的问题。因此，为了解决这个问题，一个好的思路就是`当页面离开时，自动断开网络请求数据的处理过程，即数据返回后不再进行任何处理`。\n\n\n## 四、 思考\n要达到上面这样一个功能，我们可以思考，至少需要两部分：\n1. 随时监听`Activity`(`Fragment`)的生命周期并对外发射出去；\n2. 在我们的网络请求中，接收生命周期并进行判断，如果该生命周期是自己绑定的，如`Destory`，那么就断开数据向下传递的过程。\n\n## 五、 分析\n可以看到，首先有一个核心功能要实现：就是既能够监听`Activity`生命周期事件并对外发射，又能够接收每一个生命周期事件并作出判断。为了实现这个功能，可以联想到`RxJava`中的`Subject`，既能够发射数据，又能够接收数据。\n\n## 六、 Subject解析\n了解`Subject`的读者可以跳过这部分。\n\n如何理解`Subject`呢？\n\n很容易，在RxJava里面，`Observable`是数据的发射者，它会对外发射数据，然后经过`map`、`flatmap`等等数据处理后，最终传递给`Observer`，这个数据接收者。因此，抛开中间数据处理不管，可以看出，`Observable`对外发射数据，是数据流的开端；`Observer`接收数据，是数据流的末端。\n\n那么`Subject`呢？看一眼源码：\n```\n/**\n * Represents an object that is both an Observable and an Observer.\n */\npublic abstract class Subject<T, R> extends Observable<R> implements Observer<T> {}\n```\n首先，它`extends Observable<R>`，说明`Subject`具备了对外发射数据的能力，即拥有了`from()`、`just()`等等；另外，它又`implements Observer<T>`，说明又能够处理数据，具备`onNext()`、`onCompleted`等等。\n\n然后，`Subject`毕竟只是一个抽象类，那么我们要如何使用它呢？\n\n这里介绍一种最简单的：`PublishSubject`:\n```\n  PublishSubject<Object> subject = PublishSubject.create();\n  // myObserver will receive \"one\" & \"two\" and onCompleted events\n  subject.subscribe(myObserver);\n  subject.onNext(\"one\");\n  subject.onNext(\"two\");\n  subject.onCompleted();\n```\n这里做的事情很简单，先创建一个`PublishSubject` -> 绑定一个`myObserver`，此时`subject`扮演了`Observable`的角色，把数据发射给`myObserver` -> 然后`subject`处理接收了两个数据`one`、`two` -> 最终这些数据都传递给了`myObserver`。所以，`subject`扮演的角色是:\n\n**数据`one`、`two`   =>   (Observer) `subject` (Observable)   =>   `myObserver`**\n\n简单来说，我们把数据`one`、`two`塞给`subject`，然后`subject`又发射给了`myObserver`。\n\n## 七、 BaseActivity监听生命周期\n那么我们先来实现生命周期监听功能，基本思路是：在`BaseActivity`里创建一个`PublishSubject`对象，在每个生命周期发生时，把该生命周期事件传递给`PublishSubject`。具体实现如下(只写部分生命周期，其他类似)：\n```java\nclass BaseActivity {\n\t\n\tprotected final PublishSubject<ActivityLifeCycleEvent> lifecycleSubject = PublishSubject.create();\n\n\t@Override\n  \tprotected void onCreate(Bundle savedInstanceState) {\n  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.CREATE);\n  \t\t...\n  \t}\n\n  \t@Override\n  \tprotected void onPause() {\n  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.PAUSE);\n  \t\t...\n  \t}\n\n  \t@Override\n  \tprotected void onStop() {\n  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.STOP);\n  \t\t...\n  \t}\n  \t...\n}\n```\n这样的话，我们把所有生命周期事件都传给了`lifecycleSubject`了，或者说，`lifecycleSubject`已经接收到了并能够`对外发射各种生命周期事件`的能力了。\n\n## 八、 改良每一个Observable，接收生命周期并自动断开自身\n通常我们的一次网络请求长这样：\n```java\nnetworkObservable\n\t.subscribe(new Observer(  handleUI()  ));\n```\n其中，`networkObservable`表示一个通用的网络请求，会接收网络数据并传递给`Observer`去绘制UI。\n\n现在，我们希望这个`networkObservable`监听`Activity`的`DESTORY`事件，一旦发生了`DESTORY`就自动断开`Observer`，即使网络数据回来了也不再传递给`Observer`去绘制UI。即：\n```java\nnetworkObservable\n\t.compose(bindUntilEvent(ActivityLifeCycleEvent.DESTORY))\n\t.subscribe(new Observer(  handleUI()  ));\n```\n因此，我们需要实现\n```java\nbindUntilEvent(ActivityLifeCycleEvent.DESTORY)\n```\n这个方法，那如何实现呢？\n\n我们知道`lifecycleSubject`能够发射生命周期事件了，那么我们可以让`networkObservable`去检查`lifecycleSubject`发出的生命周期，如果和自己绑定的生命周期事件一样，那就自动停掉即可。\n\n## 九、 改装networkObservable\n对于`networkObservable自动停掉`，我们可以利用操作符\n```\nnetworkObservable.takeUntil(otherObservable)\n```\n它的作用是监听`otherObservable`，一旦`otherObservable`对外发射了数据，就自动把`networkObservable`停掉；\n\n那`otherObservable`何时对外发射数据呢？当然是`lifecycleSubject`发射出的生命周期事件`等于`绑定的生命周期事件时，开始发射。\n```java\n\totherObservable = lifecycleSubject.takeFirst(new Func1<ActivityLifeCycleEvent, Boolean>() {\n              @Override\n              public Boolean call(ActivityLifeCycleEvent activityLifeCycleEvent) {\n                return activityLifeCycleEvent.equals(bindEvent);\n              }\n            });\n```\n其中的关键是判断`activityLifeCycleEvent.equals(bindEvent);`，一旦条件满足，`otherObservable`就对外发射数据，然后`networkObservable`就立即自动停掉。\n\n## 十、 合并 生命周期监听 与 networkObservable改良\n1. 在BaseActivity里添加`lifecycleSubject`，并把每一个生命周期事件按时传递给`lifecycleSubject`\n2. 在BaseActivity里添加一个`bindUntilEvent`方法:\n```java\n  @NonNull\n  @Override\n  public <T> Observable.Transformer<T, T> bindUntilEvent(@NonNull final ActivityLifeCycleEvent event) {\n    return new Observable.Transformer<T, T>() {\n      @Override\n      public Observable<T> call(Observable<T> sourceObservable) {\n        Observable<ActivityLifeCycleEvent> compareLifecycleObservable =\n            lifecycleSubject.takeFirst(new Func1<ActivityLifeCycleEvent, Boolean>() {\n              @Override\n              public Boolean call(ActivityLifeCycleEvent activityLifeCycleEvent) {\n                return activityLifeCycleEvent.equals(event);\n              }\n            });\n        return sourceObservable.takeUntil(compareLifecycleObservable);\n      }\n    };\n  }\n```\n\n3. 在任意一个网络请求 networkObservable 处改良\n```\nnetworkObservable\n\t.compose(bindUntilEvent(ActivityLifeCycleEvent.DESTORY))\n\t.subscribe(new Observer(  handleUI()  ));\n```\n\n## 注意：\n1. 文中提到的`networkObservable`是网络请求，但实际上这不限于网络请求，任何耗时操作如文件io操作等都可以利用这个方法，来监听生命周期并自动暂停。\n2. 对于Fragment中的处理方法也是类似。\n\n\n谢谢！\n\nwingjay\n---\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n","source":"_posts/RxLifecycle源码解析－当Activity被destory时自动暂停网络请求.md","raw":"title: RxLifecycle源码解析－当Activity被destory时自动停掉网络请求\ndate: 2016-07-14 20:50:37\ncategories:\n  - Android\n  - 带你学开源项目\ntags: \n\t- Android\n\t- RxJava \n  - 带你学开源项目\ncommentIssueId: 15  \n---\n\n> 私以为，阅读开源项目是与世界级技术大牛直接对话的最好方式。\n此次来分享下 RxLifecycle 源码的分析。\n\n<!-- more -->\n**此文需要读者对RxJava有一定了解**\n\n## 一、 介绍\n本文分析思路不是从源码里抽代码出来一步步跟踪，而是提出问题，一步步思考解决方法，从而学习到开源项目的思维精华，而不仅仅是了解该项目的具体实现。笔者认为这种方式更有利于读者提高自身思维方式和技术能力。\n\n## 二、 开源项目\n[RxLifecycle](https://github.com/trello/RxLifecycle) 地址：https://github.com/trello/RxLifecycle 。该项目是为了防止`RxJava`中`subscription`导致内存泄漏而诞生的，核心思想是通过监听`Activity`、`Fragment`的生命周期，来自动断开`subscription`以防止内存泄漏。\n\n基本用法如下：\n```java\nmyObservable\n    .compose(RxLifecycle.bindUntilEvent(lifecycle, ActivityEvent.DESTROY))\n    .subscribe();\n```\n此处`myObservable`可以看成一个耗时的网络请求，通过绑定到`ActivityEvent.DESTROY`，一旦Activity发生了`DESTORY`生命周期，数据就不会再流向`subscriber`，即不会对这些数据进行任何处理和UI绘制，从而提高安全性。\n\n\n\n## 三、 问题\nAndroid开发中常会有这样一个场景：\n1. 发送网络请求 -> 2. 服务器处理请求并返回数据 -> 3. client端接收数据，绘制UI。\n\n在前两步一般都是不会出现问题的，但是在第三步，当数据返回给client端时，如果页面已经不在了，那么就无法去绘制UI，很有可能会导致意向不到的问题。因此，为了解决这个问题，一个好的思路就是`当页面离开时，自动断开网络请求数据的处理过程，即数据返回后不再进行任何处理`。\n\n\n## 四、 思考\n要达到上面这样一个功能，我们可以思考，至少需要两部分：\n1. 随时监听`Activity`(`Fragment`)的生命周期并对外发射出去；\n2. 在我们的网络请求中，接收生命周期并进行判断，如果该生命周期是自己绑定的，如`Destory`，那么就断开数据向下传递的过程。\n\n## 五、 分析\n可以看到，首先有一个核心功能要实现：就是既能够监听`Activity`生命周期事件并对外发射，又能够接收每一个生命周期事件并作出判断。为了实现这个功能，可以联想到`RxJava`中的`Subject`，既能够发射数据，又能够接收数据。\n\n## 六、 Subject解析\n了解`Subject`的读者可以跳过这部分。\n\n如何理解`Subject`呢？\n\n很容易，在RxJava里面，`Observable`是数据的发射者，它会对外发射数据，然后经过`map`、`flatmap`等等数据处理后，最终传递给`Observer`，这个数据接收者。因此，抛开中间数据处理不管，可以看出，`Observable`对外发射数据，是数据流的开端；`Observer`接收数据，是数据流的末端。\n\n那么`Subject`呢？看一眼源码：\n```\n/**\n * Represents an object that is both an Observable and an Observer.\n */\npublic abstract class Subject<T, R> extends Observable<R> implements Observer<T> {}\n```\n首先，它`extends Observable<R>`，说明`Subject`具备了对外发射数据的能力，即拥有了`from()`、`just()`等等；另外，它又`implements Observer<T>`，说明又能够处理数据，具备`onNext()`、`onCompleted`等等。\n\n然后，`Subject`毕竟只是一个抽象类，那么我们要如何使用它呢？\n\n这里介绍一种最简单的：`PublishSubject`:\n```\n  PublishSubject<Object> subject = PublishSubject.create();\n  // myObserver will receive \"one\" & \"two\" and onCompleted events\n  subject.subscribe(myObserver);\n  subject.onNext(\"one\");\n  subject.onNext(\"two\");\n  subject.onCompleted();\n```\n这里做的事情很简单，先创建一个`PublishSubject` -> 绑定一个`myObserver`，此时`subject`扮演了`Observable`的角色，把数据发射给`myObserver` -> 然后`subject`处理接收了两个数据`one`、`two` -> 最终这些数据都传递给了`myObserver`。所以，`subject`扮演的角色是:\n\n**数据`one`、`two`   =>   (Observer) `subject` (Observable)   =>   `myObserver`**\n\n简单来说，我们把数据`one`、`two`塞给`subject`，然后`subject`又发射给了`myObserver`。\n\n## 七、 BaseActivity监听生命周期\n那么我们先来实现生命周期监听功能，基本思路是：在`BaseActivity`里创建一个`PublishSubject`对象，在每个生命周期发生时，把该生命周期事件传递给`PublishSubject`。具体实现如下(只写部分生命周期，其他类似)：\n```java\nclass BaseActivity {\n\t\n\tprotected final PublishSubject<ActivityLifeCycleEvent> lifecycleSubject = PublishSubject.create();\n\n\t@Override\n  \tprotected void onCreate(Bundle savedInstanceState) {\n  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.CREATE);\n  \t\t...\n  \t}\n\n  \t@Override\n  \tprotected void onPause() {\n  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.PAUSE);\n  \t\t...\n  \t}\n\n  \t@Override\n  \tprotected void onStop() {\n  \t\tlifecycleSubject.onNext(ActivityLifeCycleEvent.STOP);\n  \t\t...\n  \t}\n  \t...\n}\n```\n这样的话，我们把所有生命周期事件都传给了`lifecycleSubject`了，或者说，`lifecycleSubject`已经接收到了并能够`对外发射各种生命周期事件`的能力了。\n\n## 八、 改良每一个Observable，接收生命周期并自动断开自身\n通常我们的一次网络请求长这样：\n```java\nnetworkObservable\n\t.subscribe(new Observer(  handleUI()  ));\n```\n其中，`networkObservable`表示一个通用的网络请求，会接收网络数据并传递给`Observer`去绘制UI。\n\n现在，我们希望这个`networkObservable`监听`Activity`的`DESTORY`事件，一旦发生了`DESTORY`就自动断开`Observer`，即使网络数据回来了也不再传递给`Observer`去绘制UI。即：\n```java\nnetworkObservable\n\t.compose(bindUntilEvent(ActivityLifeCycleEvent.DESTORY))\n\t.subscribe(new Observer(  handleUI()  ));\n```\n因此，我们需要实现\n```java\nbindUntilEvent(ActivityLifeCycleEvent.DESTORY)\n```\n这个方法，那如何实现呢？\n\n我们知道`lifecycleSubject`能够发射生命周期事件了，那么我们可以让`networkObservable`去检查`lifecycleSubject`发出的生命周期，如果和自己绑定的生命周期事件一样，那就自动停掉即可。\n\n## 九、 改装networkObservable\n对于`networkObservable自动停掉`，我们可以利用操作符\n```\nnetworkObservable.takeUntil(otherObservable)\n```\n它的作用是监听`otherObservable`，一旦`otherObservable`对外发射了数据，就自动把`networkObservable`停掉；\n\n那`otherObservable`何时对外发射数据呢？当然是`lifecycleSubject`发射出的生命周期事件`等于`绑定的生命周期事件时，开始发射。\n```java\n\totherObservable = lifecycleSubject.takeFirst(new Func1<ActivityLifeCycleEvent, Boolean>() {\n              @Override\n              public Boolean call(ActivityLifeCycleEvent activityLifeCycleEvent) {\n                return activityLifeCycleEvent.equals(bindEvent);\n              }\n            });\n```\n其中的关键是判断`activityLifeCycleEvent.equals(bindEvent);`，一旦条件满足，`otherObservable`就对外发射数据，然后`networkObservable`就立即自动停掉。\n\n## 十、 合并 生命周期监听 与 networkObservable改良\n1. 在BaseActivity里添加`lifecycleSubject`，并把每一个生命周期事件按时传递给`lifecycleSubject`\n2. 在BaseActivity里添加一个`bindUntilEvent`方法:\n```java\n  @NonNull\n  @Override\n  public <T> Observable.Transformer<T, T> bindUntilEvent(@NonNull final ActivityLifeCycleEvent event) {\n    return new Observable.Transformer<T, T>() {\n      @Override\n      public Observable<T> call(Observable<T> sourceObservable) {\n        Observable<ActivityLifeCycleEvent> compareLifecycleObservable =\n            lifecycleSubject.takeFirst(new Func1<ActivityLifeCycleEvent, Boolean>() {\n              @Override\n              public Boolean call(ActivityLifeCycleEvent activityLifeCycleEvent) {\n                return activityLifeCycleEvent.equals(event);\n              }\n            });\n        return sourceObservable.takeUntil(compareLifecycleObservable);\n      }\n    };\n  }\n```\n\n3. 在任意一个网络请求 networkObservable 处改良\n```\nnetworkObservable\n\t.compose(bindUntilEvent(ActivityLifeCycleEvent.DESTORY))\n\t.subscribe(new Observer(  handleUI()  ));\n```\n\n## 注意：\n1. 文中提到的`networkObservable`是网络请求，但实际上这不限于网络请求，任何耗时操作如文件io操作等都可以利用这个方法，来监听生命周期并自动暂停。\n2. 对于Fragment中的处理方法也是类似。\n\n\n谢谢！\n\nwingjay\n---\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n","slug":"RxLifecycle源码解析－当Activity被destory时自动暂停网络请求","published":1,"updated":"2017-06-23T04:08:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm2j0035moyxmyawhsrg","sticky":0},{"title":"Java 里如何实现线程间通信？","date":"2017-04-09T09:24:06.000Z","commentIssueId":7,"_content":"> 正常情况下，每个子线程完成各自的任务就可以结束了。不过有的时候，我们希望多个线程协同工作来完成某个任务，这时就涉及到了线程间通信了。\n\n> 本文涉及到的知识点：`thread.join()`, `object.wait()`, `object.notify()`, `CountdownLatch`, `CyclicBarrier`, `FutureTask`, `Callable` 等。\n\n> 本文涉及代码：\nhttps://github.com/wingjay/HelloJava/blob/master/multi-thread/src/ForArticle.java\n\n<!-- more -->\n\n下面我从几个例子作为切入点来讲解下 Java 里有哪些方法来实现线程间通信。\n\n- 如何让两个线程依次执行？\n- 那如何让`两`个线程按照指定方式有序交叉运行呢？\n- 四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的\n- 三个运动员各自准备，等到三个人都准备好后，再一起跑\n- 子线程完成某件任务后，把得到的结果回传给主线程\n\n\n## 如何让两个线程依次执行？\n假设有两个线程，一个是线程 A，另一个是线程 B，两个线程分别依次打印 1-3 三个数字即可。我们来看下代码：\n```\nprivate static void demo1() {\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            printNumber(\"A\");\n        }\n    });\n\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            printNumber(\"B\");\n        }\n    });\n\n    A.start();\n    B.start();\n}\n```\n其中的 `printNumber(String)` 实现如下，用来依次打印 `1`, `2`, `3` 三个数字：\n```\nprivate static void printNumber(String threadName) {\n    int i=0;\n    while (i++ < 3) {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(threadName + \" print: \" + i);\n    }\n}\n```\n\n这时我们得到的结果是：\n>B print: 1\nA print: 1\nB print: 2\nA print: 2\nB print: 3\nA print: 3\n\n可以看到 A 和 B 是同时打印的。\n\n那么，如果我们希望 B 在 A `全部打印`完后再开始打印呢？我们可以利用 `thread.join()` 方法，代码如下:\n```\nprivate static void demo2() {\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            printNumber(\"A\");\n        }\n    });\n\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n        \tSystem.out.println(\"B 开始等待 A\");\n            try {\n                A.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            printNumber(\"B\");\n        }\n    });\n\n    B.start();\n    A.start();\n}\n```\n\n得到的结果如下：\n\n>B 开始等待 A\nA print: 1\nA print: 2\nA print: 3\n\n>B print: 1\nB print: 2\nB print: 3\n\n所以我们能看到 `A.join()` 方法会让 B 一直等待直到 A 运行完毕。\n\n## 那如何让`两`个线程按照指定方式有序交叉运行呢？\n还是上面那个例子，我现在希望 A 在打印完 `1` 后，再让 B 打印 `1`, `2`, `3`，最后再回到 A 继续打印 `2`, `3`。这种需求下，显然 `Thread.join()` 已经不能满足了。我们需要更细粒度的锁来控制执行顺序。\n\n这里，我们可以利用 `object.wait()` 和 `object.notify()` 两个方法来实现。代码如下：\n```\n/**\n * A 1, B 1, B 2, B 3, A 2, A 3\n */\nprivate static void demo3() {\n    Object lock = new Object();\n\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            synchronized (lock) {\n                System.out.println(\"A 1\");\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n                System.out.println(\"A 2\");\n                System.out.println(\"A 3\");\n            }\n\n        }\n    });\n\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            synchronized (lock) {\n                System.out.println(\"B 1\");\n                System.out.println(\"B 2\");\n                System.out.println(\"B 3\");\n\n                lock.notify();\n            }\n        }\n    });\n\n    A.start();\n    B.start();\n}\n```\n\n打印结果如下：\n>A 1\nA waiting...\n\n>B 1\nB 2\nB 3\nA 2\nA 3\n\n正是我们要的结果。\n\n那么，这个过程发生了什么呢？\n1. 首先创建一个 A 和 B 共享的对象锁 lock = new Object();\n2. 当 A 得到锁后，先打印 1，然后调用 `lock.wait()` 方法，交出锁的控制权，进入 `wait` 状态；\n3. 对 B 而言，由于 A 最开始得到了锁，导致 B 无法执行；直到 A 调用 `lock.wait()` 释放控制权后， B 才得到了锁；\n4. B 在得到锁后打印 1， 2， 3；然后调用 `lock.notify()` 方法，唤醒正在 `wait` 的 A;\n5. A 被唤醒后，继续打印剩下的 2，3。\n\n为了更好理解，我在上面的代码里加上 log 方便读者查看。\n\n\n```\nprivate static void demo3() {\n    Object lock = new Object();\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"INFO: A 等待锁\");\n            synchronized (lock) {\n                System.out.println(\"INFO: A 得到了锁 lock\");\n                System.out.println(\"A 1\");\n                try {\n                    System.out.println(\"INFO: A 准备进入等待状态，放弃锁 lock 的控制权\");\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"INFO: 有人唤醒了 A, A 重新获得锁 lock\");\n                System.out.println(\"A 2\");\n                System.out.println(\"A 3\");\n            }\n\n        }\n    });\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"INFO: B 等待锁\");\n            synchronized (lock) {\n                System.out.println(\"INFO: B 得到了锁 lock\");\n                System.out.println(\"B 1\");\n                System.out.println(\"B 2\");\n                System.out.println(\"B 3\");\n\n                System.out.println(\"INFO: B 打印完毕，调用 notify 方法\");\n                lock.notify();\n            }\n        }\n    });\n    A.start();\n    B.start();\n}\n```\n\n打印结果如下:\n\n>INFO: A 等待锁\nINFO: A 得到了锁 lock\nA 1\nINFO: A 准备进入等待状态，调用 lock.wait() 放弃锁 lock 的控制权\nINFO: B 等待锁\nINFO: B 得到了锁 lock\nB 1\nB 2\nB 3\nINFO: B 打印完毕，调用 lock.notify() 方法\nINFO: 有人唤醒了 A, A 重新获得锁 lock\nA 2\nA 3\n\n## 四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的\n最开始我们介绍了 `thread.join()`，可以让一个线程等另一个线程运行完毕后再继续执行，那我们可以在 D 线程里依次 join A B C，不过这也就使得 A B C 必须依次执行，而我们要的是这三者能同步运行。\n\n或者说，我们希望达到的目的是：A B C 三个线程同时运行，各自独立运行完后通知 D；对 D 而言，只要A B C 都运行完了，D 再开始运行。针对这种情况，我们可以利用 `CountdownLatch` 来实现这类通信方式。它的基本用法是：\n\n1. 创建一个计数器，设置初始值，CountdownLatch countDownLatch = new CountDownLatch(2);\n2. 在`等待线程`里调用 `countDownLatch.await()` 方法，进入等待状态，直到计数值变成 0；\n3. 在`其他线程`里，调用 `countDownLatch.countDown()` 方法，该方法会将计数值减小 1；\n4. 当`其他线程`的 `countDown()` 方法把计数值变成 0 时，`等待线程` 里的 `countDownLatch.await()` 立即退出，继续执行下面的代码。\n\n实现代码如下：\n```\nprivate static void runDAfterABC() {\n    int worker = 3;\n    CountDownLatch countDownLatch = new CountDownLatch(worker);\n\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"D is waiting for other three threads\");\n            try {\n                countDownLatch.await();\n                System.out.println(\"All done, D starts working\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }).start();\n\n    for (char threadName='A'; threadName <= 'C'; threadName++) {\n        final String tN = String.valueOf(threadName);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(tN + \" is working\");\n                try {\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n\n                System.out.println(tN + \" finished\");\n                countDownLatch.countDown();\n            }\n        }).start();\n    }\n}\n```\n下面是运行结果：\n>D is waiting for other three threads\nA is working\nB is working\nC is working\n\n>A finished\nC finished\nB finished\nAll done, D starts working\n\n\n其实简单点来说，`CountDownLatch` 就是一个倒计数器，我们把初始计数值设置为`3`，当 `D` 运行时，先调用 `countDownLatch.await()` 检查计数器值是否为 `0`，若不为 `0` 则保持等待状态；当`A` `B` `C` 各自运行完后都会利用`countDownLatch.countDown()`，将倒计数器减 `1`，当三个都运行完后，计数器被减至 `0`；此时立即触发 `D` 的 `await()` 运行结束，继续向下执行。\n\n因此，`CountDownLatch` 适用于一个线程去等待多个线程的情况。\n\n## 三个运动员各自准备，等到三个人都准备好后，再一起跑\n上面是一个形象的比喻，针对`线程 A B C 各自开始准备，直到三者都准备完毕，然后再同时运行`。也就是要实现一种`线程之间互相等待`的效果，那应该怎么来实现呢？\n\n上面的 `CountDownLatch` 可以用来倒计数，但当计数完毕，只有一个线程的 `await()` 会得到响应，无法让多个线程同时触发。\n\n为了实现线程间互相等待这种需求，我们可以利用 `CyclicBarrier` 数据结构，它的基本用法是：\n\n1. 先创建一个公共 `CyclicBarrier` 对象，设置`同时等待`的线程数，CyclicBarrier cyclicBarrier = new CyclicBarrier(3);\n2. 这些线程同时开始自己做准备，自身准备完毕后，需要等待别人准备完毕，这时调用 `cyclicBarrier.await();` 即可开始等待别人；\n3. 当指定的`同时等待`的线程数都调用了 `cyclicBarrier.await();`时，意味着这些线程都准备完毕好，然后这些线程才`同时继续执行`。\n\n实现代码如下，设想有三个跑步运动员，各自准备好后等待其他人，全部准备好后才开始跑：\n```\nprivate static void runABCWhenAllReady() {\n    int runner = 3;\n    CyclicBarrier cyclicBarrier = new CyclicBarrier(runner);\n\n    final Random random = new Random();\n    for (char runnerName='A'; runnerName <= 'C'; runnerName++) {\n        final String rN = String.valueOf(runnerName);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                long prepareTime = random.nextInt(10000) + 100;\n                System.out.println(rN + \" is preparing for time: \" + prepareTime);\n                try {\n                    Thread.sleep(prepareTime);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n\n                try {\n                    System.out.println(rN + \" is prepared, waiting for others\");\n                    cyclicBarrier.await(); // 当前运动员准备完毕，等待别人准备好\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n\n                System.out.println(rN + \" starts running\"); // 所有运动员都准备好了，一起开始跑\n            }\n        }).start();\n    }\n}\n```\n\n打印的结果如下：\n>A is preparing for time: 4131\nB is preparing for time: 6349\nC is preparing for time: 8206\n\n>A is prepared, waiting for others\n\n>B is prepared, waiting for others\n\n>C is prepared, waiting for others\n\n>C starts running\nA starts running\nB starts running\n\n\n## 子线程完成某件任务后，把得到的结果回传给主线程\n实际的开发中，我们经常要创建子线程来做一些耗时任务，然后把任务执行结果回传给主线程使用，这种情况在 Java 里要如何实现呢？\n\n回顾线程的创建，我们一般会把 `Runnable` 对象传给 Thread 去执行。`Runnable`定义如下：\n```\npublic interface Runnable {\n    public abstract void run();\n}\n```\n可以看到 `run()` 在执行完后不会返回任何结果。那如果希望返回结果呢？这里可以利用另一个类似的接口类 `Callable`：\n```\n@FunctionalInterface\npublic interface Callable<V> {\n    /**\n     * Computes a result, or throws an exception if unable to do so.\n     *\n     * @return computed result\n     * @throws Exception if unable to compute a result\n     */\n    V call() throws Exception;\n}\n```\n可以看出 `Callable` 最大区别就是返回范型 `V` 结果。\n\n那么下一个问题就是，如何把子线程的结果回传回来呢？在 Java 里，有一个类是配合 Callable 使用的：`FutureTask`，不过注意，它获取结果的 `get` 方法会阻塞主线程。\n\n举例，我们想让子线程去计算从1加到100，并把算出的结果返回到主线程。\n```\nprivate static void doTaskWithResultInWorker() {\n    Callable<Integer> callable = new Callable<Integer>() {\n        @Override\n        public Integer call() throws Exception {\n            System.out.println(\"Task starts\");\n            Thread.sleep(1000);\n            int result = 0;\n            for (int i=0; i<=100; i++) {\n                result += i;\n            }\n            System.out.println(\"Task finished and return result\");\n            return result;\n        }\n    };\n\n    FutureTask<Integer> futureTask = new FutureTask<>(callable);\n    new Thread(futureTask).start();\n\n\n    try {\n        System.out.println(\"Before futureTask.get()\");\n        System.out.println(\"Result: \" + futureTask.get());\n        System.out.println(\"After futureTask.get()\");\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    } catch (ExecutionException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n打印结果如下：\n>Before futureTask.get()\n\n>Task starts\nTask finished and return result\n\n>Result: 5050\nAfter futureTask.get()\n\n\n可以看到，主线程调用 `futureTask.get()` 方法时阻塞主线程；然后 `Callable` 内部开始执行，并返回运算结果；此时 `futureTask.get()` 得到结果，主线程恢复运行。\n\n这里我们可以学到，通过 `FutureTask` 和 `Callable` 可以直接在主线程获得子线程的运算结果，只不过需要阻塞主线程。当然，如果不希望阻塞主线程，可以考虑利用 `ExecutorService`，把 `FutureTask` 放到线程池去管理执行。\n\n## 小结\n多线程是现代语言的共同特性，而线程间通信、线程同步、线程安全是很重要的话题。本文针对 Java 的线程间通信进行了大致的讲解，后续还会对线程同步、线程安全进行讲解。\n\n谢谢。\n\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n\n\n\n\n","source":"_posts/Java里如何实现线程间通信？.md","raw":"title: Java里如何实现线程间通信？\ndate: 2017-04-09 17:24:06\ncategories:\n  - 深入理解Java技术\ntags: \n  - Java\n  - 多线程\ncommentIssueId: 7  \n---\n> 正常情况下，每个子线程完成各自的任务就可以结束了。不过有的时候，我们希望多个线程协同工作来完成某个任务，这时就涉及到了线程间通信了。\n\n> 本文涉及到的知识点：`thread.join()`, `object.wait()`, `object.notify()`, `CountdownLatch`, `CyclicBarrier`, `FutureTask`, `Callable` 等。\n\n> 本文涉及代码：\nhttps://github.com/wingjay/HelloJava/blob/master/multi-thread/src/ForArticle.java\n\n<!-- more -->\n\n下面我从几个例子作为切入点来讲解下 Java 里有哪些方法来实现线程间通信。\n\n- 如何让两个线程依次执行？\n- 那如何让`两`个线程按照指定方式有序交叉运行呢？\n- 四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的\n- 三个运动员各自准备，等到三个人都准备好后，再一起跑\n- 子线程完成某件任务后，把得到的结果回传给主线程\n\n\n## 如何让两个线程依次执行？\n假设有两个线程，一个是线程 A，另一个是线程 B，两个线程分别依次打印 1-3 三个数字即可。我们来看下代码：\n```\nprivate static void demo1() {\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            printNumber(\"A\");\n        }\n    });\n\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            printNumber(\"B\");\n        }\n    });\n\n    A.start();\n    B.start();\n}\n```\n其中的 `printNumber(String)` 实现如下，用来依次打印 `1`, `2`, `3` 三个数字：\n```\nprivate static void printNumber(String threadName) {\n    int i=0;\n    while (i++ < 3) {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(threadName + \" print: \" + i);\n    }\n}\n```\n\n这时我们得到的结果是：\n>B print: 1\nA print: 1\nB print: 2\nA print: 2\nB print: 3\nA print: 3\n\n可以看到 A 和 B 是同时打印的。\n\n那么，如果我们希望 B 在 A `全部打印`完后再开始打印呢？我们可以利用 `thread.join()` 方法，代码如下:\n```\nprivate static void demo2() {\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            printNumber(\"A\");\n        }\n    });\n\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n        \tSystem.out.println(\"B 开始等待 A\");\n            try {\n                A.join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            printNumber(\"B\");\n        }\n    });\n\n    B.start();\n    A.start();\n}\n```\n\n得到的结果如下：\n\n>B 开始等待 A\nA print: 1\nA print: 2\nA print: 3\n\n>B print: 1\nB print: 2\nB print: 3\n\n所以我们能看到 `A.join()` 方法会让 B 一直等待直到 A 运行完毕。\n\n## 那如何让`两`个线程按照指定方式有序交叉运行呢？\n还是上面那个例子，我现在希望 A 在打印完 `1` 后，再让 B 打印 `1`, `2`, `3`，最后再回到 A 继续打印 `2`, `3`。这种需求下，显然 `Thread.join()` 已经不能满足了。我们需要更细粒度的锁来控制执行顺序。\n\n这里，我们可以利用 `object.wait()` 和 `object.notify()` 两个方法来实现。代码如下：\n```\n/**\n * A 1, B 1, B 2, B 3, A 2, A 3\n */\nprivate static void demo3() {\n    Object lock = new Object();\n\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            synchronized (lock) {\n                System.out.println(\"A 1\");\n                try {\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n                System.out.println(\"A 2\");\n                System.out.println(\"A 3\");\n            }\n\n        }\n    });\n\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            synchronized (lock) {\n                System.out.println(\"B 1\");\n                System.out.println(\"B 2\");\n                System.out.println(\"B 3\");\n\n                lock.notify();\n            }\n        }\n    });\n\n    A.start();\n    B.start();\n}\n```\n\n打印结果如下：\n>A 1\nA waiting...\n\n>B 1\nB 2\nB 3\nA 2\nA 3\n\n正是我们要的结果。\n\n那么，这个过程发生了什么呢？\n1. 首先创建一个 A 和 B 共享的对象锁 lock = new Object();\n2. 当 A 得到锁后，先打印 1，然后调用 `lock.wait()` 方法，交出锁的控制权，进入 `wait` 状态；\n3. 对 B 而言，由于 A 最开始得到了锁，导致 B 无法执行；直到 A 调用 `lock.wait()` 释放控制权后， B 才得到了锁；\n4. B 在得到锁后打印 1， 2， 3；然后调用 `lock.notify()` 方法，唤醒正在 `wait` 的 A;\n5. A 被唤醒后，继续打印剩下的 2，3。\n\n为了更好理解，我在上面的代码里加上 log 方便读者查看。\n\n\n```\nprivate static void demo3() {\n    Object lock = new Object();\n    Thread A = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"INFO: A 等待锁\");\n            synchronized (lock) {\n                System.out.println(\"INFO: A 得到了锁 lock\");\n                System.out.println(\"A 1\");\n                try {\n                    System.out.println(\"INFO: A 准备进入等待状态，放弃锁 lock 的控制权\");\n                    lock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"INFO: 有人唤醒了 A, A 重新获得锁 lock\");\n                System.out.println(\"A 2\");\n                System.out.println(\"A 3\");\n            }\n\n        }\n    });\n    Thread B = new Thread(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"INFO: B 等待锁\");\n            synchronized (lock) {\n                System.out.println(\"INFO: B 得到了锁 lock\");\n                System.out.println(\"B 1\");\n                System.out.println(\"B 2\");\n                System.out.println(\"B 3\");\n\n                System.out.println(\"INFO: B 打印完毕，调用 notify 方法\");\n                lock.notify();\n            }\n        }\n    });\n    A.start();\n    B.start();\n}\n```\n\n打印结果如下:\n\n>INFO: A 等待锁\nINFO: A 得到了锁 lock\nA 1\nINFO: A 准备进入等待状态，调用 lock.wait() 放弃锁 lock 的控制权\nINFO: B 等待锁\nINFO: B 得到了锁 lock\nB 1\nB 2\nB 3\nINFO: B 打印完毕，调用 lock.notify() 方法\nINFO: 有人唤醒了 A, A 重新获得锁 lock\nA 2\nA 3\n\n## 四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的\n最开始我们介绍了 `thread.join()`，可以让一个线程等另一个线程运行完毕后再继续执行，那我们可以在 D 线程里依次 join A B C，不过这也就使得 A B C 必须依次执行，而我们要的是这三者能同步运行。\n\n或者说，我们希望达到的目的是：A B C 三个线程同时运行，各自独立运行完后通知 D；对 D 而言，只要A B C 都运行完了，D 再开始运行。针对这种情况，我们可以利用 `CountdownLatch` 来实现这类通信方式。它的基本用法是：\n\n1. 创建一个计数器，设置初始值，CountdownLatch countDownLatch = new CountDownLatch(2);\n2. 在`等待线程`里调用 `countDownLatch.await()` 方法，进入等待状态，直到计数值变成 0；\n3. 在`其他线程`里，调用 `countDownLatch.countDown()` 方法，该方法会将计数值减小 1；\n4. 当`其他线程`的 `countDown()` 方法把计数值变成 0 时，`等待线程` 里的 `countDownLatch.await()` 立即退出，继续执行下面的代码。\n\n实现代码如下：\n```\nprivate static void runDAfterABC() {\n    int worker = 3;\n    CountDownLatch countDownLatch = new CountDownLatch(worker);\n\n    new Thread(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"D is waiting for other three threads\");\n            try {\n                countDownLatch.await();\n                System.out.println(\"All done, D starts working\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }).start();\n\n    for (char threadName='A'; threadName <= 'C'; threadName++) {\n        final String tN = String.valueOf(threadName);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(tN + \" is working\");\n                try {\n                    Thread.sleep(100);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n\n                System.out.println(tN + \" finished\");\n                countDownLatch.countDown();\n            }\n        }).start();\n    }\n}\n```\n下面是运行结果：\n>D is waiting for other three threads\nA is working\nB is working\nC is working\n\n>A finished\nC finished\nB finished\nAll done, D starts working\n\n\n其实简单点来说，`CountDownLatch` 就是一个倒计数器，我们把初始计数值设置为`3`，当 `D` 运行时，先调用 `countDownLatch.await()` 检查计数器值是否为 `0`，若不为 `0` 则保持等待状态；当`A` `B` `C` 各自运行完后都会利用`countDownLatch.countDown()`，将倒计数器减 `1`，当三个都运行完后，计数器被减至 `0`；此时立即触发 `D` 的 `await()` 运行结束，继续向下执行。\n\n因此，`CountDownLatch` 适用于一个线程去等待多个线程的情况。\n\n## 三个运动员各自准备，等到三个人都准备好后，再一起跑\n上面是一个形象的比喻，针对`线程 A B C 各自开始准备，直到三者都准备完毕，然后再同时运行`。也就是要实现一种`线程之间互相等待`的效果，那应该怎么来实现呢？\n\n上面的 `CountDownLatch` 可以用来倒计数，但当计数完毕，只有一个线程的 `await()` 会得到响应，无法让多个线程同时触发。\n\n为了实现线程间互相等待这种需求，我们可以利用 `CyclicBarrier` 数据结构，它的基本用法是：\n\n1. 先创建一个公共 `CyclicBarrier` 对象，设置`同时等待`的线程数，CyclicBarrier cyclicBarrier = new CyclicBarrier(3);\n2. 这些线程同时开始自己做准备，自身准备完毕后，需要等待别人准备完毕，这时调用 `cyclicBarrier.await();` 即可开始等待别人；\n3. 当指定的`同时等待`的线程数都调用了 `cyclicBarrier.await();`时，意味着这些线程都准备完毕好，然后这些线程才`同时继续执行`。\n\n实现代码如下，设想有三个跑步运动员，各自准备好后等待其他人，全部准备好后才开始跑：\n```\nprivate static void runABCWhenAllReady() {\n    int runner = 3;\n    CyclicBarrier cyclicBarrier = new CyclicBarrier(runner);\n\n    final Random random = new Random();\n    for (char runnerName='A'; runnerName <= 'C'; runnerName++) {\n        final String rN = String.valueOf(runnerName);\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                long prepareTime = random.nextInt(10000) + 100;\n                System.out.println(rN + \" is preparing for time: \" + prepareTime);\n                try {\n                    Thread.sleep(prepareTime);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n\n                try {\n                    System.out.println(rN + \" is prepared, waiting for others\");\n                    cyclicBarrier.await(); // 当前运动员准备完毕，等待别人准备好\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n\n                System.out.println(rN + \" starts running\"); // 所有运动员都准备好了，一起开始跑\n            }\n        }).start();\n    }\n}\n```\n\n打印的结果如下：\n>A is preparing for time: 4131\nB is preparing for time: 6349\nC is preparing for time: 8206\n\n>A is prepared, waiting for others\n\n>B is prepared, waiting for others\n\n>C is prepared, waiting for others\n\n>C starts running\nA starts running\nB starts running\n\n\n## 子线程完成某件任务后，把得到的结果回传给主线程\n实际的开发中，我们经常要创建子线程来做一些耗时任务，然后把任务执行结果回传给主线程使用，这种情况在 Java 里要如何实现呢？\n\n回顾线程的创建，我们一般会把 `Runnable` 对象传给 Thread 去执行。`Runnable`定义如下：\n```\npublic interface Runnable {\n    public abstract void run();\n}\n```\n可以看到 `run()` 在执行完后不会返回任何结果。那如果希望返回结果呢？这里可以利用另一个类似的接口类 `Callable`：\n```\n@FunctionalInterface\npublic interface Callable<V> {\n    /**\n     * Computes a result, or throws an exception if unable to do so.\n     *\n     * @return computed result\n     * @throws Exception if unable to compute a result\n     */\n    V call() throws Exception;\n}\n```\n可以看出 `Callable` 最大区别就是返回范型 `V` 结果。\n\n那么下一个问题就是，如何把子线程的结果回传回来呢？在 Java 里，有一个类是配合 Callable 使用的：`FutureTask`，不过注意，它获取结果的 `get` 方法会阻塞主线程。\n\n举例，我们想让子线程去计算从1加到100，并把算出的结果返回到主线程。\n```\nprivate static void doTaskWithResultInWorker() {\n    Callable<Integer> callable = new Callable<Integer>() {\n        @Override\n        public Integer call() throws Exception {\n            System.out.println(\"Task starts\");\n            Thread.sleep(1000);\n            int result = 0;\n            for (int i=0; i<=100; i++) {\n                result += i;\n            }\n            System.out.println(\"Task finished and return result\");\n            return result;\n        }\n    };\n\n    FutureTask<Integer> futureTask = new FutureTask<>(callable);\n    new Thread(futureTask).start();\n\n\n    try {\n        System.out.println(\"Before futureTask.get()\");\n        System.out.println(\"Result: \" + futureTask.get());\n        System.out.println(\"After futureTask.get()\");\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    } catch (ExecutionException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n打印结果如下：\n>Before futureTask.get()\n\n>Task starts\nTask finished and return result\n\n>Result: 5050\nAfter futureTask.get()\n\n\n可以看到，主线程调用 `futureTask.get()` 方法时阻塞主线程；然后 `Callable` 内部开始执行，并返回运算结果；此时 `futureTask.get()` 得到结果，主线程恢复运行。\n\n这里我们可以学到，通过 `FutureTask` 和 `Callable` 可以直接在主线程获得子线程的运算结果，只不过需要阻塞主线程。当然，如果不希望阻塞主线程，可以考虑利用 `ExecutorService`，把 `FutureTask` 放到线程池去管理执行。\n\n## 小结\n多线程是现代语言的共同特性，而线程间通信、线程同步、线程安全是很重要的话题。本文针对 Java 的线程间通信进行了大致的讲解，后续还会对线程同步、线程安全进行讲解。\n\n谢谢。\n\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n\n\n\n\n\n\n\n","slug":"Java里如何实现线程间通信？","published":1,"updated":"2017-06-23T04:04:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm2m003cmoyxpkr8ne1d","sticky":0},{"title":"Java 的 equals 与 hashcode 对比分析","date":"2017-03-29T13:23:53.000Z","commentIssueId":8,"_content":">在阅读《Effective Java》第3章里读到了关于 equals() 和 hashcode() 的一些介绍，这两个方法是很多Java程序员容易弄混的，因此本文针对这两个方法的用法和具体实现来做一些介绍。\n\n<!-- more -->\n\n## equals() 与 hashcode() 的用处？\n我们一般用`equals()`来比较两个对象的`逻辑意义`上的值是否相同。举个例子：\n```java\nclass Person {\n    String name;\n    int age;\n    long id;\n}\n```\n我们现在有两个Person的对象，person1 和person2，那么什么时候这两个是相等的呢？对于两个人而言，我们认为如果他们俩名字、年龄和ID都完全一样，那么就是同一个人。也就是说，如果\n```\nperson1.name = person2.name\nperson1.age = person2.age\nperson1.id = person2.id\n```\n那么我们就认为 `person1.equals(person2)=true`。这就是表示equals是指二者逻辑意义上相等即可。\n\n而 hashcode() 则是对一个对象进行hash计算得到的一个散列值，它有以下特点：\n1. 对象x和y的hashcode相同，不代表两个对象就相同(x.equals(y)=true)，可能存在hash碰撞；不过hashcode如果不相同，那么一定是两个不同的对象\n2. 如果两个对象的equals()相等，那么hashcode一定相等。\n所以我们一般可以用hashcode来快速比较两个对象`互异`，因为如果`x.hashcode() != y.hashcode()`，那么`x.equals(y)=false`。\n\n## equals() 的特性\n很多时候我们想要重写某个自定义object的equals()方法，那么一定要记住，你的equals()方法必须满足下面四个条件：\n1. 自反性：对于非null的对象x，必须有 `x.equals(x)=true`；\n2. 对称性：如果 `x.equals(y)=true`，那么`y.equals(x)`必须也为`true`；\n3. 传递性：如果`x.equals(y)=true`而且`y.equals(z)=true`，那么`x.equals(z)`必须为`true`；\n4. 对于非null的对象x，一定有`x.equals(null)=false`\n\n## 如何重载 equals() 方法呢？\n一般而言，如果你要重载 equals() 方法，有下面一套模版代码可以参考：\n1. 首先使用 `==` 来判断`两个对象是否引用相同`；\n2. 使用 `instanceof` 来判断`两个对象是否类型相同`；\n3. 如果类型相同，则把待比较参数转型；\n4. 比较两个对象内部每个逻辑值是否相等，只有全部相等才返回true，或者返回false；\n5. 测试这个方法是否能满足上面几个特性。\n\n## Java 源码 String 里 equals() 和 hashcode() 实现\n看完上面的特性和重载方法你可能有点头大，下面我们来看一下Java里的 String 是如何实现的吧，是否满足上面几个特性呢。\n```\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n可以看到，上面的方法依次执行了下面的步骤：\n1. 比较引用`this == anObject`；\n2. 判断类型 `anObject instanceof String`；\n3. 转型 `String anotherString = (String)anObject`；\n4. 比较逻辑值 对 String 而言，首先要 `length` 相等 `n == anotherString.value.length`；然后要每一个字符相等，见代码，最后返回结果。\n\n下面我写了一段测试代码来验证是否符合上面几点特性：\n```\nprivate static void testStringEquals() {\n    String x = \"First\";\n    String y = \"First\";\n    String z = new String(\"First\");\n    System.out.println(x.equals(x));\n    System.out.println((x.equals(y) && y.equals(x)));\n    if (x.equals(y) && y.equals(x)) {\n        System.out.println(x.equals(z));\n    }\n    System.out.println(x.equals(null));\n}\n```\n打印结果如下：\n```\ntrue\ntrue\ntrue\nfalse\n```\n说明是符合的。\n\n然后我们再看下 hashcode() 的源代码实现，我们知道，hashcode的含义是计算hash散列值，其实就是对一个对象快速计算一个散列值，用来`判异`使用：只要 hashcode() 不同，那么两个对象一定不同。下面我们看下 String 是如何计算自己的hash值的。\n```java\nprivate final char value[]; /** The value is used for character storage. */\nprivate int hash; /** Cache the hash code for the string Default to 0 */\n\npublic int hashCode() {\n    int h = hash; \n    if (h == 0 && value.length > 0) { \n        char val[] = value;\n        for (int i = 0; i < value.length; i++) {\n            h = 31 * h + val[i];\n        }\n        hash = h;\n    }\n    return h;\n}\n```\n其中用来计算 hashcode 主要是这段代码\n```\nfor (int i = 0; i < value.length; i++) {\n    h = 31 * h + val[i];\n}\n```\n其中，value是内部存储string值的字符数组。计算hashcode的方法就是依次遍历每一个字符，乘以31后再加上下一个字符。例如\"a\"的hashcode就是 97；\"aa\"的hashcode是 `31*97+97`=3104。因此可以看出，`hashcode不同的两个 String 对象一定不是同一个对象`。\n\n## 谨记：重载 equals() 时要保证：两个equal的对象一定有相同的hashcode\n很多人在重载 equals() 时忽视了这一点，没有保证两个equal的对象具备相同的hashcode，从而导致了奇怪的错误。\n\n下面举一个例子，我先只重载 `PhoneNumberWithoutHashcode` 的 equals() 方法：\n```\nclass PhoneNumberWithoutHashcode {\n    final short countryCode;\n    final short number;\n    public PhoneNumberWithoutHashcode(int countryCode, int number) {\n        this.countryCode = (short) countryCode;\n        this.number = (short) number;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        // 1. check == reference\n        if(obj == this) {\n            return true;\n        }\n        // 2. check obj instance\n        if (!(obj instanceof PhoneNumberWithoutHashcode))\n            return false;\n\n        // 3. compare logic value\n        PhoneNumberWithoutHashcode anObj = (PhoneNumberWithoutHashcode) obj;\n        return anObj.countryCode == this.countryCode \n                && anObj.number == this.number;\n    }        \n}\n```\n下面我们来创建两个相同的对象，看看它们的 equals() hashcode() 返回值如何。\n```\nprivate static void test() {\n    PhoneNumberWithoutHashcode p1 = new PhoneNumberWithoutHashcode(86, 123123);\n    PhoneNumberWithoutHashcode p2 = new PhoneNumberWithoutHashcode(86, 123123);\n    System.out.println(\"p1.equals(p2)=\" + p1.equals(p2));\n    System.out.println(\"p1.hashcode()=\" + p1.hashCode());\n    System.out.println(\"p2.hashcode()=\" + p2.hashCode());    \n}\n```\n可以得到结果如下:\n```\np1.equals(p2)=true\np1.hashcode()=1846274136\np2.hashcode()=1639705018\n```\n可以看出，二者是 equals 的，但是hashcode不一样。这违背了 Java准则，会导致什么结果呢？\n\n```java\nprivate static void test() {\n    PhoneNumberWithoutHashcode p1 = new PhoneNumberWithoutHashcode(86, 123123);\n    PhoneNumberWithoutHashcode p2 = new PhoneNumberWithoutHashcode(86, 123123);\n    System.out.println(\"p1.equals(p2)=\" + p1.equals(p2));\n    \n    HashMap<PhoneNumberWithoutHashcode, String> map = new HashMap<>();\n    map.put(p1, \"TheValue\");\n    System.out.println(\"Result: \" + map.get(p2));\n}\n```\n\n读者觉得会打印什么呢？`Result: TheValue` 吗？我们来看下运行结果：\n```\np1.equals(p2)=true\nResult:  null\n```\n问题来了，p1和p2是equal的，但是确不是同样的key，至少对于HashMap而言，它们俩不是同一个key，为什么呢？\n\n我们看一下 HashMap 是怎么put和get的吧。\n```\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n```\n从这段代码可以看到，p1 和 p2 被存储时就计算了一次 `hash(key)`，如下:\n```\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n其实就是调用了 `key.hashCode()` 方法，而我们知道虽然 `p1.equals(p2)=true`，但是`p1.hashCode() != p2.hashCode()`，因此 p1 和 p2 对 HashMap 而言压根就是两个 key，当然互相取不到对方的 value了。\n\n那么要如何改进这个类呢？我们再来实现它的 hashcode 方法吧。\n```\nclass PhoneNumber {\n    protected final short countryCode;\n    protected final short number;\n\n    public PhoneNumber(int countryCode, int number) {\n        this.countryCode = (short) countryCode;\n        this.number = (short) number;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        // 1. check == reference\n        if (this == obj)\n            return true;\n\n        // 2. check obj instance\n        if (!(obj instanceof PhoneNumber))\n            return false;\n\n        // 3. compare logic value\n        PhoneNumber target = (PhoneNumber) obj;\n        return target.number == this.number\n                && target.countryCode == this.countryCode;\n    }\n\n    @Override\n    public int hashCode() {\n        return (31 * this.countryCode) + this.number;\n    }\n}\n```\n这时我们的测试代码：\n```\nprivate static void test() {\n    PhoneNumber p1 = new PhoneNumber(86, 12);\n    PhoneNumber p2 = new PhoneNumber(86, 12);\n    System.out.println(\"p1.equals(p2)=\" + p1.equals(p2));\n    System.out.println(\"p1.hashcode()=\" + p1.hashCode());\n    System.out.println(\"p2.hashcode()=\" + p2.hashCode());\n\n    HashMap<PhoneNumber, String> map = new HashMap<>(2);\n    map.put(p1, \"TheValue\");\n    System.out.println(\"Result: \" + map.get(p2));\n}\n```\n打印结果如下：\n```\np1.equals(p2)=true\np1.hashcode()=88076\np2.hashcode()=88076\nResult: TheValue\n```\n说明重载hashcode后就能保证 `PhoneNumber` 在 `HashMap` 里正常运行了，毕竟像这种 HashMap HashSet 之类的都要基于对象的hash值。\n\n## 小结\n如果存在遗漏错误欢迎读者提出。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>","source":"_posts/Java的equals与hashcode对比分析.md","raw":"title: Java的equals与hashcode对比分析\ndate: 2017-03-29 21:23:53\ncategories:\n  - 深入理解Java技术\ntags: Java\ncommentIssueId: 8\n---\n>在阅读《Effective Java》第3章里读到了关于 equals() 和 hashcode() 的一些介绍，这两个方法是很多Java程序员容易弄混的，因此本文针对这两个方法的用法和具体实现来做一些介绍。\n\n<!-- more -->\n\n## equals() 与 hashcode() 的用处？\n我们一般用`equals()`来比较两个对象的`逻辑意义`上的值是否相同。举个例子：\n```java\nclass Person {\n    String name;\n    int age;\n    long id;\n}\n```\n我们现在有两个Person的对象，person1 和person2，那么什么时候这两个是相等的呢？对于两个人而言，我们认为如果他们俩名字、年龄和ID都完全一样，那么就是同一个人。也就是说，如果\n```\nperson1.name = person2.name\nperson1.age = person2.age\nperson1.id = person2.id\n```\n那么我们就认为 `person1.equals(person2)=true`。这就是表示equals是指二者逻辑意义上相等即可。\n\n而 hashcode() 则是对一个对象进行hash计算得到的一个散列值，它有以下特点：\n1. 对象x和y的hashcode相同，不代表两个对象就相同(x.equals(y)=true)，可能存在hash碰撞；不过hashcode如果不相同，那么一定是两个不同的对象\n2. 如果两个对象的equals()相等，那么hashcode一定相等。\n所以我们一般可以用hashcode来快速比较两个对象`互异`，因为如果`x.hashcode() != y.hashcode()`，那么`x.equals(y)=false`。\n\n## equals() 的特性\n很多时候我们想要重写某个自定义object的equals()方法，那么一定要记住，你的equals()方法必须满足下面四个条件：\n1. 自反性：对于非null的对象x，必须有 `x.equals(x)=true`；\n2. 对称性：如果 `x.equals(y)=true`，那么`y.equals(x)`必须也为`true`；\n3. 传递性：如果`x.equals(y)=true`而且`y.equals(z)=true`，那么`x.equals(z)`必须为`true`；\n4. 对于非null的对象x，一定有`x.equals(null)=false`\n\n## 如何重载 equals() 方法呢？\n一般而言，如果你要重载 equals() 方法，有下面一套模版代码可以参考：\n1. 首先使用 `==` 来判断`两个对象是否引用相同`；\n2. 使用 `instanceof` 来判断`两个对象是否类型相同`；\n3. 如果类型相同，则把待比较参数转型；\n4. 比较两个对象内部每个逻辑值是否相等，只有全部相等才返回true，或者返回false；\n5. 测试这个方法是否能满足上面几个特性。\n\n## Java 源码 String 里 equals() 和 hashcode() 实现\n看完上面的特性和重载方法你可能有点头大，下面我们来看一下Java里的 String 是如何实现的吧，是否满足上面几个特性呢。\n```\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n可以看到，上面的方法依次执行了下面的步骤：\n1. 比较引用`this == anObject`；\n2. 判断类型 `anObject instanceof String`；\n3. 转型 `String anotherString = (String)anObject`；\n4. 比较逻辑值 对 String 而言，首先要 `length` 相等 `n == anotherString.value.length`；然后要每一个字符相等，见代码，最后返回结果。\n\n下面我写了一段测试代码来验证是否符合上面几点特性：\n```\nprivate static void testStringEquals() {\n    String x = \"First\";\n    String y = \"First\";\n    String z = new String(\"First\");\n    System.out.println(x.equals(x));\n    System.out.println((x.equals(y) && y.equals(x)));\n    if (x.equals(y) && y.equals(x)) {\n        System.out.println(x.equals(z));\n    }\n    System.out.println(x.equals(null));\n}\n```\n打印结果如下：\n```\ntrue\ntrue\ntrue\nfalse\n```\n说明是符合的。\n\n然后我们再看下 hashcode() 的源代码实现，我们知道，hashcode的含义是计算hash散列值，其实就是对一个对象快速计算一个散列值，用来`判异`使用：只要 hashcode() 不同，那么两个对象一定不同。下面我们看下 String 是如何计算自己的hash值的。\n```java\nprivate final char value[]; /** The value is used for character storage. */\nprivate int hash; /** Cache the hash code for the string Default to 0 */\n\npublic int hashCode() {\n    int h = hash; \n    if (h == 0 && value.length > 0) { \n        char val[] = value;\n        for (int i = 0; i < value.length; i++) {\n            h = 31 * h + val[i];\n        }\n        hash = h;\n    }\n    return h;\n}\n```\n其中用来计算 hashcode 主要是这段代码\n```\nfor (int i = 0; i < value.length; i++) {\n    h = 31 * h + val[i];\n}\n```\n其中，value是内部存储string值的字符数组。计算hashcode的方法就是依次遍历每一个字符，乘以31后再加上下一个字符。例如\"a\"的hashcode就是 97；\"aa\"的hashcode是 `31*97+97`=3104。因此可以看出，`hashcode不同的两个 String 对象一定不是同一个对象`。\n\n## 谨记：重载 equals() 时要保证：两个equal的对象一定有相同的hashcode\n很多人在重载 equals() 时忽视了这一点，没有保证两个equal的对象具备相同的hashcode，从而导致了奇怪的错误。\n\n下面举一个例子，我先只重载 `PhoneNumberWithoutHashcode` 的 equals() 方法：\n```\nclass PhoneNumberWithoutHashcode {\n    final short countryCode;\n    final short number;\n    public PhoneNumberWithoutHashcode(int countryCode, int number) {\n        this.countryCode = (short) countryCode;\n        this.number = (short) number;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        // 1. check == reference\n        if(obj == this) {\n            return true;\n        }\n        // 2. check obj instance\n        if (!(obj instanceof PhoneNumberWithoutHashcode))\n            return false;\n\n        // 3. compare logic value\n        PhoneNumberWithoutHashcode anObj = (PhoneNumberWithoutHashcode) obj;\n        return anObj.countryCode == this.countryCode \n                && anObj.number == this.number;\n    }        \n}\n```\n下面我们来创建两个相同的对象，看看它们的 equals() hashcode() 返回值如何。\n```\nprivate static void test() {\n    PhoneNumberWithoutHashcode p1 = new PhoneNumberWithoutHashcode(86, 123123);\n    PhoneNumberWithoutHashcode p2 = new PhoneNumberWithoutHashcode(86, 123123);\n    System.out.println(\"p1.equals(p2)=\" + p1.equals(p2));\n    System.out.println(\"p1.hashcode()=\" + p1.hashCode());\n    System.out.println(\"p2.hashcode()=\" + p2.hashCode());    \n}\n```\n可以得到结果如下:\n```\np1.equals(p2)=true\np1.hashcode()=1846274136\np2.hashcode()=1639705018\n```\n可以看出，二者是 equals 的，但是hashcode不一样。这违背了 Java准则，会导致什么结果呢？\n\n```java\nprivate static void test() {\n    PhoneNumberWithoutHashcode p1 = new PhoneNumberWithoutHashcode(86, 123123);\n    PhoneNumberWithoutHashcode p2 = new PhoneNumberWithoutHashcode(86, 123123);\n    System.out.println(\"p1.equals(p2)=\" + p1.equals(p2));\n    \n    HashMap<PhoneNumberWithoutHashcode, String> map = new HashMap<>();\n    map.put(p1, \"TheValue\");\n    System.out.println(\"Result: \" + map.get(p2));\n}\n```\n\n读者觉得会打印什么呢？`Result: TheValue` 吗？我们来看下运行结果：\n```\np1.equals(p2)=true\nResult:  null\n```\n问题来了，p1和p2是equal的，但是确不是同样的key，至少对于HashMap而言，它们俩不是同一个key，为什么呢？\n\n我们看一下 HashMap 是怎么put和get的吧。\n```\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n```\n从这段代码可以看到，p1 和 p2 被存储时就计算了一次 `hash(key)`，如下:\n```\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n其实就是调用了 `key.hashCode()` 方法，而我们知道虽然 `p1.equals(p2)=true`，但是`p1.hashCode() != p2.hashCode()`，因此 p1 和 p2 对 HashMap 而言压根就是两个 key，当然互相取不到对方的 value了。\n\n那么要如何改进这个类呢？我们再来实现它的 hashcode 方法吧。\n```\nclass PhoneNumber {\n    protected final short countryCode;\n    protected final short number;\n\n    public PhoneNumber(int countryCode, int number) {\n        this.countryCode = (short) countryCode;\n        this.number = (short) number;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        // 1. check == reference\n        if (this == obj)\n            return true;\n\n        // 2. check obj instance\n        if (!(obj instanceof PhoneNumber))\n            return false;\n\n        // 3. compare logic value\n        PhoneNumber target = (PhoneNumber) obj;\n        return target.number == this.number\n                && target.countryCode == this.countryCode;\n    }\n\n    @Override\n    public int hashCode() {\n        return (31 * this.countryCode) + this.number;\n    }\n}\n```\n这时我们的测试代码：\n```\nprivate static void test() {\n    PhoneNumber p1 = new PhoneNumber(86, 12);\n    PhoneNumber p2 = new PhoneNumber(86, 12);\n    System.out.println(\"p1.equals(p2)=\" + p1.equals(p2));\n    System.out.println(\"p1.hashcode()=\" + p1.hashCode());\n    System.out.println(\"p2.hashcode()=\" + p2.hashCode());\n\n    HashMap<PhoneNumber, String> map = new HashMap<>(2);\n    map.put(p1, \"TheValue\");\n    System.out.println(\"Result: \" + map.get(p2));\n}\n```\n打印结果如下：\n```\np1.equals(p2)=true\np1.hashcode()=88076\np2.hashcode()=88076\nResult: TheValue\n```\n说明重载hashcode后就能保证 `PhoneNumber` 在 `HashMap` 里正常运行了，毕竟像这种 HashMap HashSet 之类的都要基于对象的hash值。\n\n## 小结\n如果存在遗漏错误欢迎读者提出。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>","slug":"Java的equals与hashcode对比分析","published":1,"updated":"2017-06-23T04:04:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm2o003jmoyx64dv0zee","sticky":0},{"title":"Java 技术之类加载机制","date":"2017-05-08T12:46:38.000Z","commentIssueId":4,"_content":"> 类加载机制是 Java 语言的一大亮点，使得 Java 类可以被动态加载到 Java 虚拟机中。\n\n> 这次我们抛开术语和概念，从例子入手，由浅入深地讲解 Java 的类加载机制。\n\n> 本文涉及知识点：双亲委托机制、BootstrapClassLoader、ExtClassLoader、AppClassLoader、自定义网络类加载器等\n\n> 文章涉及代码：\nhttps://github.com/wingjay/HelloJava/blob/master/common/src/classloader/HelloClassLoader.java\n\n<!-- more -->\n\n## 什么是 Java 类加载机制?\nJava 虚拟机一般使用 Java 类的流程为：首先将开发者编写的 Java 源代码（.java文件）编译成 Java 字节码（.class文件），然后类加载器会读取这个 .class 文件，并转换成 java.lang.Class 的实例。有了该 Class 实例后，Java 虚拟机可以利用 newInstance 之类的方法创建其真正对象了。\n\nClassLoader 是 Java 提供的类加载器，绝大多数的类加载器都继承自 ClassLoader，它们被用来加载不同来源的 Class 文件。\n\n## Class 文件有哪些来源呢?\n上文提到了 ClassLoader 可以去加载多种来源的 Class，那么具体有哪些来源呢？\n\n首先，最常见的是开发者在应用程序中编写的类，这些类位于项目目录下；\n\n然后，有 Java 内部自带的`核心类`如 `java.lang`、`java.math`、`java.io` 等 package 内部的类，位于 `$JAVA_HOME/jre/lib/` 目录下，如 `java.lang.String` 类就是定义在 `$JAVA_HOME/jre/lib/rt.jar` 文件里；\n\n另外，还有 Java `核心扩展类`，位于 `$JAVA_HOME/jre/lib/ext` 目录下。开发者也可以把自己编写的类打包成 jar 文件放入该目录下；\n\n最后还有一种，是动态加载远程的 .class 文件。\n\n既然有这么多种类的来源，那么在 Java 里，是由某一个具体的 ClassLoader 来统一加载呢？还是由多个 ClassLoader 来协作加载呢？\n\n## 哪些 ClassLoader 负责加载上面几类 Class？\n实际上，针对上面四种来源的类，分别有不同的加载器负责加载。\n\n首先，我们来看级别最高的 `Java 核心类`，即`$JAVA_HOME/jre/lib` 里的核心 jar 文件。这些类是 Java 运行的基础类，由一个名为 `BootstrapClassLoader` 加载器负责加载，它也被称作 `根加载器／引导加载器`。注意，`BootstrapClassLoader` 比较特殊，它不继承 `ClassLoader`，而是由 JVM 内部实现；\n\n然后，需要加载 `Java 核心扩展类`，即 `$JAVA_HOME/jre/lib/ext` 目录下的 jar 文件。这些文件由 `ExtensionClassLoader` 负责加载，它也被称作 `扩展类加载器`。当然，用户如果把自己开发的 jar 文件放在这个目录，也会被 `ExtClassLoader` 加载；\n\n接下来是开发者在项目中编写的类，这些文件将由 `AppClassLoader` 加载器进行加载，它也被称作 `系统类加载器 System ClassLoader`；\n\n最后，如果想远程加载如（本地文件／网络下载）的方式，则必须要自己自定义一个 ClassLoader，复写其中的 `findClass()` 方法才能得以实现。\n\n因此能看出，Java 里提供了至少四类 `ClassLoader` 来分别加载不同来源的 Class。\n\n那么，这几种 ClassLoader 是如何协作来加载一个类呢？\n\n## 这些 ClassLoader 以何种方式来协作加载 String 类呢？\nString 类是 Java 自带的最常用的一个类，现在的问题是，JVM 将以何种方式把 String class 加载进来呢？\n\n我们来猜想下。\n\n首先，String 类属于 Java 核心类，位于 `$JAVA_HOME/jre/lib` 目录下。有的朋友会马上反应过来，上文中提过了，该目录下的类会由 `BootstrapClassLoader` 进行加载。没错，它确实是由 `BootstrapClassLoader` 进行加载。但，这种回答的前提是你已经知道了 String 在 `$JAVA_HOME/jre/lib` 目录下。\n\n那么，如果你并不知道 String 类究竟位于哪呢？或者我希望你去加载一个 `unknown` 的类呢？\n\n有的朋友这时会说，那很简单，只要去遍历一遍所有的类，看看这个 `unknown` 的类位于哪里，然后再用对应的加载器去加载。\n\n是的，思路很正确。那应该如何去遍历呢？\n\n比如，可以先遍历用户自己写的类，如果找到了就用 `AppClassLoader` 去加载；否则去遍历 Java 核心类目录，找到了就用 `BootstrapClassLoader` 去加载，否则就去遍历 Java 扩展类库，依次类推。\n\n这种思路方向是正确的，不过存在一个漏洞。\n\n假如开发者自己伪造了一个 `java.lang.String` 类，即在项目中创建一个包`java.lang`，包内创建一个名为 `String` 的类，这完全可以做到。那如果利用上面的遍历方法，是不是这个项目中用到的 String 不是都变成了这个伪造的 `java.lang.String` 类吗？如何解决这个问题呢？\n\n解决方法很简单，当查找一个类时，优先遍历最高级别的 Java 核心类，然后再去遍历 Java 核心扩展类，最后再遍历用户自定义类，而且这个遍历过程是一旦找到就立即停止遍历。\n\n在 Java 中，这种实现方式也称作 `双亲委托`。其实很简单，把 `BootstrapClassLoader` 想象为核心高层领导人， `ExtClassLoader` 想象为中层干部， `AppClassLoader` 想象为普通公务员。每次需要加载一个类，先获取一个系统加载器 `AppClassLoader` 的实例（ClassLoader.getSystemClassLoader()），然后向上级层层请求，由最上级优先去加载，如果上级觉得这些类不属于核心类，就可以下放到各子级负责人去自行加载。\n\n如下图所示：\n![双亲委托](/img/classloader/order.png)\n\n## 真的是按照`双亲委托`方式进行类加载吗？\n下面通过几个例子来验证上面的加载方式。\n\n#### 开发者自定义的类会被 `AppClassLoader` 加载吗？\n在项目中创建一个名为 `MusicPlayer` 的类文件，内容如下：\n```\npackage classloader;\n\npublic class MusicPlayer {\n\tpublic void print() {\n\t\tSystem.out.printf(\"Hi I'm MusicPlayer\");\n\t}\n}\n```\n\n然后来加载 `MusicPlayer`。\n\n```\nprivate static void loadClass() throws ClassNotFoundException {\n    Class<?> clazz = Class.forName(\"classloader.MusicPlayer\");\n    ClassLoader classLoader = clazz.getClassLoader();\n    System.out.printf(\"ClassLoader is %s\", classLoader.getClass().getSimpleName());\n}\n```\n打印结果为：\n```\nClassLoader is AppClassLoader\n```\n可以验证，`MusicPlayer` 是由 `AppClassLoader` 进行的加载。\n\n#### 验证 `AppClassLoader` 的双亲真的是 ExtClassLoader 和 BootstrapClassLoader 吗？\n这时发现 `AppClassLoader` 提供了一个 `getParent()` 的方法，来打印看看都是什么。\n```\nprivate static void printParent() throws ClassNotFoundException {\n        Class<?> clazz = Class.forName(\"classloader.MusicPlayer\");\n        ClassLoader classLoader = clazz.getClassLoader();\n        System.out.printf(\"currentClassLoader is %s\\n\", classLoader.getClass().getSimpleName());\n\n        while (classLoader.getParent() != null) {\n            classLoader = classLoader.getParent();\n            System.out.printf(\"Parent is %s\\n\", classLoader.getClass().getSimpleName());\n        }\n}\n```\n打印结果为：\n```\ncurrentClassLoader is AppClassLoader\nParent is ExtClassLoader\n```\n首先能看到 `ExtClassLoader` 确实是 `AppClassLoader` 的双亲，不过却没有看到 `BootstrapClassLoader`。事实上，上文就提过， `BootstrapClassLoader`比较特殊，它是由 JVM 内部实现的，所以 `ExtClassLoader.getParent() = null`。\n\n#### 如果把 MusicPlayer 类挪到 `$JAVA_HOME/jre/lib/ext` 目录下会发生什么？\n上文中说了，`ExtClassLoader` 会加载`$JAVA_HOME/jre/lib/ext` 目录下所有的 jar 文件。那来尝试下直接把 `MusicPlayer` 这个类放到 `$JAVA_HOME/jre/lib/ext` 目录下吧。\n\n利用下面命令可以把 MusicPlayer.java 编译打包成 jar 文件，并放置到对应目录。\n```\njavac classloader/MusicPlayer.java\njar cvf MusicPlayer.jar classloader/MusicPlayer.class\nmv MusicPlayer.jar $JAVA_HOME/jre/lib/ext/\n```\n\n这时 MusicPlayer.jar 已经被放置与 `$JAVA_HOME/jre/lib/ext` 目录下，同时把之前的 `MusicPlayer` `删除`，而且这一次`刻意`使用 `AppClassLoader` 来加载：\n```\nprivate static void loadClass() throws ClassNotFoundException {\n    ClassLoader appClassLoader = ClassLoader.getSystemClassLoader(); // AppClassLoader\n    Class<?> clazz = appClassLoader.loadClass(\"classloader.MusicPlayer\");\n    ClassLoader classLoader = clazz.getClassLoader();\n    System.out.printf(\"ClassLoader is %s\", classLoader.getClass().getSimpleName());\n}\n```\n打印结果为：\n```\nClassLoader is ExtClassLoader\n```\n说明即使直接用 `AppClassLoader` 去加载，它仍然会被 `ExtClassLoader` 加载到。\n\n## 从源码角度真正理解`双亲委托`加载机制\n上面已经通过一些例子了解了`双亲委托`的一些特性了，下面来看一下它的实现代码，加深理解。\n\n打开 `ClassLoader` 里的 `loadClass()` 方法，便是需要分析的源码了。这个方法里做了下面几件事：\n\n1. 检查目标class是否曾经加载过，如果加载过则直接返回；\n2. 如果没加载过，把加载请求传递给 parent 加载器去加载；\n3. 如果 parent 加载器加载成功，则直接返回；\n4. 如果 parent 未加载到，则自身调用 findClass() 方法进行寻找，并把寻找结果返回。\n\n代码如下：\n```\nprotected Class<?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n    synchronized (getClassLoadingLock(name)) {\n        // 1. 检查是否曾加载过\n        Class<?> c = findLoadedClass(name);\n        if (c == null) {\n            long t0 = System.nanoTime();\n            try {\n                if (parent != null) {\n                \t// 优先让 parent 加载器去加载\n                    c = parent.loadClass(name, false);\n                } else {\n                \t// 如无 parent，表示当前是 BootstrapClassLoader，调用 native 方法去 JVM 加载\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                // ClassNotFoundException thrown if class not found\n                // from the non-null parent class loader\n            }\n\n            if (c == null) {\n            \t// 如果 parent 均没有加载到目标class，调用自身的 findClass() 方法去搜索\n                long t1 = System.nanoTime();\n                c = findClass(name);\n\n                // this is the defining class loader; record the stats\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            }\n        }\n        if (resolve) {\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n\n// BootstrapClassLoader 会调用 native 方法去 JVM 加载\nprivate native Class<?> findBootstrapClass(String name);\n```\n\n看完实现源码相信能够有更完整的理解。\n\n## 类加载器最酷的一面：自定义类加载器\n前面提到了 Java 自带的加载器 `BootstrapClassLoader`、`AppClassLoader`和`ExtClassLoader`，这些都是 Java 已经提供好的。\n\n而真正有意思的，是 `自定义类加载器`，它允许我们在`运行时`可以从`本地磁盘或网络`上动态加载自定义类。这使得开发者可以动态修复某些有问题的类，热更新代码。\n\n下面来实现一个`网络类加载器`，这个加载器可以从网络上动态下载 .class 文件并加载到虚拟机中使用。\n\n后面我还会写作与 `热修复／动态更新` 相关的文章，这里先学习 Java 层 `NetworkClassLoader` 相关的原理。\n\n1. 作为一个 `NetworkClassLoader`，它首先要继承 `ClassLoader`；\n2. 然后它要实现`ClassLoader`内的 `findClass()` 方法。注意，不是`loadClass()`方法，因为`ClassLoader`提供了`loadClass()`（如上面的源码），它会基于`双亲委托`机制去搜索某个 class，直到搜索不到才会调用自身的`findClass()`，如果直接复写`loadClass()`，那还要实现`双亲委托`机制；\n3. 在 `findClass()` 方法里，要从网络上下载一个 .class 文件，然后转化成 Class 对象供虚拟机使用。\n\n具体实现代码如下：\n```\n/**\n * Load class from network\n */\npublic class NetworkClassLoader extends ClassLoader {\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        byte[] classData = downloadClassData(name); // 从远程下载\n        if (classData == null) {\n            super.findClass(name); // 未找到，抛异常\n        } else {\n            return defineClass(name, classData, 0, classData.length); // convert class byte data to Class<?> object\n        }\n        return null;\n    }\n\n    private byte[] downloadClassData(String name) {\n        // 从 localhost 下载 .class 文件\n        String path = \"http://localhost\" + File.separatorChar + \"java\" + File.separatorChar + name.replace('.', File.separatorChar) + \".class\"; \n\n        try {\n            URL url = new URL(path);\n            InputStream ins = url.openStream();\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int bufferSize = 4096;\n            byte[] buffer = new byte[bufferSize];\n            int bytesNumRead = 0;\n            while ((bytesNumRead = ins.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesNumRead); // 把下载的二进制数据存入 ByteArrayOutputStream\n            }\n            return baos.toByteArray();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public String getName() {\n        System.out.printf(\"Real NetworkClassLoader\\n\");\n        return \"networkClassLoader\";\n    }\n}\n```\n\n这个类的作用是从网络上（这里是本人的 local apache 服务器 http://localhost/java 上）目录里去下载对应的 .class 文件，并转换成 Class<?> 返回回去使用。\n\n下面我们来利用这个 `NetworkClassLoader` 去加载 localhost 上的 `MusicPlayer` 类：\n\n1. 首先把 `MusicPlayer.class` 放置于 `/Library/WebServer/Documents/java` （MacOS）目录下，由于 MacOS 自带 apache 服务器，这里是服务器的默认目录；\n2. 执行下面一段代码：\n```\nString className = \"classloader.NetworkClass\";\nNetworkClassLoader networkClassLoader = new NetworkClassLoader();\nClass<?> clazz  = networkClassLoader.loadClass(className);\n```\n3. 正常运行，加载 `http://localhost/java/classloader/MusicPlayer.class`成功。\n\n可以看出 `NetworkClassLoader` 可以正常工作，如果读者要用的话，只要稍微修改 url 的拼接方式即可自行使用。\n\n## 小结\n类加载方式是 Java 上非常创新的一项技术，给未来的热修复技术提供了可能。本文力求通过简单的语言和合适的例子来讲解其中`双亲委托机制`、`自定义加载器`等，并开发了自定义的`NetworkClassLoader`。\n\n当然，类加载是很有意思的技术，很难覆盖所有知识点，比如不同类加载器加载同一个类，得到的实例却不是同一个等等。\n\n之后我还会写作关于热修复／动态更新相关的技术，欢迎关注。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n","source":"_posts/Java-技术之类加载机制.md","raw":"title: Java 技术之类加载机制\ndate: 2017-05-08 20:46:38\npermalink: java_classloader\ncategories:\n  - 深入理解Java技术\ntags:\n  - Java\n  - Annotation\ncommentIssueId: 4  \n---\n> 类加载机制是 Java 语言的一大亮点，使得 Java 类可以被动态加载到 Java 虚拟机中。\n\n> 这次我们抛开术语和概念，从例子入手，由浅入深地讲解 Java 的类加载机制。\n\n> 本文涉及知识点：双亲委托机制、BootstrapClassLoader、ExtClassLoader、AppClassLoader、自定义网络类加载器等\n\n> 文章涉及代码：\nhttps://github.com/wingjay/HelloJava/blob/master/common/src/classloader/HelloClassLoader.java\n\n<!-- more -->\n\n## 什么是 Java 类加载机制?\nJava 虚拟机一般使用 Java 类的流程为：首先将开发者编写的 Java 源代码（.java文件）编译成 Java 字节码（.class文件），然后类加载器会读取这个 .class 文件，并转换成 java.lang.Class 的实例。有了该 Class 实例后，Java 虚拟机可以利用 newInstance 之类的方法创建其真正对象了。\n\nClassLoader 是 Java 提供的类加载器，绝大多数的类加载器都继承自 ClassLoader，它们被用来加载不同来源的 Class 文件。\n\n## Class 文件有哪些来源呢?\n上文提到了 ClassLoader 可以去加载多种来源的 Class，那么具体有哪些来源呢？\n\n首先，最常见的是开发者在应用程序中编写的类，这些类位于项目目录下；\n\n然后，有 Java 内部自带的`核心类`如 `java.lang`、`java.math`、`java.io` 等 package 内部的类，位于 `$JAVA_HOME/jre/lib/` 目录下，如 `java.lang.String` 类就是定义在 `$JAVA_HOME/jre/lib/rt.jar` 文件里；\n\n另外，还有 Java `核心扩展类`，位于 `$JAVA_HOME/jre/lib/ext` 目录下。开发者也可以把自己编写的类打包成 jar 文件放入该目录下；\n\n最后还有一种，是动态加载远程的 .class 文件。\n\n既然有这么多种类的来源，那么在 Java 里，是由某一个具体的 ClassLoader 来统一加载呢？还是由多个 ClassLoader 来协作加载呢？\n\n## 哪些 ClassLoader 负责加载上面几类 Class？\n实际上，针对上面四种来源的类，分别有不同的加载器负责加载。\n\n首先，我们来看级别最高的 `Java 核心类`，即`$JAVA_HOME/jre/lib` 里的核心 jar 文件。这些类是 Java 运行的基础类，由一个名为 `BootstrapClassLoader` 加载器负责加载，它也被称作 `根加载器／引导加载器`。注意，`BootstrapClassLoader` 比较特殊，它不继承 `ClassLoader`，而是由 JVM 内部实现；\n\n然后，需要加载 `Java 核心扩展类`，即 `$JAVA_HOME/jre/lib/ext` 目录下的 jar 文件。这些文件由 `ExtensionClassLoader` 负责加载，它也被称作 `扩展类加载器`。当然，用户如果把自己开发的 jar 文件放在这个目录，也会被 `ExtClassLoader` 加载；\n\n接下来是开发者在项目中编写的类，这些文件将由 `AppClassLoader` 加载器进行加载，它也被称作 `系统类加载器 System ClassLoader`；\n\n最后，如果想远程加载如（本地文件／网络下载）的方式，则必须要自己自定义一个 ClassLoader，复写其中的 `findClass()` 方法才能得以实现。\n\n因此能看出，Java 里提供了至少四类 `ClassLoader` 来分别加载不同来源的 Class。\n\n那么，这几种 ClassLoader 是如何协作来加载一个类呢？\n\n## 这些 ClassLoader 以何种方式来协作加载 String 类呢？\nString 类是 Java 自带的最常用的一个类，现在的问题是，JVM 将以何种方式把 String class 加载进来呢？\n\n我们来猜想下。\n\n首先，String 类属于 Java 核心类，位于 `$JAVA_HOME/jre/lib` 目录下。有的朋友会马上反应过来，上文中提过了，该目录下的类会由 `BootstrapClassLoader` 进行加载。没错，它确实是由 `BootstrapClassLoader` 进行加载。但，这种回答的前提是你已经知道了 String 在 `$JAVA_HOME/jre/lib` 目录下。\n\n那么，如果你并不知道 String 类究竟位于哪呢？或者我希望你去加载一个 `unknown` 的类呢？\n\n有的朋友这时会说，那很简单，只要去遍历一遍所有的类，看看这个 `unknown` 的类位于哪里，然后再用对应的加载器去加载。\n\n是的，思路很正确。那应该如何去遍历呢？\n\n比如，可以先遍历用户自己写的类，如果找到了就用 `AppClassLoader` 去加载；否则去遍历 Java 核心类目录，找到了就用 `BootstrapClassLoader` 去加载，否则就去遍历 Java 扩展类库，依次类推。\n\n这种思路方向是正确的，不过存在一个漏洞。\n\n假如开发者自己伪造了一个 `java.lang.String` 类，即在项目中创建一个包`java.lang`，包内创建一个名为 `String` 的类，这完全可以做到。那如果利用上面的遍历方法，是不是这个项目中用到的 String 不是都变成了这个伪造的 `java.lang.String` 类吗？如何解决这个问题呢？\n\n解决方法很简单，当查找一个类时，优先遍历最高级别的 Java 核心类，然后再去遍历 Java 核心扩展类，最后再遍历用户自定义类，而且这个遍历过程是一旦找到就立即停止遍历。\n\n在 Java 中，这种实现方式也称作 `双亲委托`。其实很简单，把 `BootstrapClassLoader` 想象为核心高层领导人， `ExtClassLoader` 想象为中层干部， `AppClassLoader` 想象为普通公务员。每次需要加载一个类，先获取一个系统加载器 `AppClassLoader` 的实例（ClassLoader.getSystemClassLoader()），然后向上级层层请求，由最上级优先去加载，如果上级觉得这些类不属于核心类，就可以下放到各子级负责人去自行加载。\n\n如下图所示：\n![双亲委托](/img/classloader/order.png)\n\n## 真的是按照`双亲委托`方式进行类加载吗？\n下面通过几个例子来验证上面的加载方式。\n\n#### 开发者自定义的类会被 `AppClassLoader` 加载吗？\n在项目中创建一个名为 `MusicPlayer` 的类文件，内容如下：\n```\npackage classloader;\n\npublic class MusicPlayer {\n\tpublic void print() {\n\t\tSystem.out.printf(\"Hi I'm MusicPlayer\");\n\t}\n}\n```\n\n然后来加载 `MusicPlayer`。\n\n```\nprivate static void loadClass() throws ClassNotFoundException {\n    Class<?> clazz = Class.forName(\"classloader.MusicPlayer\");\n    ClassLoader classLoader = clazz.getClassLoader();\n    System.out.printf(\"ClassLoader is %s\", classLoader.getClass().getSimpleName());\n}\n```\n打印结果为：\n```\nClassLoader is AppClassLoader\n```\n可以验证，`MusicPlayer` 是由 `AppClassLoader` 进行的加载。\n\n#### 验证 `AppClassLoader` 的双亲真的是 ExtClassLoader 和 BootstrapClassLoader 吗？\n这时发现 `AppClassLoader` 提供了一个 `getParent()` 的方法，来打印看看都是什么。\n```\nprivate static void printParent() throws ClassNotFoundException {\n        Class<?> clazz = Class.forName(\"classloader.MusicPlayer\");\n        ClassLoader classLoader = clazz.getClassLoader();\n        System.out.printf(\"currentClassLoader is %s\\n\", classLoader.getClass().getSimpleName());\n\n        while (classLoader.getParent() != null) {\n            classLoader = classLoader.getParent();\n            System.out.printf(\"Parent is %s\\n\", classLoader.getClass().getSimpleName());\n        }\n}\n```\n打印结果为：\n```\ncurrentClassLoader is AppClassLoader\nParent is ExtClassLoader\n```\n首先能看到 `ExtClassLoader` 确实是 `AppClassLoader` 的双亲，不过却没有看到 `BootstrapClassLoader`。事实上，上文就提过， `BootstrapClassLoader`比较特殊，它是由 JVM 内部实现的，所以 `ExtClassLoader.getParent() = null`。\n\n#### 如果把 MusicPlayer 类挪到 `$JAVA_HOME/jre/lib/ext` 目录下会发生什么？\n上文中说了，`ExtClassLoader` 会加载`$JAVA_HOME/jre/lib/ext` 目录下所有的 jar 文件。那来尝试下直接把 `MusicPlayer` 这个类放到 `$JAVA_HOME/jre/lib/ext` 目录下吧。\n\n利用下面命令可以把 MusicPlayer.java 编译打包成 jar 文件，并放置到对应目录。\n```\njavac classloader/MusicPlayer.java\njar cvf MusicPlayer.jar classloader/MusicPlayer.class\nmv MusicPlayer.jar $JAVA_HOME/jre/lib/ext/\n```\n\n这时 MusicPlayer.jar 已经被放置与 `$JAVA_HOME/jre/lib/ext` 目录下，同时把之前的 `MusicPlayer` `删除`，而且这一次`刻意`使用 `AppClassLoader` 来加载：\n```\nprivate static void loadClass() throws ClassNotFoundException {\n    ClassLoader appClassLoader = ClassLoader.getSystemClassLoader(); // AppClassLoader\n    Class<?> clazz = appClassLoader.loadClass(\"classloader.MusicPlayer\");\n    ClassLoader classLoader = clazz.getClassLoader();\n    System.out.printf(\"ClassLoader is %s\", classLoader.getClass().getSimpleName());\n}\n```\n打印结果为：\n```\nClassLoader is ExtClassLoader\n```\n说明即使直接用 `AppClassLoader` 去加载，它仍然会被 `ExtClassLoader` 加载到。\n\n## 从源码角度真正理解`双亲委托`加载机制\n上面已经通过一些例子了解了`双亲委托`的一些特性了，下面来看一下它的实现代码，加深理解。\n\n打开 `ClassLoader` 里的 `loadClass()` 方法，便是需要分析的源码了。这个方法里做了下面几件事：\n\n1. 检查目标class是否曾经加载过，如果加载过则直接返回；\n2. 如果没加载过，把加载请求传递给 parent 加载器去加载；\n3. 如果 parent 加载器加载成功，则直接返回；\n4. 如果 parent 未加载到，则自身调用 findClass() 方法进行寻找，并把寻找结果返回。\n\n代码如下：\n```\nprotected Class<?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n    synchronized (getClassLoadingLock(name)) {\n        // 1. 检查是否曾加载过\n        Class<?> c = findLoadedClass(name);\n        if (c == null) {\n            long t0 = System.nanoTime();\n            try {\n                if (parent != null) {\n                \t// 优先让 parent 加载器去加载\n                    c = parent.loadClass(name, false);\n                } else {\n                \t// 如无 parent，表示当前是 BootstrapClassLoader，调用 native 方法去 JVM 加载\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                // ClassNotFoundException thrown if class not found\n                // from the non-null parent class loader\n            }\n\n            if (c == null) {\n            \t// 如果 parent 均没有加载到目标class，调用自身的 findClass() 方法去搜索\n                long t1 = System.nanoTime();\n                c = findClass(name);\n\n                // this is the defining class loader; record the stats\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            }\n        }\n        if (resolve) {\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n\n// BootstrapClassLoader 会调用 native 方法去 JVM 加载\nprivate native Class<?> findBootstrapClass(String name);\n```\n\n看完实现源码相信能够有更完整的理解。\n\n## 类加载器最酷的一面：自定义类加载器\n前面提到了 Java 自带的加载器 `BootstrapClassLoader`、`AppClassLoader`和`ExtClassLoader`，这些都是 Java 已经提供好的。\n\n而真正有意思的，是 `自定义类加载器`，它允许我们在`运行时`可以从`本地磁盘或网络`上动态加载自定义类。这使得开发者可以动态修复某些有问题的类，热更新代码。\n\n下面来实现一个`网络类加载器`，这个加载器可以从网络上动态下载 .class 文件并加载到虚拟机中使用。\n\n后面我还会写作与 `热修复／动态更新` 相关的文章，这里先学习 Java 层 `NetworkClassLoader` 相关的原理。\n\n1. 作为一个 `NetworkClassLoader`，它首先要继承 `ClassLoader`；\n2. 然后它要实现`ClassLoader`内的 `findClass()` 方法。注意，不是`loadClass()`方法，因为`ClassLoader`提供了`loadClass()`（如上面的源码），它会基于`双亲委托`机制去搜索某个 class，直到搜索不到才会调用自身的`findClass()`，如果直接复写`loadClass()`，那还要实现`双亲委托`机制；\n3. 在 `findClass()` 方法里，要从网络上下载一个 .class 文件，然后转化成 Class 对象供虚拟机使用。\n\n具体实现代码如下：\n```\n/**\n * Load class from network\n */\npublic class NetworkClassLoader extends ClassLoader {\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        byte[] classData = downloadClassData(name); // 从远程下载\n        if (classData == null) {\n            super.findClass(name); // 未找到，抛异常\n        } else {\n            return defineClass(name, classData, 0, classData.length); // convert class byte data to Class<?> object\n        }\n        return null;\n    }\n\n    private byte[] downloadClassData(String name) {\n        // 从 localhost 下载 .class 文件\n        String path = \"http://localhost\" + File.separatorChar + \"java\" + File.separatorChar + name.replace('.', File.separatorChar) + \".class\"; \n\n        try {\n            URL url = new URL(path);\n            InputStream ins = url.openStream();\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int bufferSize = 4096;\n            byte[] buffer = new byte[bufferSize];\n            int bytesNumRead = 0;\n            while ((bytesNumRead = ins.read(buffer)) != -1) {\n                baos.write(buffer, 0, bytesNumRead); // 把下载的二进制数据存入 ByteArrayOutputStream\n            }\n            return baos.toByteArray();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public String getName() {\n        System.out.printf(\"Real NetworkClassLoader\\n\");\n        return \"networkClassLoader\";\n    }\n}\n```\n\n这个类的作用是从网络上（这里是本人的 local apache 服务器 http://localhost/java 上）目录里去下载对应的 .class 文件，并转换成 Class<?> 返回回去使用。\n\n下面我们来利用这个 `NetworkClassLoader` 去加载 localhost 上的 `MusicPlayer` 类：\n\n1. 首先把 `MusicPlayer.class` 放置于 `/Library/WebServer/Documents/java` （MacOS）目录下，由于 MacOS 自带 apache 服务器，这里是服务器的默认目录；\n2. 执行下面一段代码：\n```\nString className = \"classloader.NetworkClass\";\nNetworkClassLoader networkClassLoader = new NetworkClassLoader();\nClass<?> clazz  = networkClassLoader.loadClass(className);\n```\n3. 正常运行，加载 `http://localhost/java/classloader/MusicPlayer.class`成功。\n\n可以看出 `NetworkClassLoader` 可以正常工作，如果读者要用的话，只要稍微修改 url 的拼接方式即可自行使用。\n\n## 小结\n类加载方式是 Java 上非常创新的一项技术，给未来的热修复技术提供了可能。本文力求通过简单的语言和合适的例子来讲解其中`双亲委托机制`、`自定义加载器`等，并开发了自定义的`NetworkClassLoader`。\n\n当然，类加载是很有意思的技术，很难覆盖所有知识点，比如不同类加载器加载同一个类，得到的实例却不是同一个等等。\n\n之后我还会写作关于热修复／动态更新相关的技术，欢迎关注。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n\n","slug":"java_classloader","published":1,"updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm2q003mmoyx0jm0rpxp","sticky":0},{"title":"Java 技术之注解 Annotation","date":"2017-05-03T02:47:11.000Z","commentIssueId":5,"_content":"\n>`注解`这种语法本身很有意思，当前很多流行库如 `Dagger`、`ButterKnife`等都是基于注解这种语法。\n\n>熟练使用`注解`，既能让你的代码变得简洁易读，动态运行时执行你想要的操作，还能帮你生成代码，省去重复代码写作。\n\n> 本文涉及知识点：注解的生命周期，代码编辑时注解，编译时注解代码生成，运行时注解动态反射。\n\n<!-- more -->\n\n\n## 注解的生命周期与修饰对象\n对于 Java 代码从编写到运行有三个时期：代码编辑；编译成 `.class` 文件；读取到 JVM 运行。针对这三个时期有三种 `Annotation` 对应：\n```\nRetentionPolicy.SOURCE  // 只在代码编辑期生效\n\nRetentionPolicy.CLASS  // 在编译期生效，默认值\n\nRetentionPolicy.RUNTIME // 在代码运行时生效\n```\n\n除了生命周期，我们还可以指定 `Annotation` 用来指定的对象，比如修饰方法、类、变量、参数等，例如：\n```\n@Annotation \npublic void getName() {}\n\n@Annotation \nString name;\n\npublic void setName(@Annotation String name) {}\n```\n\nJava 提供了 `@Target` 这个`元注解`来指定某个 `Annotation` 修饰的目标对象。\n\n例如 `@Override` 是用来修饰方法的。\n```\n@Target(ElementType.METHOD)\npublic @interface Override {\n}\n```\n\n而 `@SuppressWarnings` 可以用来修饰很多，包括类、方法、变量等等。\n```\n@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})\npublic @interface SuppressWarnings {\n    String[] value();\n}\n```\n\n下面我们依次来看看不同生命周期的三类 Annotation。\n\n## 1. 代码编辑时注解\n这种 Annotation 只存在于代码编辑阶段（RetentionPolicy.SOURCE），主要功能是让 IDE 来为开发者提供 warning 检查。这一类注解只会在编辑代码时生效，当编译器把 .java 文件编译成 .class 文件时会自动丢弃。\n\n比较常用的有 `SuppressWarnings`，`Override`。\n\n`SuppressWarnings`是抑制编译器生成警告信息，比如我们调用了某个被标记为 `Deprecated` 的方法，这时编译器会发出警告，而我们又不得不使用这个方法时，就可以用`@SuppressWarnings`来抑制这个警告。\n```\n@Retention(RetentionPolicy.SOURCE)\npublic @interface SuppressWarnings {\n    String[] value();\n}\n```\n其作用如下图，`@SuppressWarnings(\"deprecation\")` 可以把 `deprecation` 相关的警告给抑制掉。\n\n\n![warning](/img/annotation/warning.png)\n![no-warning](/img/annotation/no-warning.png)\n\n`Override`用来标记重写父类某个方法，万一不小心写错方法名或者父类该方法发生改动，IDE 就会发出警告。\n```\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override {\n}\n```\n\n当然，对于开发者而言，这一类的 Annotation 我们很少自定义，更重要的是学会使用。其实 Java 和 Android 里提供了非常多有用的静态检查的 Annotation，有助于提高代码的正确率，省去人工的代码检查，方便代码给他人使用。\n\n之后的文章我会具体介绍 Android 内部[`support-annotations`]很多有趣有用的 Annotation。\n\n## 2. 运行时注解\n这一类注解是开发者广泛使用的。基本原理是利用`反射机制`在代码运行过程中动态地执行一些操作。关于 `反射机制` 我已经在之前的文章[Java 技术之反射](/2017/04/26/Java-技术之反射/)中细致阐述过了，不熟悉的读者可以去阅读。\n\n下面我们以两个例子来进行讲解。还是利用我们常用的 `UserBean` 对象为目标，对它内部的一些 `Annotation` 进行运行时处理。\n```\npublic class UserBean {\n\n    @Alias(\"user_name\")\n    public String userName;\n\n    @Alias(\"user_id\")\n    private long userId;\n\n    public UserBean(String userName, long userId) {\n        this.userName = userName;\n        this.userId = userId;\n    }\n\n    public String getName() {\n        return userName;\n    }\n\n    public long getId() {\n        return userId;\n    }\n\n    @Test(value = \"static_method\", id = 1)\n    public static void staticMethod() {\n        System.out.printf(\"I'm a static method\\n\");\n    }\n\n    @Test(value = \"public_method\", id = 2)\n    public void publicMethod() {\n        System.out.println(\"I'm a public method\\n\");\n    }\n\n    @Test(value = \"private_method\", id = 3)\n    private void privateMethod() {\n        System.out.println(\"I'm a private method\\n\");\n    }\n\n    @Test(id = 4)\n    public void testFailure() {\n        throw new RuntimeException(\"Test failure\");\n    }\n}\n```\n\n这次我在 `UserBean` 里面创建了两个自定义的 `Annotation`: `Alias` 和 `Test`，前者是用来设置变量的别名并在运行时打印，后者是调用所有被`Test`标记的方法，得出测试通过率。当然，这两个功能目前完全没有实现，只是标记了一下而已。下面我们依次来实现这两个Annotation的功能。\n\n#### Alias 功能实现：设置变量别名并在运行时打印别名\n首先，我们要创建 `Alias` 这个注解。那么要明确三个方面：\n\n- 生命周期是什么？\n- 针对的目标是什么类型？\n- 内部是否有参数？\n\n针对 `Alias` 的功能，我们可以作如下回答：\n- 生命周期是`运行时`，因为要动态打印出变量的别名 -> @Retention(RetentionPolicy.RUNTIME)\n- 针对的目标是 `变量` -> @Target(ElementType.FIELD)\n- 内部需要维护一个 String 型的变量来保存别名 -> String value();\n\n因此可以得到\n```\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Alias {\n    String value();\n}\n```\n\n`Alias` 定义得到了，接下来我们要实现它的功能了，即在运行时取出变量的别名并打印。\n\n代码如下：\n```\n/**\n * print alias during runtime\n */\nprivate static void printAlias(Object userBeanObject) {\n    for (Field field : userBeanObject.getClass().getDeclaredFields()) {\n        if (field.isAnnotationPresent(Alias.class)) {\n            Alias alias = field.getAnnotation(Alias.class);\n            System.out.println(alias.value());\n        }\n    }\n}\n```\n\n过程很简单，利用反射机制，把 `userBeanObject` 对应 Class 里所有的成员变量都找到，找出其中被 `Alias` 修饰的成员变量，然后把真实注解 `Alias` 对象取出来，把内部的 `value` 打印出来即可。 \n\n#### `Test`功能实现：调用所有被`Test`标记的方法，得出测试通过率\n同样我们要回答上面三个问题：生命周期，针对对象类型和内部参数，回答是：\n\n- 生命周期：由于是`动态运行时`去遍历这些 `Test` 的存在，因此是 `RUNTIME`;\n- 针对对象类型：因为是修饰`方法`的，因此是 `@Target(ElementType.METHOD)`;\n- 内部参数：由于需要记录方法的`名称`和对应的`id`，因此需要 `String value();` `int id;`\n\n得到如下：\n```\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test {\n    String value() default \"\"; // 如果没有设置，那么直接取函数方法名\n    int id();\n}\n```\n\n接下来我们需要找到所有被 `@Test` 修饰的方法，并逐一调用。注意两点：\n1. 就算是 `private` 和 `static` 修饰的方法也需要调用；\n2. 在执行每个方法前后都要打印相关log，表示开始测试该方法。打印的内容要含有 `value` 和 `id`， 如果 `@Test` 里的 `value` 没有设置值，那么就取函数名为值。\n\n可以看出，在 `UserBean` 里已经定义好了三个被 `@Test` 修饰的方法了。\n```\n    @Test(value = \"static_method\", id = 1)\n    public static void staticMethod() {\n        System.out.printf(\"I'm a static method\\n\");\n    }\n\n    @Test(value = \"public_method\", id = 2)\n    public void publicMethod() {\n        System.out.println(\"I'm a public method\\n\");\n    }\n\n    @Test(value = \"private_method\", id = 3)\n    private void privateMethod() {\n        System.out.println(\"I'm a private method\\n\");\n    }\n\n    @Test(id = 4)\n    public void testFailure() {\n        throw new RuntimeException(\"Test failure\");\n    }\n```\n\n接下来我们实现 `@Test` 的具体功能：\n```\n/**\n * Test methods which are be annotated with @Test\n */\nprivate static void doTest(Object object) {\n    Method[] methods = object.getClass().getDeclaredMethods();\n    for (Method method : methods) {\n        if (method.isAnnotationPresent(Test.class)) {\n            Test test = method.getAnnotation(Test.class);\n            try {\n                String methodName = test.value().length() == 0 ? method.getName() : test.value(); // if test.value() is empty, use `method.getName()`\n                System.out.printf(\"Testing. methodName: %s, id: %s\\n\", methodName, test.id());\n\n                if (Modifier.isStatic(method.getModifiers())) {\n                    method.invoke(null); // static method\n                } else if (Modifier.isPrivate(method.getModifiers())) {\n                    method.setAccessible(true);  // private method\n                    method.invoke(object);\n                } else {\n                    method.invoke(object);  // public method\n                }\n\n                System.out.printf(\"PASS: Method id: %s\\n\", test.id());\n            } catch (Exception e) {\n                System.out.printf(\"FAIL: Method id: %s\\n\", test.id());\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n打印结果如下：\n\n```\nTesting. methodName: static_method, id: 1\nI'm a static method\nPASS: Method id: 1\n\nTesting. methodName: public_method, id: 2\nI'm a public method\nPASS: Method id: 2\n\nTesting. methodName: private_method, id: 3\nI'm a private method\nPASS: Method id: 3\n\nTesting. methodName: testFailure, id: 4\nFAIL: Method id: 4\n```\n\n全部正常打印。其中，由于 `testFailure()` 的 `@Test` 里未设置 `value()`，因此直接打印了它的函数名；针对`static`方法，直接调用`method.invoke(null)`；针对`private`，利用`method.setAccessible(true);`获取了权限。\n\n当然这里有一点要注意，我在 `invoke method` 时，直接使用 `method.invoke(object);`，没有传任何参数。这是由于我在 `UserBean` 里写的几个方法都不用传参数。如果需要传参数的话，那就还需要再单独判断是哪个函数，并传递对应的参数进去。\n\n\n## 3. 编译时注解\n当 .java 文件写好了准备进行编译时，我们有另一种 Annotation 可以在这时发挥效果。\n\n我们知道，Java 源代码编译的过程会对所有的文件进行扫描，而`编译时 Annotation` 的作用就是`在编译过程中生成代码`。在 Java 里提供了 apt 工具来处理注解，同时有一套 Mirror API 来描述编译时的程序语义结构，它可以在编译时获取到被注解 Java 元素的信息以方便我们处理。该处理过程的核心是编写注解处理器 `AnnotationProcessor` 接口。\n\n大概说明下整体的过程。\n\n假设我们希望用某个 `Annotation`：`@Inject` 来生成一些代码，那么我们要做下面几步：\n\n##### 定义 @Inject\n由于它是编译时注解，因此是 `RetentionPolicy.CLASS`，对象的话就是变量和构造函数，因此得到：\n```\n@Retention(RetentionPolicy.CLASS)\n@Target({ElementType.CONSTRUCTOR, ElementType.FIELD})\npublic @interface Inject {\n}\n```\n\n##### 定义 Processor 类\n```\n// Helper to define the Processor\n@AutoService(Processor.class)\n// Define the supported Java source code version\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\n// Define which annotation you want to process\n@SupportedAnnotationTypes(\"com.wingjay.annotation.Inject\")\npublic class MyProcessor extends AbstractProcessor {  ...  }\n```\n##### 重写 `Processor` 内部的 `process` 方法\n这个 `process` 方法会在编译时被执行到，我们可以在这个方法里进行代码生成的工作。\n\n关于具体的代码生成部分，可以利用 `Square` 提供的 `JavaPoet` 工具：https://github.com/square/javapoet\n\n下面有一些代码片段供参考：\n```\n@Override\npublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n\t//扫描所有 Inject 标记过的元素\n    Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(Inject.class);\n    Set<? extends TypeElement> typeElements = ElementFilter.typesIn(elements);\n    for (TypeElement element : typeElements) {\n\n    \t// 拼接待生成代码\n    \tClassName currentType = ClassName.get(element);\n      \tMethodSpec.Builder builder = MethodSpec.methodBuilder(\"fromCursor\")\n\t       .returns(currentType)\n\t       .addModifiers(Modifier.STATIC)\n\t       .addModifiers(Modifier.PUBLIC)\n\t       .addParameter(ClassName.get(\"android.database\", \"Cursor\"), \"cursor\");\n\n\t    // 将这些拼接代码写入文件\n        String className = ... // 设置你要生成的代码class名字\n        JavaFileObject sourceFile =   processingEnv.getFiler().createSourceFile(className, element);\n        Writer writer = sourceFile.openWriter();\n        javaFile.writeTo(writer);\n        writer.close();  \n\t}\n\treturn false;\n}\n```\n\n\n## 小结\n本文在前文[Java 技术之反射](/2017/04/26/Java-技术之反射/)的基础上，对 Java 的注解 `Annotation` 做了一定的介绍。\n\n熟练使用 `Annotation` 能在很多时候帮助代码变得更简洁，也能帮我们生成很多代码，免除重复写作相同代码，是一种很高效的编程方式。\n\n下一篇我会为 Android 的小伙伴介绍不少你可能不太知道但非常好用的 `Android Annotation`。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n","source":"_posts/Java-技术之注解-Annotation.md","raw":"title: Java 技术之注解 Annotation\ndate: 2017-05-03 10:47:11\ncategories:\n  - 深入理解Java技术\ntags: \n  - Java\n  - Annotation\ncommentIssueId: 5  \n---\n\n>`注解`这种语法本身很有意思，当前很多流行库如 `Dagger`、`ButterKnife`等都是基于注解这种语法。\n\n>熟练使用`注解`，既能让你的代码变得简洁易读，动态运行时执行你想要的操作，还能帮你生成代码，省去重复代码写作。\n\n> 本文涉及知识点：注解的生命周期，代码编辑时注解，编译时注解代码生成，运行时注解动态反射。\n\n<!-- more -->\n\n\n## 注解的生命周期与修饰对象\n对于 Java 代码从编写到运行有三个时期：代码编辑；编译成 `.class` 文件；读取到 JVM 运行。针对这三个时期有三种 `Annotation` 对应：\n```\nRetentionPolicy.SOURCE  // 只在代码编辑期生效\n\nRetentionPolicy.CLASS  // 在编译期生效，默认值\n\nRetentionPolicy.RUNTIME // 在代码运行时生效\n```\n\n除了生命周期，我们还可以指定 `Annotation` 用来指定的对象，比如修饰方法、类、变量、参数等，例如：\n```\n@Annotation \npublic void getName() {}\n\n@Annotation \nString name;\n\npublic void setName(@Annotation String name) {}\n```\n\nJava 提供了 `@Target` 这个`元注解`来指定某个 `Annotation` 修饰的目标对象。\n\n例如 `@Override` 是用来修饰方法的。\n```\n@Target(ElementType.METHOD)\npublic @interface Override {\n}\n```\n\n而 `@SuppressWarnings` 可以用来修饰很多，包括类、方法、变量等等。\n```\n@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})\npublic @interface SuppressWarnings {\n    String[] value();\n}\n```\n\n下面我们依次来看看不同生命周期的三类 Annotation。\n\n## 1. 代码编辑时注解\n这种 Annotation 只存在于代码编辑阶段（RetentionPolicy.SOURCE），主要功能是让 IDE 来为开发者提供 warning 检查。这一类注解只会在编辑代码时生效，当编译器把 .java 文件编译成 .class 文件时会自动丢弃。\n\n比较常用的有 `SuppressWarnings`，`Override`。\n\n`SuppressWarnings`是抑制编译器生成警告信息，比如我们调用了某个被标记为 `Deprecated` 的方法，这时编译器会发出警告，而我们又不得不使用这个方法时，就可以用`@SuppressWarnings`来抑制这个警告。\n```\n@Retention(RetentionPolicy.SOURCE)\npublic @interface SuppressWarnings {\n    String[] value();\n}\n```\n其作用如下图，`@SuppressWarnings(\"deprecation\")` 可以把 `deprecation` 相关的警告给抑制掉。\n\n\n![warning](/img/annotation/warning.png)\n![no-warning](/img/annotation/no-warning.png)\n\n`Override`用来标记重写父类某个方法，万一不小心写错方法名或者父类该方法发生改动，IDE 就会发出警告。\n```\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override {\n}\n```\n\n当然，对于开发者而言，这一类的 Annotation 我们很少自定义，更重要的是学会使用。其实 Java 和 Android 里提供了非常多有用的静态检查的 Annotation，有助于提高代码的正确率，省去人工的代码检查，方便代码给他人使用。\n\n之后的文章我会具体介绍 Android 内部[`support-annotations`]很多有趣有用的 Annotation。\n\n## 2. 运行时注解\n这一类注解是开发者广泛使用的。基本原理是利用`反射机制`在代码运行过程中动态地执行一些操作。关于 `反射机制` 我已经在之前的文章[Java 技术之反射](/2017/04/26/Java-技术之反射/)中细致阐述过了，不熟悉的读者可以去阅读。\n\n下面我们以两个例子来进行讲解。还是利用我们常用的 `UserBean` 对象为目标，对它内部的一些 `Annotation` 进行运行时处理。\n```\npublic class UserBean {\n\n    @Alias(\"user_name\")\n    public String userName;\n\n    @Alias(\"user_id\")\n    private long userId;\n\n    public UserBean(String userName, long userId) {\n        this.userName = userName;\n        this.userId = userId;\n    }\n\n    public String getName() {\n        return userName;\n    }\n\n    public long getId() {\n        return userId;\n    }\n\n    @Test(value = \"static_method\", id = 1)\n    public static void staticMethod() {\n        System.out.printf(\"I'm a static method\\n\");\n    }\n\n    @Test(value = \"public_method\", id = 2)\n    public void publicMethod() {\n        System.out.println(\"I'm a public method\\n\");\n    }\n\n    @Test(value = \"private_method\", id = 3)\n    private void privateMethod() {\n        System.out.println(\"I'm a private method\\n\");\n    }\n\n    @Test(id = 4)\n    public void testFailure() {\n        throw new RuntimeException(\"Test failure\");\n    }\n}\n```\n\n这次我在 `UserBean` 里面创建了两个自定义的 `Annotation`: `Alias` 和 `Test`，前者是用来设置变量的别名并在运行时打印，后者是调用所有被`Test`标记的方法，得出测试通过率。当然，这两个功能目前完全没有实现，只是标记了一下而已。下面我们依次来实现这两个Annotation的功能。\n\n#### Alias 功能实现：设置变量别名并在运行时打印别名\n首先，我们要创建 `Alias` 这个注解。那么要明确三个方面：\n\n- 生命周期是什么？\n- 针对的目标是什么类型？\n- 内部是否有参数？\n\n针对 `Alias` 的功能，我们可以作如下回答：\n- 生命周期是`运行时`，因为要动态打印出变量的别名 -> @Retention(RetentionPolicy.RUNTIME)\n- 针对的目标是 `变量` -> @Target(ElementType.FIELD)\n- 内部需要维护一个 String 型的变量来保存别名 -> String value();\n\n因此可以得到\n```\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Alias {\n    String value();\n}\n```\n\n`Alias` 定义得到了，接下来我们要实现它的功能了，即在运行时取出变量的别名并打印。\n\n代码如下：\n```\n/**\n * print alias during runtime\n */\nprivate static void printAlias(Object userBeanObject) {\n    for (Field field : userBeanObject.getClass().getDeclaredFields()) {\n        if (field.isAnnotationPresent(Alias.class)) {\n            Alias alias = field.getAnnotation(Alias.class);\n            System.out.println(alias.value());\n        }\n    }\n}\n```\n\n过程很简单，利用反射机制，把 `userBeanObject` 对应 Class 里所有的成员变量都找到，找出其中被 `Alias` 修饰的成员变量，然后把真实注解 `Alias` 对象取出来，把内部的 `value` 打印出来即可。 \n\n#### `Test`功能实现：调用所有被`Test`标记的方法，得出测试通过率\n同样我们要回答上面三个问题：生命周期，针对对象类型和内部参数，回答是：\n\n- 生命周期：由于是`动态运行时`去遍历这些 `Test` 的存在，因此是 `RUNTIME`;\n- 针对对象类型：因为是修饰`方法`的，因此是 `@Target(ElementType.METHOD)`;\n- 内部参数：由于需要记录方法的`名称`和对应的`id`，因此需要 `String value();` `int id;`\n\n得到如下：\n```\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Test {\n    String value() default \"\"; // 如果没有设置，那么直接取函数方法名\n    int id();\n}\n```\n\n接下来我们需要找到所有被 `@Test` 修饰的方法，并逐一调用。注意两点：\n1. 就算是 `private` 和 `static` 修饰的方法也需要调用；\n2. 在执行每个方法前后都要打印相关log，表示开始测试该方法。打印的内容要含有 `value` 和 `id`， 如果 `@Test` 里的 `value` 没有设置值，那么就取函数名为值。\n\n可以看出，在 `UserBean` 里已经定义好了三个被 `@Test` 修饰的方法了。\n```\n    @Test(value = \"static_method\", id = 1)\n    public static void staticMethod() {\n        System.out.printf(\"I'm a static method\\n\");\n    }\n\n    @Test(value = \"public_method\", id = 2)\n    public void publicMethod() {\n        System.out.println(\"I'm a public method\\n\");\n    }\n\n    @Test(value = \"private_method\", id = 3)\n    private void privateMethod() {\n        System.out.println(\"I'm a private method\\n\");\n    }\n\n    @Test(id = 4)\n    public void testFailure() {\n        throw new RuntimeException(\"Test failure\");\n    }\n```\n\n接下来我们实现 `@Test` 的具体功能：\n```\n/**\n * Test methods which are be annotated with @Test\n */\nprivate static void doTest(Object object) {\n    Method[] methods = object.getClass().getDeclaredMethods();\n    for (Method method : methods) {\n        if (method.isAnnotationPresent(Test.class)) {\n            Test test = method.getAnnotation(Test.class);\n            try {\n                String methodName = test.value().length() == 0 ? method.getName() : test.value(); // if test.value() is empty, use `method.getName()`\n                System.out.printf(\"Testing. methodName: %s, id: %s\\n\", methodName, test.id());\n\n                if (Modifier.isStatic(method.getModifiers())) {\n                    method.invoke(null); // static method\n                } else if (Modifier.isPrivate(method.getModifiers())) {\n                    method.setAccessible(true);  // private method\n                    method.invoke(object);\n                } else {\n                    method.invoke(object);  // public method\n                }\n\n                System.out.printf(\"PASS: Method id: %s\\n\", test.id());\n            } catch (Exception e) {\n                System.out.printf(\"FAIL: Method id: %s\\n\", test.id());\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n打印结果如下：\n\n```\nTesting. methodName: static_method, id: 1\nI'm a static method\nPASS: Method id: 1\n\nTesting. methodName: public_method, id: 2\nI'm a public method\nPASS: Method id: 2\n\nTesting. methodName: private_method, id: 3\nI'm a private method\nPASS: Method id: 3\n\nTesting. methodName: testFailure, id: 4\nFAIL: Method id: 4\n```\n\n全部正常打印。其中，由于 `testFailure()` 的 `@Test` 里未设置 `value()`，因此直接打印了它的函数名；针对`static`方法，直接调用`method.invoke(null)`；针对`private`，利用`method.setAccessible(true);`获取了权限。\n\n当然这里有一点要注意，我在 `invoke method` 时，直接使用 `method.invoke(object);`，没有传任何参数。这是由于我在 `UserBean` 里写的几个方法都不用传参数。如果需要传参数的话，那就还需要再单独判断是哪个函数，并传递对应的参数进去。\n\n\n## 3. 编译时注解\n当 .java 文件写好了准备进行编译时，我们有另一种 Annotation 可以在这时发挥效果。\n\n我们知道，Java 源代码编译的过程会对所有的文件进行扫描，而`编译时 Annotation` 的作用就是`在编译过程中生成代码`。在 Java 里提供了 apt 工具来处理注解，同时有一套 Mirror API 来描述编译时的程序语义结构，它可以在编译时获取到被注解 Java 元素的信息以方便我们处理。该处理过程的核心是编写注解处理器 `AnnotationProcessor` 接口。\n\n大概说明下整体的过程。\n\n假设我们希望用某个 `Annotation`：`@Inject` 来生成一些代码，那么我们要做下面几步：\n\n##### 定义 @Inject\n由于它是编译时注解，因此是 `RetentionPolicy.CLASS`，对象的话就是变量和构造函数，因此得到：\n```\n@Retention(RetentionPolicy.CLASS)\n@Target({ElementType.CONSTRUCTOR, ElementType.FIELD})\npublic @interface Inject {\n}\n```\n\n##### 定义 Processor 类\n```\n// Helper to define the Processor\n@AutoService(Processor.class)\n// Define the supported Java source code version\n@SupportedSourceVersion(SourceVersion.RELEASE_7)\n// Define which annotation you want to process\n@SupportedAnnotationTypes(\"com.wingjay.annotation.Inject\")\npublic class MyProcessor extends AbstractProcessor {  ...  }\n```\n##### 重写 `Processor` 内部的 `process` 方法\n这个 `process` 方法会在编译时被执行到，我们可以在这个方法里进行代码生成的工作。\n\n关于具体的代码生成部分，可以利用 `Square` 提供的 `JavaPoet` 工具：https://github.com/square/javapoet\n\n下面有一些代码片段供参考：\n```\n@Override\npublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n\t//扫描所有 Inject 标记过的元素\n    Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(Inject.class);\n    Set<? extends TypeElement> typeElements = ElementFilter.typesIn(elements);\n    for (TypeElement element : typeElements) {\n\n    \t// 拼接待生成代码\n    \tClassName currentType = ClassName.get(element);\n      \tMethodSpec.Builder builder = MethodSpec.methodBuilder(\"fromCursor\")\n\t       .returns(currentType)\n\t       .addModifiers(Modifier.STATIC)\n\t       .addModifiers(Modifier.PUBLIC)\n\t       .addParameter(ClassName.get(\"android.database\", \"Cursor\"), \"cursor\");\n\n\t    // 将这些拼接代码写入文件\n        String className = ... // 设置你要生成的代码class名字\n        JavaFileObject sourceFile =   processingEnv.getFiler().createSourceFile(className, element);\n        Writer writer = sourceFile.openWriter();\n        javaFile.writeTo(writer);\n        writer.close();  \n\t}\n\treturn false;\n}\n```\n\n\n## 小结\n本文在前文[Java 技术之反射](/2017/04/26/Java-技术之反射/)的基础上，对 Java 的注解 `Annotation` 做了一定的介绍。\n\n熟练使用 `Annotation` 能在很多时候帮助代码变得更简洁，也能帮我们生成很多代码，免除重复写作相同代码，是一种很高效的编程方式。\n\n下一篇我会为 Android 的小伙伴介绍不少你可能不太知道但非常好用的 `Android Annotation`。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n","slug":"Java-技术之注解-Annotation","published":1,"updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm2s003rmoyxpb95efeo","sticky":0},{"title":"Java 技术之垃圾回收机制","date":"2017-05-24T13:19:26.000Z","commentIssueId":2,"_content":"\n>垃圾回收机制是 Java 非常重要的特性之一，也是面试题的常客。它让开发者无需关注空间的创建和释放，而是以守护进程的形式在后台自动回收垃圾。这样做不仅提高了开发效率，更改善了内存的使用状况。\n\n>今天本文来对垃圾回收机制进行讲解，主要涉及下面几个问题：\n- 什么是堆内存？\n- 什么是垃圾？\n- 有哪些方法回收这些垃圾？\n- 什么是分代回收机制？\n\n<!-- more -->\n\n## 什么是 Java 堆内存\n堆是在 JVM 启动时创建的，主要用来维护运行时数据，如运行过程中创建的对象和数组都是基于这块内存空间。Java 堆是非常重要的元素，如果我们动态创建的对象没有得到及时回收，持续堆积，最后会导致堆空间被占满，内存溢出。\n\n因此，Java 提供了一种垃圾回收机制，在后台创建一个守护进程。该进程会在内存紧张的时候自动跳出来，把堆空间的垃圾全部进行回收，从而保证程序的正常运行。\n\n## 那什么是垃圾呢？\n所谓“垃圾”，就是指所有不再存活的对象。常见的判断是否存活有两种方法：引用计数法和可达性分析。\n\n### 引用计数法\n为每一个创建的对象分配一个引用计数器，用来存储该对象被引用的个数。当该个数为零，意味着没有人再使用这个对象，可以认为“对象死亡”。但是，这种方案存在严重的问题，就是无法检测“循环引用”：当两个对象互相引用，即时它俩都不被外界任何东西引用，它俩的计数都不为零，因此永远不会被回收。而实际上对于开发者而言，这两个对象已经完全没有用处了。\n\n因此，Java 里没有采用这样的方案来判定对象的“存活性”。\n\n### 可达性分析\n这种方案是目前主流语言里采用的对象存活性判断方案。基本思路是把所有引用的对象想象成一棵树，从树的根结点 GC Roots 出发，持续遍历找出所有连接的树枝对象，这些对象则被称为“可达”对象，或称“存活”对象。其余的对象则被视为“死亡”的“不可达”对象，或称“垃圾”。\n\n参考下图，object5,object6和object7便是不可达对象，视为“死亡状态”，应该被垃圾回收器回收。\n\n![](/img/gc/reachable.JPG)\n\n#### GC Roots 究竟指谁呢？\n我们可以猜测，GC Roots 本身一定是可达的，这样从它们出发遍历到的对象才能保证一定可达。那么，Java 里有哪些对象是一定可达呢？主要有以下四种：\n- 虚拟机栈（帧栈中的本地变量表）中引用的对象。\n- 方法区中静态属性引用的对象。\n- 方法区中常量引用的对象。\n- 本地方法栈中JNI引用的对象。\n\n不少读者可能对这些 GC Roots 似懂非懂，这涉及到 JVM 本身的内存结构等等，未来的文章会再做深入讲解。这里只要知道有这么几种类型的 GC Roots，每次垃圾回收器会从这些根结点开始遍历寻找所有可达节点。\n\n## 有哪些方式来回收这些垃圾呢？\n上面已经知道，所有GC Roots不可达的对象都称为垃圾，参考下图，黑色的表示垃圾，灰色表示存活对象，绿色表示空白空间。\n\n![](/img/gc/garbage.png)\n\n那么，我们如何来回收这些垃圾呢？\n\n#### 标记－清理\n第一步，所谓“标记”就是利用可达性遍历堆内存，把“存活”对象和“垃圾”对象进行标记，得到的结果如上图；\n第二步，既然“垃圾”已经标记好了，那我们再遍历一遍，把所有“垃圾”对象所占的空间直接`清空`即可。\n\n结果如下：\n![](/img/gc/mark-sweep.png)\n\n这便是`标记－清理`方案，`简单方便`，但是容易产生`内存碎片`。\n\n#### 标记－整理\n既然上面的方法会产生内存碎片，那好，我在清理的时候，把所有`存活`对象扎堆到同一个地方，让它们待在一起，这样就没有内存碎片了。\n\n结果如下：\n![](/img/gc/mark-compact.png)\n\n这两种方案适合`存活对象多，垃圾少`的情况，它只需要清理掉少量的垃圾，然后挪动下存活对象就可以了。\n\n#### 复制\n这种方法比较粗暴，直接把堆内存分成两部分，一段时间内只允许在其中一块内存上进行分配，当这块内存被分配完后，则执行垃圾回收，把所有`存活`对象全部复制到另一块内存上，当前内存则直接全部清空。\n\n参考下图：\n![](/img/gc/copying.png)\n\n起初时只使用上面部分的内存，直到内存使用完毕，才进行垃圾回收，把所有存活对象搬到下半部分，并把上半部分进行清空。\n\n这种做法不容易产生碎片，也简单粗暴；但是，它意味着你在一段时间内只能使用一部分的内存，超过这部分内存的话就意味着堆内存里频繁的`复制清空`。\n\n这种方案适合`存活对象少，垃圾多`的情况，这样在复制时就不需要复制多少对象过去，多数垃圾直接被清空处理。\n\n## Java 的分代回收机制\n上面我们看到有至少三种方法来回收内存，那么 Java 里是如何选择利用这三种回收算法呢？是只用一种还是三种都用呢？\n\n### Java 的堆结构\n在选择回收算法前，我们先来看一下 Java 堆的结构。\n\n一块 Java 堆空间一般分成三部分，这三部分用来存储三类数据：\n- 刚刚创建的对象。在代码运行时会持续不断地创造新的对象，这些新创建的对象会被统一放在一起。因为有很多局部变量等在新创建后很快会变成`不可达`的对象，`快速死去`，因此这块区域的特点是`存活对象少，垃圾多`。形象点描述这块区域为：`新生代`；\n- 存活了一段时间的对象。这些对象早早就被创建了，而且一直活了下来。我们把这些`存活时间较长`的对象放在一起，它们的特点是`存活对象多，垃圾少`。形象点描述这块区域为：`老年代`；\n- 永久存在的对象。比如一些静态文件，这些对象的特点是不需要垃圾回收，永远存活。形象点描述这块区域为：`永久代`。（不过在 Java 8 里已经把`永久代`删除了，把这块内存空间给了`元空间`，后续文章再讲解。）\n\n也就是说，常规的 Java 堆至少包括了 `新生代` 和 `老年代` 两块内存区域，而且这两块区域有很明显的特征：\n- 新生代：存活对象少、垃圾多\n- 老年代：存活对象多、垃圾少\n\n\n结合新生代／老年代的存活对象特点和之前提过的几种垃圾回收算法，可以得到如下的回收方案：\n### 新生代－`复制`回收机制\n对于新生代区域，由于每次 GC 都会有大量新对象死去，只有少量存活。因此采用`复制`回收算法，GC 时把少量的存活对象复制过去即可。\n\n那么如何设计这个`复制`算法比较好呢？有以下几种方式：\n\n##### 思路1. 把内存均分成 `1:1` 两等份\n如下图拆分内存。\n![](/img/gc/young_1.png)\n\n每次只使用一半的内存，当这一半满了后，就进行垃圾回收，把存活的对象直接复制到另一半内存，并清空当前一半的内存。\n\n这种分法的缺陷是相当于只有一半的可用内存，对于新生代而言，新对象持续不断地被创建，如果只有一半可用内存，那显然要持续不断地进行垃圾回收工作，反而影响到了正常程序的运行，得不偿失。\n\n##### 思路2. 把内存按 `9:1` 分\n既然上面的分法导致可用内存只剩一半，那么我做些调整，把 `1:1`变成`9:1`，\n![](/img/gc/young_2.png)\n\n最开始在 `9` 的内存区使用，当 `9` 快要满时，执行复制回收，把 `9` 内仍然存活的对象复制到 `1` 区，并清空 `9` 区。\n\n这样看起来是比上面的方法好了，但是它存在比较严重的问题。\n\n当我们把 `9` 区存活对象复制到 `1` 区时，由于内存空间比例相差比较大，所以很有可能 `1` 区放不满，此时就不得不把对象移到 `老年区`。而这就意味着，可能会有一部分 `并不老` 的 `9` 区对象由于 `1` 区放不下了而被放到了 `老年区`，可想而知，这破坏了 `老年区` 的规则。或者说，一定程度上的 `老年区` 并不一定全是 `老年对象`。\n\n那应该如何才能把真正比较 `老` 的对象挪到 `老年区` 呢？ \n\n##### 思路3. 把内存按 `8:1:1` 分\n![](/img/gc/young_3.png)\n\n既然 `9:1` 有可能把年轻对象放到 `老年区`，那就换成 `8:1:1`，依次取名为 `Eden`、`Survivor A`、`Survivor B`区，其中`Eden`意为伊甸园，形容有很多新生对象在里面创建；`Survivor`区则为幸存者，即经历 GC 后仍然存活下来的对象。\n\n工作原理如下：\n1. 首先，`Eden`区最大，对外提供堆内存。当 `Eden` 区快要满了，则进行 `Minor GC`，把存活对象放入`Survivor A`区，清空 `Eden` 区；\n2. `Eden`区被清空后，继续对外提供堆内存；\n3. 当`Eden`区再次被填满，此时对`Eden`区和`Survivor A`区同时进行 `Minor GC`，把存活对象放入`Survivor B`区，同时清空`Eden` 区和`Survivor A`区；\n4. `Eden`区继续对外提供堆内存，并重复上述过程，即在`Eden`区填满后，把`Eden`区和某个`Survivor`区的存活对象放到另一个`Survivor`区；\n5. 当某个`Survivor`区被填满，且仍有对象未被复制完毕时，或者某些对象在反复`Survive` `15` 次左右时，则把这部分剩余对象放到`Old`区；\n6. 当 `Old` 区也被填满时，进行 `Major GC`，对 `Old` 区进行垃圾回收。\n\n[注意，在真实的 JVM 环境里，可以通过参数 `SurvivorRatio` 手动配置`Eden`区和单个`Survivor`区的比例，默认为8。]\n\n那么，所谓的 `Old` 区垃圾回收，或称`Major GC`，应该如何执行呢？\n\n### 老年代－`标记整理`回收机制\n根据上面我们知道，老年代一般存放的是存活时间较久的对象，所以每一次 GC 时，存活对象比较较大，也就是说每次只有少部分对象被回收。\n\n因此，根据不同回收机制的特点，这里选择`存活对象多，垃圾少`的`标记整理`回收机制，仅仅通过少量地移动对象就能清理垃圾，而且不存在内存碎片化。\n\n至此，我们已经了解了 Java 堆内存的分代原理，并了解了不同代根据各自特点采用了不同的回收机制，即`新生代`采用`回收`机制，`老年代`采用`标记整理`机制。\n\n\n## 小结\n垃圾回收是 Java 非常重要的特性，也是高级 Java 工程师的必经之路。\n\n如有问题欢迎与我联系。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n\n\n参考文章：\n- 《[理解Java垃圾回收机制](http://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)》\n- 《[JVM 的 工作原理，层次结构 以及 GC工作原理](https://segmentfault.com/a/1190000002579346#articleHeader6)》\n- 《[深入理解Java虚拟机笔记二（垃圾收集器与内存分配策略）](http://howiefh.github.io/2015/04/08/jvm-note-2/)》\n\n","source":"_posts/Java-技术之垃圾回收机制.md","raw":"title: Java 技术之垃圾回收机制\ndate: 2017-05-24 21:19:26\ncategories:\n  - 深入理解Java技术\ntags: Java\ncommentIssueId: 2\n---\n\n>垃圾回收机制是 Java 非常重要的特性之一，也是面试题的常客。它让开发者无需关注空间的创建和释放，而是以守护进程的形式在后台自动回收垃圾。这样做不仅提高了开发效率，更改善了内存的使用状况。\n\n>今天本文来对垃圾回收机制进行讲解，主要涉及下面几个问题：\n- 什么是堆内存？\n- 什么是垃圾？\n- 有哪些方法回收这些垃圾？\n- 什么是分代回收机制？\n\n<!-- more -->\n\n## 什么是 Java 堆内存\n堆是在 JVM 启动时创建的，主要用来维护运行时数据，如运行过程中创建的对象和数组都是基于这块内存空间。Java 堆是非常重要的元素，如果我们动态创建的对象没有得到及时回收，持续堆积，最后会导致堆空间被占满，内存溢出。\n\n因此，Java 提供了一种垃圾回收机制，在后台创建一个守护进程。该进程会在内存紧张的时候自动跳出来，把堆空间的垃圾全部进行回收，从而保证程序的正常运行。\n\n## 那什么是垃圾呢？\n所谓“垃圾”，就是指所有不再存活的对象。常见的判断是否存活有两种方法：引用计数法和可达性分析。\n\n### 引用计数法\n为每一个创建的对象分配一个引用计数器，用来存储该对象被引用的个数。当该个数为零，意味着没有人再使用这个对象，可以认为“对象死亡”。但是，这种方案存在严重的问题，就是无法检测“循环引用”：当两个对象互相引用，即时它俩都不被外界任何东西引用，它俩的计数都不为零，因此永远不会被回收。而实际上对于开发者而言，这两个对象已经完全没有用处了。\n\n因此，Java 里没有采用这样的方案来判定对象的“存活性”。\n\n### 可达性分析\n这种方案是目前主流语言里采用的对象存活性判断方案。基本思路是把所有引用的对象想象成一棵树，从树的根结点 GC Roots 出发，持续遍历找出所有连接的树枝对象，这些对象则被称为“可达”对象，或称“存活”对象。其余的对象则被视为“死亡”的“不可达”对象，或称“垃圾”。\n\n参考下图，object5,object6和object7便是不可达对象，视为“死亡状态”，应该被垃圾回收器回收。\n\n![](/img/gc/reachable.JPG)\n\n#### GC Roots 究竟指谁呢？\n我们可以猜测，GC Roots 本身一定是可达的，这样从它们出发遍历到的对象才能保证一定可达。那么，Java 里有哪些对象是一定可达呢？主要有以下四种：\n- 虚拟机栈（帧栈中的本地变量表）中引用的对象。\n- 方法区中静态属性引用的对象。\n- 方法区中常量引用的对象。\n- 本地方法栈中JNI引用的对象。\n\n不少读者可能对这些 GC Roots 似懂非懂，这涉及到 JVM 本身的内存结构等等，未来的文章会再做深入讲解。这里只要知道有这么几种类型的 GC Roots，每次垃圾回收器会从这些根结点开始遍历寻找所有可达节点。\n\n## 有哪些方式来回收这些垃圾呢？\n上面已经知道，所有GC Roots不可达的对象都称为垃圾，参考下图，黑色的表示垃圾，灰色表示存活对象，绿色表示空白空间。\n\n![](/img/gc/garbage.png)\n\n那么，我们如何来回收这些垃圾呢？\n\n#### 标记－清理\n第一步，所谓“标记”就是利用可达性遍历堆内存，把“存活”对象和“垃圾”对象进行标记，得到的结果如上图；\n第二步，既然“垃圾”已经标记好了，那我们再遍历一遍，把所有“垃圾”对象所占的空间直接`清空`即可。\n\n结果如下：\n![](/img/gc/mark-sweep.png)\n\n这便是`标记－清理`方案，`简单方便`，但是容易产生`内存碎片`。\n\n#### 标记－整理\n既然上面的方法会产生内存碎片，那好，我在清理的时候，把所有`存活`对象扎堆到同一个地方，让它们待在一起，这样就没有内存碎片了。\n\n结果如下：\n![](/img/gc/mark-compact.png)\n\n这两种方案适合`存活对象多，垃圾少`的情况，它只需要清理掉少量的垃圾，然后挪动下存活对象就可以了。\n\n#### 复制\n这种方法比较粗暴，直接把堆内存分成两部分，一段时间内只允许在其中一块内存上进行分配，当这块内存被分配完后，则执行垃圾回收，把所有`存活`对象全部复制到另一块内存上，当前内存则直接全部清空。\n\n参考下图：\n![](/img/gc/copying.png)\n\n起初时只使用上面部分的内存，直到内存使用完毕，才进行垃圾回收，把所有存活对象搬到下半部分，并把上半部分进行清空。\n\n这种做法不容易产生碎片，也简单粗暴；但是，它意味着你在一段时间内只能使用一部分的内存，超过这部分内存的话就意味着堆内存里频繁的`复制清空`。\n\n这种方案适合`存活对象少，垃圾多`的情况，这样在复制时就不需要复制多少对象过去，多数垃圾直接被清空处理。\n\n## Java 的分代回收机制\n上面我们看到有至少三种方法来回收内存，那么 Java 里是如何选择利用这三种回收算法呢？是只用一种还是三种都用呢？\n\n### Java 的堆结构\n在选择回收算法前，我们先来看一下 Java 堆的结构。\n\n一块 Java 堆空间一般分成三部分，这三部分用来存储三类数据：\n- 刚刚创建的对象。在代码运行时会持续不断地创造新的对象，这些新创建的对象会被统一放在一起。因为有很多局部变量等在新创建后很快会变成`不可达`的对象，`快速死去`，因此这块区域的特点是`存活对象少，垃圾多`。形象点描述这块区域为：`新生代`；\n- 存活了一段时间的对象。这些对象早早就被创建了，而且一直活了下来。我们把这些`存活时间较长`的对象放在一起，它们的特点是`存活对象多，垃圾少`。形象点描述这块区域为：`老年代`；\n- 永久存在的对象。比如一些静态文件，这些对象的特点是不需要垃圾回收，永远存活。形象点描述这块区域为：`永久代`。（不过在 Java 8 里已经把`永久代`删除了，把这块内存空间给了`元空间`，后续文章再讲解。）\n\n也就是说，常规的 Java 堆至少包括了 `新生代` 和 `老年代` 两块内存区域，而且这两块区域有很明显的特征：\n- 新生代：存活对象少、垃圾多\n- 老年代：存活对象多、垃圾少\n\n\n结合新生代／老年代的存活对象特点和之前提过的几种垃圾回收算法，可以得到如下的回收方案：\n### 新生代－`复制`回收机制\n对于新生代区域，由于每次 GC 都会有大量新对象死去，只有少量存活。因此采用`复制`回收算法，GC 时把少量的存活对象复制过去即可。\n\n那么如何设计这个`复制`算法比较好呢？有以下几种方式：\n\n##### 思路1. 把内存均分成 `1:1` 两等份\n如下图拆分内存。\n![](/img/gc/young_1.png)\n\n每次只使用一半的内存，当这一半满了后，就进行垃圾回收，把存活的对象直接复制到另一半内存，并清空当前一半的内存。\n\n这种分法的缺陷是相当于只有一半的可用内存，对于新生代而言，新对象持续不断地被创建，如果只有一半可用内存，那显然要持续不断地进行垃圾回收工作，反而影响到了正常程序的运行，得不偿失。\n\n##### 思路2. 把内存按 `9:1` 分\n既然上面的分法导致可用内存只剩一半，那么我做些调整，把 `1:1`变成`9:1`，\n![](/img/gc/young_2.png)\n\n最开始在 `9` 的内存区使用，当 `9` 快要满时，执行复制回收，把 `9` 内仍然存活的对象复制到 `1` 区，并清空 `9` 区。\n\n这样看起来是比上面的方法好了，但是它存在比较严重的问题。\n\n当我们把 `9` 区存活对象复制到 `1` 区时，由于内存空间比例相差比较大，所以很有可能 `1` 区放不满，此时就不得不把对象移到 `老年区`。而这就意味着，可能会有一部分 `并不老` 的 `9` 区对象由于 `1` 区放不下了而被放到了 `老年区`，可想而知，这破坏了 `老年区` 的规则。或者说，一定程度上的 `老年区` 并不一定全是 `老年对象`。\n\n那应该如何才能把真正比较 `老` 的对象挪到 `老年区` 呢？ \n\n##### 思路3. 把内存按 `8:1:1` 分\n![](/img/gc/young_3.png)\n\n既然 `9:1` 有可能把年轻对象放到 `老年区`，那就换成 `8:1:1`，依次取名为 `Eden`、`Survivor A`、`Survivor B`区，其中`Eden`意为伊甸园，形容有很多新生对象在里面创建；`Survivor`区则为幸存者，即经历 GC 后仍然存活下来的对象。\n\n工作原理如下：\n1. 首先，`Eden`区最大，对外提供堆内存。当 `Eden` 区快要满了，则进行 `Minor GC`，把存活对象放入`Survivor A`区，清空 `Eden` 区；\n2. `Eden`区被清空后，继续对外提供堆内存；\n3. 当`Eden`区再次被填满，此时对`Eden`区和`Survivor A`区同时进行 `Minor GC`，把存活对象放入`Survivor B`区，同时清空`Eden` 区和`Survivor A`区；\n4. `Eden`区继续对外提供堆内存，并重复上述过程，即在`Eden`区填满后，把`Eden`区和某个`Survivor`区的存活对象放到另一个`Survivor`区；\n5. 当某个`Survivor`区被填满，且仍有对象未被复制完毕时，或者某些对象在反复`Survive` `15` 次左右时，则把这部分剩余对象放到`Old`区；\n6. 当 `Old` 区也被填满时，进行 `Major GC`，对 `Old` 区进行垃圾回收。\n\n[注意，在真实的 JVM 环境里，可以通过参数 `SurvivorRatio` 手动配置`Eden`区和单个`Survivor`区的比例，默认为8。]\n\n那么，所谓的 `Old` 区垃圾回收，或称`Major GC`，应该如何执行呢？\n\n### 老年代－`标记整理`回收机制\n根据上面我们知道，老年代一般存放的是存活时间较久的对象，所以每一次 GC 时，存活对象比较较大，也就是说每次只有少部分对象被回收。\n\n因此，根据不同回收机制的特点，这里选择`存活对象多，垃圾少`的`标记整理`回收机制，仅仅通过少量地移动对象就能清理垃圾，而且不存在内存碎片化。\n\n至此，我们已经了解了 Java 堆内存的分代原理，并了解了不同代根据各自特点采用了不同的回收机制，即`新生代`采用`回收`机制，`老年代`采用`标记整理`机制。\n\n\n## 小结\n垃圾回收是 Java 非常重要的特性，也是高级 Java 工程师的必经之路。\n\n如有问题欢迎与我联系。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n\n\n参考文章：\n- 《[理解Java垃圾回收机制](http://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)》\n- 《[JVM 的 工作原理，层次结构 以及 GC工作原理](https://segmentfault.com/a/1190000002579346#articleHeader6)》\n- 《[深入理解Java虚拟机笔记二（垃圾收集器与内存分配策略）](http://howiefh.github.io/2015/04/08/jvm-note-2/)》\n\n","slug":"Java-技术之垃圾回收机制","published":1,"updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm2v003vmoyxhr9uf4if","sticky":0},{"title":"Java 技术之反射","date":"2017-04-26T14:37:55.000Z","commentIssueId":6,"_content":">关于Java反射机制的文章很多，这次换种方式来讲解反射的作用。\n\n>本文涉及到的知识点：`class.getDeclaredXXX()`、`XXX.getModifiers()`、`method.getReturnType()`、`method.getParameterTypes()`、`method.isAnnotationPresent(XXX.class)`、`Modifier.isStatic(method.getModifiers())` 和 `constructor.newInstance(XX)`\n\n>本文涉及代码：\nhttps://github.com/wingjay/HelloJava/blob/master/data-structure/src/reflection/ForArticle.java   \n\n<!-- more -->\n\n## 先来看一个熟悉的 Class\n首先，简单来说，反射就是在运行时可以获取任意 `Class` 或 `Object` 内部所有成员属性，如成员变量、成员方法、构造函数和 Annotation。\n\n这次先给出一个大家非常熟悉的 `Class`：`UserBean`。\n\n本文要完成的任务就是，在只有一个 `UserBean.getClass()` 的情况下，利用代码`打印出其内部所有成员变量、方法，并动态执行内部用 @Invoke 修饰的成员方法`。\n\n```\npackage com.wingjay.reflection;\n\npublic class UserBean {\n\n    public String userName;\n\n    private long userId;\n\n    public UserBean(String userName, long userId) {\n        this.userName = userName;\n        this.userId = userId;\n    }\n\n    public String getName() {\n        return userName;\n    }\n\n    public long getId() {\n        return userId;\n    }\n\n    @Invoke\n    public static void staticMethod(String devName) {\n        System.out.printf(\"Hi %s, I'm a static method\", devName);\n    }\n\n    @Invoke\n    public void publicMethod() {\n        System.out.println(\"I'm a public method\");\n    }\n\n    @Invoke\n    private void privateMethod() {\n        System.out.println(\"I'm a private method\");\n    }\n}\n```\n\n在只提供一个 UserBean 的 Class 情况下，\n\n1. 打印出这个 `Class` 内部的所有成员变量、成员方法、构造函数，包括 `private` 的；\n2. 调用这个 `Class` 内部的三个用 `@Invoke` 修饰的方法：`staticMethod()`, `publicMethod()`, `privateMethod()`；\n\n## 1. 打印 UserBean Class 里的所有成员变量、成员方法，包括 private 的\n首先我们拥有一个 `Class userBeanClass = UserBean.class`，我们要利用这个 `Class` 来打印它的成员变量 `userName` 和 `userId`。\n\n#### 打印成员变量\n那么如何获取成员变量呢，我们发现，Java 里提供了 `Field` 这个类来表示成员变量，提供了 `clazz.getDeclaredFields()` 来获取一个类内部声明的所有变量。因此，可以利用下面的代码获取 `userBeanClass` 内部所有的成员变量。\n```\nField[] fields = userBeanClass.getDeclaredFields();\n```\n那么，我们如何将一个 `field` 对象打印成 `private String userName;` 这种形式呢？或者说如何分别找到 `private`、`String`、`userName` 这三个值呢？\n\n其实，`Field` 里包含了三种元素来对应它们，分别是`Modifier`、`Type`、`Name`。\n```\nprivate <-- field.getModifiers();\nString <-- field.getType();\nuserName <-- field.getName();\n```\n\n```\n// fields\nField[] fields = userBeanClass.getDeclaredFields();\n\nfor(Field field : fields) {\n    String fieldString = \"\";\n    fieldString += Modifier.toString(field.getModifiers()) + \" \"; // `private`\n    fieldString += field.getType().getSimpleName() + \" \"; // `String`\n    fieldString += field.getName(); // `userName`\n    fieldString += \";\";\n    System.out.println(fieldString);\n}\n```\n\n打印结果：\n\n```\npublic String userName;\nprivate long userId;\n```\n\n#### 打印成员方法\n类似成员变量的 `Field`，成员方法也有对应的类 `Method`，首先可以通过 `Method[] methods = userBeanClass.getDeclaredMethods();` 获得所有的成员方法，然后，为了打印形如：`public static void staticMethod(String devName)`的数据，可以利用下列 `method` 提供的方法：\n\n```\nprivate static <-- method.getModifiers();\nvoid <-- method.getReturnType();\nstaticMethod <-- method.getName();\nString <-- method.getParameterTypes();\n```\n\n因此可以得到:\n```\nMethod[] methods = userBeanClass.getDeclaredMethods();\nfor (Method method : methods) {\n    String methodString = Modifier.toString(method.getModifiers()) + \" \" ; // private static\n    methodString += method.getReturnType().getSimpleName() + \" \"; // void\n    methodString += method.getName() + \"(\"; // staticMethod \n    Class[] parameters = method.getParameterTypes();\n    for (Class parameter : parameters) {\n        methodString += parameter.getSimpleName() + \" \"; // String\n    }\n    methodString += \")\";\n    System.out.println(methodString);\n}\n```\n\n打印结果如下：\n```\npublic String getName()\npublic long getId()\npublic static void staticMethod(String )\npublic void publicMethod()\nprivate void privateMethod()\n```\n可以完整的打印所有成员方法，无论是 `public` 还是 `private`，而且能打印 `static` 关键字。\n\n#### 打印构造函数\n其实构造函数和成员函数非常类似，Java 里提供了 `Constructor` 来表示构造函数，为了打印 `public UserBean(String userName, long userId)`，可以利用下面的函数实现：\n\n```\n// constructors\nConstructor[] constructors = userBeanClass.getDeclaredConstructors();\nfor (Constructor constructor : constructors) {\n    String s = Modifier.toString(constructor.getModifiers()) + \" \";\n    s += constructor.getName() + \"(\";\n    Class[] parameters = constructor.getParameterTypes();\n    for (Class parameter : parameters) {\n        s += parameter.getSimpleName() + \", \";\n    }\n    s += \")\";\n    System.out.println(s);\n}\n```\n\n打印结果如下：\n```\npublic com.wingjay.reflection.UserBean(String, long)\n```\n\n## 2. 调用 Class 内部的用 `@Invoke` 修饰的方法\n从上面知道，我们可以利用 `class.getDeclaredMethods()` 获取一个类内部所有成员方法，接下来我们还要做的事是：\n\n1. 判断这个方法是否被 `@Invoke` 修饰\n2. 如果修饰，判断这个方法是不是 `static` 的\n3. 如果是 `static`，则可以直接用 class 调用\n4. 如果不是 `static`，那就需要实例化一个对象来调用\n5. 如果这个方法是 `private` 的，要记得 `setAccessible(true)`。\n\n如果分别实现上面的一些功能呢？\n\n- 为了判断一个 Method 是否被某个 Annotation 修饰，可以用 `method.isAnnotationPresent(Invoke.class)` ；\n- 关于 `static` `private`，我们可以用 `Modifier` 类提供的 `Modifier.isStatic()` 和 `Modifier.isPrivate()`来判断；\n- 如果 Method 不是 static，那就要实例化对象，我们可以用 `class.newInstance()` 或者 `constructor.newInstance(params)` 来得到实例。\n- 关于执行一个 Method，可以使用 `method.invoke(object, ...params)` 方法，如果方法不是 `static` 就必须实例化一个 `object` 传给它，否则可以传 `null`\n\n\n实现如下：\n```\nMethod[] methods = userBeanClass.getDeclaredMethods(); // 获取所有成员方法\nfor (Method method : methods) {\n    if (method.isAnnotationPresent(Invoke.class)) { // 判断是否被 @Invoke 修饰\n        if (Modifier.isStatic(method.getModifiers())) { // 如果是 static 方法\n            method.invoke(null, \"wingjay\"); // 直接调用，并传入需要的参数 devName\n        } else {\n            Class[] params = {String.class, long.class};\n            Constructor constructor = userBeanClass.getDeclaredConstructor(params); // 获取参数格式为 String,long 的构造函数\n            Object userBean = constructor.newInstance(\"wingjay\", 11); // 利用构造函数进行实例化，得到 Object\n            if (Modifier.isPrivate(method.getModifiers())) {\n                method.setAccessible(true); // 如果是 private 的方法，需要获取其调用权限\n            }\n            method.invoke(userBean); // 调用 method，无须参数\n        }\n    }\n}\n```\n\n打印结果：\n```\nI'm a public method\nHi wingjay, I'm a static method\nI'm a private method\n```\n\n可见三个方法都正常调用了，而且 `public static void staticMethod(String devName)` 的参数 `devName` 也正常传进去了。\n\n## 小结\n基于上面两个实践，我们已经能够利用反射机制，在运行状态下把一个 Class 的内部成员方法、成员变量和构造函数全部获取到，并且能够进行实例化、直接调用内部的成员方法。\n\n因此，有了反射机制，我们即使只有动态得到的 Class，也能直接得到它内部的信息、甚至调用它内部的方法。\n\n了解了反射后，下文我将介绍 `Annotation` 一些有趣的自定义实现，合理地利用 `Annotation` 能让代码更简洁，自动生成代码，实现一些常规难以实现的功能。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n","source":"_posts/Java-技术之反射.md","raw":"title: Java 技术之反射\ndate: 2017-04-26 22:37:55\ncategories:\n  - 深入理解Java技术\ntags: Java\ncommentIssueId: 6\n---\n>关于Java反射机制的文章很多，这次换种方式来讲解反射的作用。\n\n>本文涉及到的知识点：`class.getDeclaredXXX()`、`XXX.getModifiers()`、`method.getReturnType()`、`method.getParameterTypes()`、`method.isAnnotationPresent(XXX.class)`、`Modifier.isStatic(method.getModifiers())` 和 `constructor.newInstance(XX)`\n\n>本文涉及代码：\nhttps://github.com/wingjay/HelloJava/blob/master/data-structure/src/reflection/ForArticle.java   \n\n<!-- more -->\n\n## 先来看一个熟悉的 Class\n首先，简单来说，反射就是在运行时可以获取任意 `Class` 或 `Object` 内部所有成员属性，如成员变量、成员方法、构造函数和 Annotation。\n\n这次先给出一个大家非常熟悉的 `Class`：`UserBean`。\n\n本文要完成的任务就是，在只有一个 `UserBean.getClass()` 的情况下，利用代码`打印出其内部所有成员变量、方法，并动态执行内部用 @Invoke 修饰的成员方法`。\n\n```\npackage com.wingjay.reflection;\n\npublic class UserBean {\n\n    public String userName;\n\n    private long userId;\n\n    public UserBean(String userName, long userId) {\n        this.userName = userName;\n        this.userId = userId;\n    }\n\n    public String getName() {\n        return userName;\n    }\n\n    public long getId() {\n        return userId;\n    }\n\n    @Invoke\n    public static void staticMethod(String devName) {\n        System.out.printf(\"Hi %s, I'm a static method\", devName);\n    }\n\n    @Invoke\n    public void publicMethod() {\n        System.out.println(\"I'm a public method\");\n    }\n\n    @Invoke\n    private void privateMethod() {\n        System.out.println(\"I'm a private method\");\n    }\n}\n```\n\n在只提供一个 UserBean 的 Class 情况下，\n\n1. 打印出这个 `Class` 内部的所有成员变量、成员方法、构造函数，包括 `private` 的；\n2. 调用这个 `Class` 内部的三个用 `@Invoke` 修饰的方法：`staticMethod()`, `publicMethod()`, `privateMethod()`；\n\n## 1. 打印 UserBean Class 里的所有成员变量、成员方法，包括 private 的\n首先我们拥有一个 `Class userBeanClass = UserBean.class`，我们要利用这个 `Class` 来打印它的成员变量 `userName` 和 `userId`。\n\n#### 打印成员变量\n那么如何获取成员变量呢，我们发现，Java 里提供了 `Field` 这个类来表示成员变量，提供了 `clazz.getDeclaredFields()` 来获取一个类内部声明的所有变量。因此，可以利用下面的代码获取 `userBeanClass` 内部所有的成员变量。\n```\nField[] fields = userBeanClass.getDeclaredFields();\n```\n那么，我们如何将一个 `field` 对象打印成 `private String userName;` 这种形式呢？或者说如何分别找到 `private`、`String`、`userName` 这三个值呢？\n\n其实，`Field` 里包含了三种元素来对应它们，分别是`Modifier`、`Type`、`Name`。\n```\nprivate <-- field.getModifiers();\nString <-- field.getType();\nuserName <-- field.getName();\n```\n\n```\n// fields\nField[] fields = userBeanClass.getDeclaredFields();\n\nfor(Field field : fields) {\n    String fieldString = \"\";\n    fieldString += Modifier.toString(field.getModifiers()) + \" \"; // `private`\n    fieldString += field.getType().getSimpleName() + \" \"; // `String`\n    fieldString += field.getName(); // `userName`\n    fieldString += \";\";\n    System.out.println(fieldString);\n}\n```\n\n打印结果：\n\n```\npublic String userName;\nprivate long userId;\n```\n\n#### 打印成员方法\n类似成员变量的 `Field`，成员方法也有对应的类 `Method`，首先可以通过 `Method[] methods = userBeanClass.getDeclaredMethods();` 获得所有的成员方法，然后，为了打印形如：`public static void staticMethod(String devName)`的数据，可以利用下列 `method` 提供的方法：\n\n```\nprivate static <-- method.getModifiers();\nvoid <-- method.getReturnType();\nstaticMethod <-- method.getName();\nString <-- method.getParameterTypes();\n```\n\n因此可以得到:\n```\nMethod[] methods = userBeanClass.getDeclaredMethods();\nfor (Method method : methods) {\n    String methodString = Modifier.toString(method.getModifiers()) + \" \" ; // private static\n    methodString += method.getReturnType().getSimpleName() + \" \"; // void\n    methodString += method.getName() + \"(\"; // staticMethod \n    Class[] parameters = method.getParameterTypes();\n    for (Class parameter : parameters) {\n        methodString += parameter.getSimpleName() + \" \"; // String\n    }\n    methodString += \")\";\n    System.out.println(methodString);\n}\n```\n\n打印结果如下：\n```\npublic String getName()\npublic long getId()\npublic static void staticMethod(String )\npublic void publicMethod()\nprivate void privateMethod()\n```\n可以完整的打印所有成员方法，无论是 `public` 还是 `private`，而且能打印 `static` 关键字。\n\n#### 打印构造函数\n其实构造函数和成员函数非常类似，Java 里提供了 `Constructor` 来表示构造函数，为了打印 `public UserBean(String userName, long userId)`，可以利用下面的函数实现：\n\n```\n// constructors\nConstructor[] constructors = userBeanClass.getDeclaredConstructors();\nfor (Constructor constructor : constructors) {\n    String s = Modifier.toString(constructor.getModifiers()) + \" \";\n    s += constructor.getName() + \"(\";\n    Class[] parameters = constructor.getParameterTypes();\n    for (Class parameter : parameters) {\n        s += parameter.getSimpleName() + \", \";\n    }\n    s += \")\";\n    System.out.println(s);\n}\n```\n\n打印结果如下：\n```\npublic com.wingjay.reflection.UserBean(String, long)\n```\n\n## 2. 调用 Class 内部的用 `@Invoke` 修饰的方法\n从上面知道，我们可以利用 `class.getDeclaredMethods()` 获取一个类内部所有成员方法，接下来我们还要做的事是：\n\n1. 判断这个方法是否被 `@Invoke` 修饰\n2. 如果修饰，判断这个方法是不是 `static` 的\n3. 如果是 `static`，则可以直接用 class 调用\n4. 如果不是 `static`，那就需要实例化一个对象来调用\n5. 如果这个方法是 `private` 的，要记得 `setAccessible(true)`。\n\n如果分别实现上面的一些功能呢？\n\n- 为了判断一个 Method 是否被某个 Annotation 修饰，可以用 `method.isAnnotationPresent(Invoke.class)` ；\n- 关于 `static` `private`，我们可以用 `Modifier` 类提供的 `Modifier.isStatic()` 和 `Modifier.isPrivate()`来判断；\n- 如果 Method 不是 static，那就要实例化对象，我们可以用 `class.newInstance()` 或者 `constructor.newInstance(params)` 来得到实例。\n- 关于执行一个 Method，可以使用 `method.invoke(object, ...params)` 方法，如果方法不是 `static` 就必须实例化一个 `object` 传给它，否则可以传 `null`\n\n\n实现如下：\n```\nMethod[] methods = userBeanClass.getDeclaredMethods(); // 获取所有成员方法\nfor (Method method : methods) {\n    if (method.isAnnotationPresent(Invoke.class)) { // 判断是否被 @Invoke 修饰\n        if (Modifier.isStatic(method.getModifiers())) { // 如果是 static 方法\n            method.invoke(null, \"wingjay\"); // 直接调用，并传入需要的参数 devName\n        } else {\n            Class[] params = {String.class, long.class};\n            Constructor constructor = userBeanClass.getDeclaredConstructor(params); // 获取参数格式为 String,long 的构造函数\n            Object userBean = constructor.newInstance(\"wingjay\", 11); // 利用构造函数进行实例化，得到 Object\n            if (Modifier.isPrivate(method.getModifiers())) {\n                method.setAccessible(true); // 如果是 private 的方法，需要获取其调用权限\n            }\n            method.invoke(userBean); // 调用 method，无须参数\n        }\n    }\n}\n```\n\n打印结果：\n```\nI'm a public method\nHi wingjay, I'm a static method\nI'm a private method\n```\n\n可见三个方法都正常调用了，而且 `public static void staticMethod(String devName)` 的参数 `devName` 也正常传进去了。\n\n## 小结\n基于上面两个实践，我们已经能够利用反射机制，在运行状态下把一个 Class 的内部成员方法、成员变量和构造函数全部获取到，并且能够进行实例化、直接调用内部的成员方法。\n\n因此，有了反射机制，我们即使只有动态得到的 Class，也能直接得到它内部的信息、甚至调用它内部的方法。\n\n了解了反射后，下文我将介绍 `Annotation` 一些有趣的自定义实现，合理地利用 `Annotation` 能让代码更简洁，自动生成代码，实现一些常规难以实现的功能。\n\n谢谢。\n\nwingjay\n\nhttp://wingjay.com\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n","slug":"Java-技术之反射","published":1,"updated":"2017-06-23T04:03:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm2y003ymoyxrv9thhfv","sticky":0},{"title":"Hey folks","date":"2015-12-05T13:39:28.000Z","_content":"\n![Hey folks](/img/hey_folks.jpg)\n\nHi, I'm Jay! Welcome!\n\nThis is my first post here and I will write more here. Interested with me? Keep your eyes here!\n\nThanks!","source":"_posts/Hey folks.md","raw":"title: Hey folks\ntags: welcome\ndate: 2015-12-05 21:39:28\n---\n\n![Hey folks](/img/hey_folks.jpg)\n\nHi, I'm Jay! Welcome!\n\nThis is my first post here and I will write more here. Interested with me? Keep your eyes here!\n\nThanks!","slug":"Hey folks","published":1,"updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm300041moyxn4sptqfu","sticky":0},{"title":"30 条 Android 开发建议","date":"2016-03-15T04:03:03.000Z","commentIssueId":17,"_content":">    There are two kinds of people ：\n     those who learn the hard way and those who learn by taking someone’s advice. \n\n<!-- more -->\n\n本文主要用来收集Android开发中积累的一些宝贵经验，这些经验中有一些约定熟成且经过检验的建议，有一些结合最新技术的实践。无论是菜鸟还是大神，都应该学会阅读别人的经验，并结合自己的思考转化成对自己有用的知识，这才是最快的成长之路。另外，对于这些建议，我会尽量翔实的进行说明以确保能够顺利快速应用到实际开发中。\n\n## 介绍\n下面以这篇文章：[Building Android Apps — 30 things that experience made me learn the hard way](https://medium.com/@cesarmcferreira/building-android-apps-30-things-that-experience-made-me-learn-the-hard-way-313680430bf9#.efowqynql)为核心，对其中提出的每一点建议进行较为深入的分析探究，最终整理成一篇完整的文章。当然，本文还在不断更新中。\n\n#### 第三方库 \n在你添加每一个third party library之前，请认真考虑是否真的需要这个library。\n#### OverDraw\n如果用户看不到，那就不要进行绘制(draw)，或者说，不要`过度绘制 OverDraw`\n`OverDraw`会导致GPU浪费，也会导致app的速度变慢。为了减少这种危害，我们可以利用[`Debug GPU Overdraw Tool`](http://developer.android.com/tools/performance/debug-gpu-overdraw/index.html)来观察app里的绘制情况，然后可以使用[Hierarchy Viewer](http://developer.android.com/tools/performance/hierarchy-viewer/index.html)来进行优化。 \n#### 数据库\n除非不得不，否则不要使用`database`\n#### 65k methods limit\n`Dalvik 65K methods limit`你很快就会遇到的，不过放心，[`multidexing`](https://medium.com/@rotxed/dex-skys-the-limit-no-65k-methods-is-28e6cb40cf71)会帮助你。\n什么是`Dalvik 65K methods limit`？我们知道，我们写完java code之后，dx tool会把java编译成Dalivik虚拟机能识别的`DEX`文件，这个文件里最多能够索引`65536个method`。关于这个有两点要注意：\n1. 这些method是指能够`索引(reference)`到的，而不是`定义(define)`的。或者说，如果你定义了一个方法，但这个方法并没有被调用，那么就不算在内。\n2. 这些method不仅仅是开发人员自己写的，还包括所有第三方library里面的method。\n\n所以，我们总共可以索引`65536`个方法，包括自己写的和引入第三方库里的。\n那么，我们如何能快速知道我们的app里已经有多少个method了呢？    \n- bash script: [dex-method-counts](https://github.com/mihaip/dex-method-counts)。这个工具可以快速计算，并且提供一个清晰的视图来阅读。\n- [dex.sh](https://gist.github.com/JakeWharton/6002797) by Jake Wharton。这个工具由于采用了递归算法，所以耗时比较长。(Jake大神还写了一篇有趣的分析文章[Play Services 5.0 Is A Monolith Abomination](http://jakewharton.com/play-services-is-a-monolith/)，针对Play Services 5.0太大的问题进行了分析，有空时我再翻译下给各位。虽然[Play Services 6.5已经模块化，更加轻量级了](http://android-developers.blogspot.it/2014/12/google-play-services-and-dex-method.html)）。\n     \n现在，既然我们已经知道了自家app里的method数了，那么如何来处理这种情况呢？\n- [Multidex](http://developer.android.com/tools/building/multidex.html)，官方提供的解决方案，[这篇文章](http://blog.osom.info/2014/10/multi-dex-to-rescue-from-infamous-65536.html)里有详细的使用方法，此不赘述。\n- [ProGuard](http://developer.android.com/tools/help/proguard.html)\n`ProGuard`可以把code里unnecessary的method移除，压缩apk，当然还有`代码混淆`的奇效。\n- 再创建一个`DEX File`。把app里可以独立的模块或code提取出来，放到一个独立的dex文件里，你可以使用[Custom ClassLoader](http://android-developers.blogspot.it/2011/07/custom-class-loading-in-dalvik.html)来加载这些类，然后使用`接口`或`反射`来调用这些方法。不过，这个过程还是比较麻烦的。\n\n#### `RxJava, RxAndroid & Retrolambda`\n使用前可以通过[这篇gist](https://gist.github.com/cesarferreira/510aa2456dc0879f559f#file-rxjava-md)来了解[RxJava](https://github.com/ReactiveX/RxJava)＋[RxAndroid](https://github.com/ReactiveX/RxAndroid)＋[Retrolambda](https://github.com/orfjackal/retrolambda)的结合用法。这个组合可以优雅的在不同线程中处理事务，同时能够方便的实现数据流动和及时响应，而且Retrolambda能够精简你的code。其中，核心的两个概念是`Observables`和`Subscribers`，前者对外提供数据，后者监听并消费这些数据。\n另外，这里有一个看起来不错的项目[Learning RxJava for Android by example](https://github.com/kaushikgopal/RxJava-Android-Samples)，等空闲时再去阅读下code。\n\n#### `Retrofit` ＋ RxJava\n利用[Retrofit](http://square.github.io/retrofit/)与RxJava结合，为你的app提供网络请求服务。\n你可以参考这个[超赞的例子](https://gist.github.com/cesarferreira/da1e8fc5742ab1e581b7)，让你快速感受二者结合使用方法。\n\n#### 按`feature`来分package，而不是按`layer`\n这是这篇文章提出的一个点，文中认为分package就像公司安排座位，要按照`team`来分而不是按照每个人的职位来分，即按照负责一个app的`developer、designer、pm`坐在一起，而不是把所有`developer`坐在一起，所有`designer`坐在一起。所以，原文作者认为把一个feature相关的如`Activity ` `adapter`等都放在一起。\n\n不过，我认为按feature也有坏处，那就是`复用`，拿adapter来讲，一个app里很多adapter是类似且可以复用的，如果我们把各个adapter拆倒各个角落里，就很难提取其中的关联来创建一个`BaseAdapter`了。而且，`不同feature之间也有很多公用的东西`，比如一个自定义view，那就很难界定应该放在哪个feature包里了。相反，我们把所有自定义view放在一起，这样也有助于我们发现某些自定义view的区别，然后在refactor时可以提取公用的东西来`复用`。\n\n关于这点，欢迎读者给出自己意见。\n\n#### Gradle 加速\n参考[这篇文章](https://medium.com/the-engineering-team/speeding-up-gradle-builds-619c442113cb#.vpoaqdivn)来加速你的Gradle\n\n#### 架构：使用clean Architecture\n这里有两篇优质文章:[Architecting Android…The clean way?](http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/)和[Architecting Android…The evolution](http://fernandocejas.com/2015/07/18/architecting-android-the-evolution/) 分别介绍并用code实现了一个Clean架构。后面我也会专门分析下这种架构，因为对于任何一个project而言，最初的好的架构是非常重要的！所以，如果你想提高自己，那么`架构`这一关是必经之路。\n\n#### 测试你的app\n虽然做测试需要花费你不少时间，但一旦你完成了这一步，以后的开发会更加快速，app也会更加稳定。\n这里有个哥们，[对`unit test`进行了细致的点评](http://stackoverflow.com/a/67500/794485)。\n\n#### 使用`依赖注入`神器`Dagger`\n如果你不知道什么是`依赖注入`，你可以先读一下这篇文章[Dependency injection on Android: Dagger (Part 1)](http://antonioleiva.com/dependency-injection-android-dagger-part-1/)，或者这篇[依赖注入](https://github.com/android-cn/blog/tree/master/java/dependency-injection)。简单来说，依赖注入替代了传统创建对象的`new`操作，当需要创建一个class的实例时，使用依赖注入从外部直接获取一个实例，具体这个实例是如何创建的不需要关心，由一个对象库统一管理每个对象的创建过程，并直接对外提供对象。这样做的好处是我们不用管实例是怎么创建的，这种抽象可以使得每个对象的创建过程变得可扩展性，只要在对象库里修改一次，那么所有用到这个实例的地方都随之变更。例如在测试时，我们希望某个mock某个对象的数据，就可以修改注入的对象。\n\n依赖注入有不少工具，不过[Dagger2](http://google.github.io/dagger/)使用的是`编译时代码生成(code generation)`方式而不是`反射(reflection)`，所以它的性能比较出众。[这篇文章](http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/)有对Dagger2的实践和分析。\n\n#### EditText\n[对EditText使用合适的输入类型](http://developer.android.com/training/keyboard-input/style.html)\n\n#### 关注新的开源library\n你可以通过[Android Arsenal](http://android-arsenal.com/cc)来保持对开源项目的关注，同时利用这个工具[dryrun](https://github.com/cesarferreira/dryrun)来快速将开源项目跑在genymotion以看到实际效果。\n\n#### Service\n如果你创建了Service，那么一旦这个Service完成了自己的使命，就应该立即清理掉它\n\n#### AccountManager\n使用[AccountManager](http://developer.android.com/reference/android/accounts/AccountManager.html)来统一管理用户的帐号密码。\n\n#### 使用`持续集成CI(Continuous Integration)`来编译并发布你的beta和release build\n持续集成可以帮助你方便的编译并发布项目，不过，不要去搭建你们自己的CI服务器，因为你需要花费太多的时间来处理硬盘空间、安全问题和预防SSL攻击等问题。你可以尝试Jenkins、circleci、 travis 或者 shippable，这些价格并不贵，而且能帮你省很多事情。\n\n#### 自动发布到Play Store\n你可以使用这个工具[gradle-play-publisher](https://github.com/Triple-T/gradle-play-publisher)来帮助你自动上传apk到Play Store上\n\n#### 开始考虑用svg替代png\n理由很简单，android developer应该很熟悉每次导入一张图片时都需要生成四五种不同大小的png图片并放入到对应文件夹。与其维护这么多图片，显然使用一张svg图片更加方便。而且，google也在不断提供相关的支持，除了基本的[Vector Drawable](http://developer.android.com/tools/help/vector-asset-studio.html)，从最新的[Support Library](http://android-developers.blogspot.com/2016/02/android-support-library-232.html)我们也能看到google也在鼓励developer们使用svg。\n\n不过，svg也有自己的限制，比如它比较适合小icon，因为它最终会生成bitmap加载以供显示，所以这需要一定的cpu支持。当然总体来讲svg还是更优的，至少大家可以不用再维护四五张不同尺寸的图片了。\n\n#### 将一些library的类进行抽象，从而方便后期替换library\n例如，一旦我们打log会使用`Log.i()`，但是，如果后面我们突然想换成`Timber.i()`就会很麻烦，需要一个个log找到来替换。但是，如果我们抽象出一个`AppLogger`来，全部调用`AppLogger.i()`来记log，那么我们只要简单的在`AppLogger`内部替换掉具体实现就可以了。\n\n#### 监控网络连接类型，区分`移动数据流量`和`Wi-Fi`；同样，可以监控`电量`和`充电状态`\n对于不同网络类型，我们可以动态改变我们的UI，比如大图可以选择在`Wi-Fi`下才加载，而在`移动数据流量`则不加载。对于`电量`也是类似的逻辑。用户一定会很感谢app做的这种自适应的。\n\n#### User Interface is like a joke.If you have to explain it, it's not that good.\n\n#### 先写slow但是right的代码，再去进行优化\n\n## 小结\n本文长期更新，会保持跟踪最新的技术和研究实践经验，为大家提供有效有用的经验，少走坑。\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n","source":"_posts/30条Android开发建议.md","raw":"title: 30条Android开发建议\ndate: 2016-03-15 12:03:03\ncategories:\n  - Android\ntags: \n\t- Android\ncommentIssueId: 17\t\n---\n>    There are two kinds of people ：\n     those who learn the hard way and those who learn by taking someone’s advice. \n\n<!-- more -->\n\n本文主要用来收集Android开发中积累的一些宝贵经验，这些经验中有一些约定熟成且经过检验的建议，有一些结合最新技术的实践。无论是菜鸟还是大神，都应该学会阅读别人的经验，并结合自己的思考转化成对自己有用的知识，这才是最快的成长之路。另外，对于这些建议，我会尽量翔实的进行说明以确保能够顺利快速应用到实际开发中。\n\n## 介绍\n下面以这篇文章：[Building Android Apps — 30 things that experience made me learn the hard way](https://medium.com/@cesarmcferreira/building-android-apps-30-things-that-experience-made-me-learn-the-hard-way-313680430bf9#.efowqynql)为核心，对其中提出的每一点建议进行较为深入的分析探究，最终整理成一篇完整的文章。当然，本文还在不断更新中。\n\n#### 第三方库 \n在你添加每一个third party library之前，请认真考虑是否真的需要这个library。\n#### OverDraw\n如果用户看不到，那就不要进行绘制(draw)，或者说，不要`过度绘制 OverDraw`\n`OverDraw`会导致GPU浪费，也会导致app的速度变慢。为了减少这种危害，我们可以利用[`Debug GPU Overdraw Tool`](http://developer.android.com/tools/performance/debug-gpu-overdraw/index.html)来观察app里的绘制情况，然后可以使用[Hierarchy Viewer](http://developer.android.com/tools/performance/hierarchy-viewer/index.html)来进行优化。 \n#### 数据库\n除非不得不，否则不要使用`database`\n#### 65k methods limit\n`Dalvik 65K methods limit`你很快就会遇到的，不过放心，[`multidexing`](https://medium.com/@rotxed/dex-skys-the-limit-no-65k-methods-is-28e6cb40cf71)会帮助你。\n什么是`Dalvik 65K methods limit`？我们知道，我们写完java code之后，dx tool会把java编译成Dalivik虚拟机能识别的`DEX`文件，这个文件里最多能够索引`65536个method`。关于这个有两点要注意：\n1. 这些method是指能够`索引(reference)`到的，而不是`定义(define)`的。或者说，如果你定义了一个方法，但这个方法并没有被调用，那么就不算在内。\n2. 这些method不仅仅是开发人员自己写的，还包括所有第三方library里面的method。\n\n所以，我们总共可以索引`65536`个方法，包括自己写的和引入第三方库里的。\n那么，我们如何能快速知道我们的app里已经有多少个method了呢？    \n- bash script: [dex-method-counts](https://github.com/mihaip/dex-method-counts)。这个工具可以快速计算，并且提供一个清晰的视图来阅读。\n- [dex.sh](https://gist.github.com/JakeWharton/6002797) by Jake Wharton。这个工具由于采用了递归算法，所以耗时比较长。(Jake大神还写了一篇有趣的分析文章[Play Services 5.0 Is A Monolith Abomination](http://jakewharton.com/play-services-is-a-monolith/)，针对Play Services 5.0太大的问题进行了分析，有空时我再翻译下给各位。虽然[Play Services 6.5已经模块化，更加轻量级了](http://android-developers.blogspot.it/2014/12/google-play-services-and-dex-method.html)）。\n     \n现在，既然我们已经知道了自家app里的method数了，那么如何来处理这种情况呢？\n- [Multidex](http://developer.android.com/tools/building/multidex.html)，官方提供的解决方案，[这篇文章](http://blog.osom.info/2014/10/multi-dex-to-rescue-from-infamous-65536.html)里有详细的使用方法，此不赘述。\n- [ProGuard](http://developer.android.com/tools/help/proguard.html)\n`ProGuard`可以把code里unnecessary的method移除，压缩apk，当然还有`代码混淆`的奇效。\n- 再创建一个`DEX File`。把app里可以独立的模块或code提取出来，放到一个独立的dex文件里，你可以使用[Custom ClassLoader](http://android-developers.blogspot.it/2011/07/custom-class-loading-in-dalvik.html)来加载这些类，然后使用`接口`或`反射`来调用这些方法。不过，这个过程还是比较麻烦的。\n\n#### `RxJava, RxAndroid & Retrolambda`\n使用前可以通过[这篇gist](https://gist.github.com/cesarferreira/510aa2456dc0879f559f#file-rxjava-md)来了解[RxJava](https://github.com/ReactiveX/RxJava)＋[RxAndroid](https://github.com/ReactiveX/RxAndroid)＋[Retrolambda](https://github.com/orfjackal/retrolambda)的结合用法。这个组合可以优雅的在不同线程中处理事务，同时能够方便的实现数据流动和及时响应，而且Retrolambda能够精简你的code。其中，核心的两个概念是`Observables`和`Subscribers`，前者对外提供数据，后者监听并消费这些数据。\n另外，这里有一个看起来不错的项目[Learning RxJava for Android by example](https://github.com/kaushikgopal/RxJava-Android-Samples)，等空闲时再去阅读下code。\n\n#### `Retrofit` ＋ RxJava\n利用[Retrofit](http://square.github.io/retrofit/)与RxJava结合，为你的app提供网络请求服务。\n你可以参考这个[超赞的例子](https://gist.github.com/cesarferreira/da1e8fc5742ab1e581b7)，让你快速感受二者结合使用方法。\n\n#### 按`feature`来分package，而不是按`layer`\n这是这篇文章提出的一个点，文中认为分package就像公司安排座位，要按照`team`来分而不是按照每个人的职位来分，即按照负责一个app的`developer、designer、pm`坐在一起，而不是把所有`developer`坐在一起，所有`designer`坐在一起。所以，原文作者认为把一个feature相关的如`Activity ` `adapter`等都放在一起。\n\n不过，我认为按feature也有坏处，那就是`复用`，拿adapter来讲，一个app里很多adapter是类似且可以复用的，如果我们把各个adapter拆倒各个角落里，就很难提取其中的关联来创建一个`BaseAdapter`了。而且，`不同feature之间也有很多公用的东西`，比如一个自定义view，那就很难界定应该放在哪个feature包里了。相反，我们把所有自定义view放在一起，这样也有助于我们发现某些自定义view的区别，然后在refactor时可以提取公用的东西来`复用`。\n\n关于这点，欢迎读者给出自己意见。\n\n#### Gradle 加速\n参考[这篇文章](https://medium.com/the-engineering-team/speeding-up-gradle-builds-619c442113cb#.vpoaqdivn)来加速你的Gradle\n\n#### 架构：使用clean Architecture\n这里有两篇优质文章:[Architecting Android…The clean way?](http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/)和[Architecting Android…The evolution](http://fernandocejas.com/2015/07/18/architecting-android-the-evolution/) 分别介绍并用code实现了一个Clean架构。后面我也会专门分析下这种架构，因为对于任何一个project而言，最初的好的架构是非常重要的！所以，如果你想提高自己，那么`架构`这一关是必经之路。\n\n#### 测试你的app\n虽然做测试需要花费你不少时间，但一旦你完成了这一步，以后的开发会更加快速，app也会更加稳定。\n这里有个哥们，[对`unit test`进行了细致的点评](http://stackoverflow.com/a/67500/794485)。\n\n#### 使用`依赖注入`神器`Dagger`\n如果你不知道什么是`依赖注入`，你可以先读一下这篇文章[Dependency injection on Android: Dagger (Part 1)](http://antonioleiva.com/dependency-injection-android-dagger-part-1/)，或者这篇[依赖注入](https://github.com/android-cn/blog/tree/master/java/dependency-injection)。简单来说，依赖注入替代了传统创建对象的`new`操作，当需要创建一个class的实例时，使用依赖注入从外部直接获取一个实例，具体这个实例是如何创建的不需要关心，由一个对象库统一管理每个对象的创建过程，并直接对外提供对象。这样做的好处是我们不用管实例是怎么创建的，这种抽象可以使得每个对象的创建过程变得可扩展性，只要在对象库里修改一次，那么所有用到这个实例的地方都随之变更。例如在测试时，我们希望某个mock某个对象的数据，就可以修改注入的对象。\n\n依赖注入有不少工具，不过[Dagger2](http://google.github.io/dagger/)使用的是`编译时代码生成(code generation)`方式而不是`反射(reflection)`，所以它的性能比较出众。[这篇文章](http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/)有对Dagger2的实践和分析。\n\n#### EditText\n[对EditText使用合适的输入类型](http://developer.android.com/training/keyboard-input/style.html)\n\n#### 关注新的开源library\n你可以通过[Android Arsenal](http://android-arsenal.com/cc)来保持对开源项目的关注，同时利用这个工具[dryrun](https://github.com/cesarferreira/dryrun)来快速将开源项目跑在genymotion以看到实际效果。\n\n#### Service\n如果你创建了Service，那么一旦这个Service完成了自己的使命，就应该立即清理掉它\n\n#### AccountManager\n使用[AccountManager](http://developer.android.com/reference/android/accounts/AccountManager.html)来统一管理用户的帐号密码。\n\n#### 使用`持续集成CI(Continuous Integration)`来编译并发布你的beta和release build\n持续集成可以帮助你方便的编译并发布项目，不过，不要去搭建你们自己的CI服务器，因为你需要花费太多的时间来处理硬盘空间、安全问题和预防SSL攻击等问题。你可以尝试Jenkins、circleci、 travis 或者 shippable，这些价格并不贵，而且能帮你省很多事情。\n\n#### 自动发布到Play Store\n你可以使用这个工具[gradle-play-publisher](https://github.com/Triple-T/gradle-play-publisher)来帮助你自动上传apk到Play Store上\n\n#### 开始考虑用svg替代png\n理由很简单，android developer应该很熟悉每次导入一张图片时都需要生成四五种不同大小的png图片并放入到对应文件夹。与其维护这么多图片，显然使用一张svg图片更加方便。而且，google也在不断提供相关的支持，除了基本的[Vector Drawable](http://developer.android.com/tools/help/vector-asset-studio.html)，从最新的[Support Library](http://android-developers.blogspot.com/2016/02/android-support-library-232.html)我们也能看到google也在鼓励developer们使用svg。\n\n不过，svg也有自己的限制，比如它比较适合小icon，因为它最终会生成bitmap加载以供显示，所以这需要一定的cpu支持。当然总体来讲svg还是更优的，至少大家可以不用再维护四五张不同尺寸的图片了。\n\n#### 将一些library的类进行抽象，从而方便后期替换library\n例如，一旦我们打log会使用`Log.i()`，但是，如果后面我们突然想换成`Timber.i()`就会很麻烦，需要一个个log找到来替换。但是，如果我们抽象出一个`AppLogger`来，全部调用`AppLogger.i()`来记log，那么我们只要简单的在`AppLogger`内部替换掉具体实现就可以了。\n\n#### 监控网络连接类型，区分`移动数据流量`和`Wi-Fi`；同样，可以监控`电量`和`充电状态`\n对于不同网络类型，我们可以动态改变我们的UI，比如大图可以选择在`Wi-Fi`下才加载，而在`移动数据流量`则不加载。对于`电量`也是类似的逻辑。用户一定会很感谢app做的这种自适应的。\n\n#### User Interface is like a joke.If you have to explain it, it's not that good.\n\n#### 先写slow但是right的代码，再去进行优化\n\n## 小结\n本文长期更新，会保持跟踪最新的技术和研究实践经验，为大家提供有效有用的经验，少走坑。\n\n谢谢！\n\nwingjay\n\n\n\n\n\n欢迎各位关注\n[我的Github](https://github.com/wingjay): <https://github.com/wingjay> \n和 \n[我的个人博客](http://wingjay.com): <http://wingjay.com>\n和\n[我的简书](http://www.jianshu.com/users/da333fd63fe5/latest_articles): <http://www.jianshu.com/users/da333fd63fe5/latest_articles>\n和\n[微博 iam_wingjay](http://weibo.com/u/1625892654): <http://weibo.com/u/1625892654>\n如果有问题，可以给我留言或发邮件<mailto:yinjiesh@126.com>\n\n![](https://avatars0.githubusercontent.com/u/9619875?v=3&s=460)\n\n","slug":"30条Android开发建议","published":1,"updated":"2017-06-23T04:10:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm330044moyx3ot2ki9l","sticky":0},{"title":"梦想升起的地方","_content":"\n<img src=\"https://wingjay.com/img/dream_flies/dream.jpg\" width=\"300\">\n\n好赖，我毕业了🎓。\n\n从本科毕业时懵懂迷茫的自己，到现在坚定方向不为所动的自己。\n\n两三年的磨砺，我成长了非常多。\n\n<!-- more -->\n\n还是那句话，我热爱交大的一草一木，沉静深远，热爱这里共同奋斗努力的同窗好友，热爱每位聪明上进的年轻人。\n\n这一切让我不舍怀念。\n\n然后，生命的车轮总在向前，离别是迟早的。\n\n属于交大的记忆，留在交大。\n\n此刻的我，会继续向前。\n\n在交大，我找到了自己的梦；离开交大，我会将这个梦继续坚持下去。\n\n饮水思源。","source":"_drafts/梦想升起的地方.md","raw":"title: 梦想升起的地方\ntags: \n\t- 随笔\n---\n\n<img src=\"https://wingjay.com/img/dream_flies/dream.jpg\" width=\"300\">\n\n好赖，我毕业了🎓。\n\n从本科毕业时懵懂迷茫的自己，到现在坚定方向不为所动的自己。\n\n两三年的磨砺，我成长了非常多。\n\n<!-- more -->\n\n还是那句话，我热爱交大的一草一木，沉静深远，热爱这里共同奋斗努力的同窗好友，热爱每位聪明上进的年轻人。\n\n这一切让我不舍怀念。\n\n然后，生命的车轮总在向前，离别是迟早的。\n\n属于交大的记忆，留在交大。\n\n此刻的我，会继续向前。\n\n在交大，我找到了自己的梦；离开交大，我会将这个梦继续坚持下去。\n\n饮水思源。","slug":"梦想升起的地方","published":0,"date":"2017-06-22T02:56:46.000Z","updated":"2017-06-22T02:56:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj49cbm360047moyxf5qj3qgj","sticky":0}],"PostAsset":[],"PostCategory":[{"post_id":"cj49cbm0i0004moyxnkb1q9oq","category_id":"cj49cbm0k0005moyxi0xt4q1e","_id":"cj49cbm0n0009moyxmtw93lz3"},{"post_id":"cj49cbm0i0004moyxnkb1q9oq","category_id":"cj49cbm0m0007moyx3z56h5sq","_id":"cj49cbm0n000amoyx8in1z4ly"},{"post_id":"cj49cbm0o000bmoyx6ihlbgr0","category_id":"cj49cbm0q000cmoyxztom1tg7","_id":"cj49cbm0q000fmoyx8q6buet7"},{"post_id":"cj49cbm0s000gmoyx1br5d1m0","category_id":"cj49cbm0t000hmoyx6sydop4r","_id":"cj49cbm0t000imoyxjh46vi5i"},{"post_id":"cj49cbm0v000jmoyxboq9bzi1","category_id":"cj49cbm0w000kmoyx4b5ddjrm","_id":"cj49cbm0x000pmoyxz2jlkllx"},{"post_id":"cj49cbm0v000jmoyxboq9bzi1","category_id":"cj49cbm0w000nmoyxo3yhvugo","_id":"cj49cbm0x000qmoyxe3vhoonz"},{"post_id":"cj49cbm0y000ymoyx6ocvtdry","category_id":"cj49cbm0z000zmoyxq8qmc85r","_id":"cj49cbm100012moyxgswmcltc"},{"post_id":"cj49cbm0y000ymoyx6ocvtdry","category_id":"cj49cbm0z0010moyxgfs1xsm1","_id":"cj49cbm100013moyxhmjpqq3e"},{"post_id":"cj49cbm0y000ymoyx6ocvtdry","category_id":"cj49cbm100011moyxj9dsdh2l","_id":"cj49cbm100014moyxsuv5vd8f"},{"post_id":"cj49cbm110015moyxw4mi8077","category_id":"cj49cbm120016moyxidmnm6fj","_id":"cj49cbm130018moyxdxtf6lw0"},{"post_id":"cj49cbm160019moyxh5j53hg5","category_id":"cj49cbm0k0005moyxi0xt4q1e","_id":"cj49cbm18001dmoyxzmp12tfd"},{"post_id":"cj49cbm160019moyxh5j53hg5","category_id":"cj49cbm17001amoyx6wezraqr","_id":"cj49cbm18001emoyx2et5i75l"},{"post_id":"cj49cbm19001hmoyxuiylz935","category_id":"cj49cbm120016moyxidmnm6fj","_id":"cj49cbm1a001imoyxste0aweq"},{"post_id":"cj49cbm1c001mmoyx0huzkmtc","category_id":"cj49cbm0k0005moyxi0xt4q1e","_id":"cj49cbm1d001nmoyxwr10kkt6"},{"post_id":"cj49cbm1f001pmoyx89gve7uf","category_id":"cj49cbm0k0005moyxi0xt4q1e","_id":"cj49cbm1h001tmoyx99uok099"},{"post_id":"cj49cbm1f001pmoyx89gve7uf","category_id":"cj49cbm1g001qmoyxm4iu89i6","_id":"cj49cbm1h001vmoyx1yz4ee2o"},{"post_id":"cj49cbm1j001wmoyx87jlpunn","category_id":"cj49cbm0k0005moyxi0xt4q1e","_id":"cj49cbm1k001xmoyxamn5ezng"},{"post_id":"cj49cbm1j001wmoyx87jlpunn","category_id":"cj49cbm1g001qmoyxm4iu89i6","_id":"cj49cbm1k001zmoyx2i84bfx2"},{"post_id":"cj49cbm1m0021moyxhj40xmps","category_id":"cj49cbm0k0005moyxi0xt4q1e","_id":"cj49cbm1n0022moyxk47ha1d5"},{"post_id":"cj49cbm1m0021moyxhj40xmps","category_id":"cj49cbm1g001qmoyxm4iu89i6","_id":"cj49cbm1n0024moyxt8m73afb"},{"post_id":"cj49cbm1p002amoyxwbmslbx5","category_id":"cj49cbm0q000cmoyxztom1tg7","_id":"cj49cbm1q002bmoyxjt3mueu4"},{"post_id":"cj49cbm1t002dmoyx9q4r3br6","category_id":"cj49cbm0w000kmoyx4b5ddjrm","_id":"cj49cbm1u002emoyxwgd65gsi"},{"post_id":"cj49cbm1t002dmoyx9q4r3br6","category_id":"cj49cbm0w000nmoyxo3yhvugo","_id":"cj49cbm1v002gmoyxgyhpckcu"},{"post_id":"cj49cbm1x002imoyx2t4pxplo","category_id":"cj49cbm1y002jmoyxm2qqm922","_id":"cj49cbm1z002mmoyx7mcxwsq6"},{"post_id":"cj49cbm21002nmoyx4r9tr6dw","category_id":"cj49cbm0t000hmoyx6sydop4r","_id":"cj49cbm23002omoyx4gauapuc"},{"post_id":"cj49cbm24002pmoyxtkvoiyb9","category_id":"cj49cbm0t000hmoyx6sydop4r","_id":"cj49cbm25002qmoyxjvpx53x2"},{"post_id":"cj49cbm27002tmoyxrh24uzko","category_id":"cj49cbm28002umoyx1v8hctcy","_id":"cj49cbm2a002xmoyxlc04i3xo"},{"post_id":"cj49cbm2b002ymoyxwsslb9cs","category_id":"cj49cbm0k0005moyxi0xt4q1e","_id":"cj49cbm2d002zmoyxaw7hglh4"},{"post_id":"cj49cbm2b002ymoyxwsslb9cs","category_id":"cj49cbm17001amoyx6wezraqr","_id":"cj49cbm2d0031moyxx8cih0kq"},{"post_id":"cj49cbm2h0032moyx8v030xb1","category_id":"cj49cbm28002umoyx1v8hctcy","_id":"cj49cbm2h0033moyxd2h40kmr"},{"post_id":"cj49cbm2j0035moyxmyawhsrg","category_id":"cj49cbm0k0005moyxi0xt4q1e","_id":"cj49cbm2k0036moyxhdx2txlp"},{"post_id":"cj49cbm2j0035moyxmyawhsrg","category_id":"cj49cbm1g001qmoyxm4iu89i6","_id":"cj49cbm2l0038moyxupbyljvw"},{"post_id":"cj49cbm2m003cmoyxpkr8ne1d","category_id":"cj49cbm2n003dmoyxmssjv7kg","_id":"cj49cbm2n003gmoyx72cmgt08"},{"post_id":"cj49cbm2o003jmoyx64dv0zee","category_id":"cj49cbm2n003dmoyxmssjv7kg","_id":"cj49cbm2p003kmoyxi5nqov45"},{"post_id":"cj49cbm2q003mmoyx0jm0rpxp","category_id":"cj49cbm2n003dmoyxmssjv7kg","_id":"cj49cbm2r003nmoyx6itpxsqk"},{"post_id":"cj49cbm2s003rmoyxpb95efeo","category_id":"cj49cbm2n003dmoyxmssjv7kg","_id":"cj49cbm2u003smoyx4457055p"},{"post_id":"cj49cbm2v003vmoyxhr9uf4if","category_id":"cj49cbm2n003dmoyxmssjv7kg","_id":"cj49cbm2x003wmoyx6fn1jrea"},{"post_id":"cj49cbm2y003ymoyxrv9thhfv","category_id":"cj49cbm2n003dmoyxmssjv7kg","_id":"cj49cbm2z003zmoyxvnafu834"},{"post_id":"cj49cbm330044moyx3ot2ki9l","category_id":"cj49cbm0k0005moyxi0xt4q1e","_id":"cj49cbm350045moyxno2l2tl0"}],"PostTag":[{"post_id":"cj49cbm0i0004moyxnkb1q9oq","tag_id":"cj49cbm0k0006moyxl1yvoies","_id":"cj49cbm0m0008moyxnij60qcm"},{"post_id":"cj49cbm0o000bmoyx6ihlbgr0","tag_id":"cj49cbm0q000dmoyxmrqe4cr0","_id":"cj49cbm0q000emoyxqr59a4l2"},{"post_id":"cj49cbm0v000jmoyxboq9bzi1","tag_id":"cj49cbm0w000lmoyxrno4n4c6","_id":"cj49cbm0x000tmoyxfq9cxtr9"},{"post_id":"cj49cbm0v000jmoyxboq9bzi1","tag_id":"cj49cbm0w000mmoyxkf7c5v88","_id":"cj49cbm0x000umoyxhia2h9eo"},{"post_id":"cj49cbm0v000jmoyxboq9bzi1","tag_id":"cj49cbm0x000omoyxr9gf8yg0","_id":"cj49cbm0x000vmoyx3p94v2um"},{"post_id":"cj49cbm0v000jmoyxboq9bzi1","tag_id":"cj49cbm0x000rmoyxzs8c2g7p","_id":"cj49cbm0x000wmoyx9il52kj1"},{"post_id":"cj49cbm0v000jmoyxboq9bzi1","tag_id":"cj49cbm0x000smoyxagqmz7ck","_id":"cj49cbm0x000xmoyxc92m7f75"},{"post_id":"cj49cbm110015moyxw4mi8077","tag_id":"cj49cbm0q000dmoyxmrqe4cr0","_id":"cj49cbm130017moyxy43ff5y3"},{"post_id":"cj49cbm160019moyxh5j53hg5","tag_id":"cj49cbm17001bmoyxxv5etzd9","_id":"cj49cbm18001fmoyxc2j39fu0"},{"post_id":"cj49cbm160019moyxh5j53hg5","tag_id":"cj49cbm18001cmoyxd2xou9mo","_id":"cj49cbm18001gmoyxonsjups9"},{"post_id":"cj49cbm19001hmoyxuiylz935","tag_id":"cj49cbm1a001jmoyxcgv7nyi8","_id":"cj49cbm1b001kmoyxa0ivjp4m"},{"post_id":"cj49cbm19001hmoyxuiylz935","tag_id":"cj49cbm0q000dmoyxmrqe4cr0","_id":"cj49cbm1b001lmoyxgk53iro1"},{"post_id":"cj49cbm1c001mmoyx0huzkmtc","tag_id":"cj49cbm0k0006moyxl1yvoies","_id":"cj49cbm1d001omoyxdavzd5pv"},{"post_id":"cj49cbm1f001pmoyx89gve7uf","tag_id":"cj49cbm0k0006moyxl1yvoies","_id":"cj49cbm1h001smoyxh96z6a2o"},{"post_id":"cj49cbm1f001pmoyx89gve7uf","tag_id":"cj49cbm1g001rmoyx0hraubh1","_id":"cj49cbm1h001umoyx2i2q1471"},{"post_id":"cj49cbm1j001wmoyx87jlpunn","tag_id":"cj49cbm0k0006moyxl1yvoies","_id":"cj49cbm1k001ymoyxpy7qv8uw"},{"post_id":"cj49cbm1j001wmoyx87jlpunn","tag_id":"cj49cbm1g001rmoyx0hraubh1","_id":"cj49cbm1k0020moyxeqvmkpxk"},{"post_id":"cj49cbm1m0021moyxhj40xmps","tag_id":"cj49cbm0k0006moyxl1yvoies","_id":"cj49cbm1o0026moyx94jss60j"},{"post_id":"cj49cbm1m0021moyxhj40xmps","tag_id":"cj49cbm1g001rmoyx0hraubh1","_id":"cj49cbm1o0027moyxwz74iz8v"},{"post_id":"cj49cbm1m0021moyxhj40xmps","tag_id":"cj49cbm1n0023moyxcircsm92","_id":"cj49cbm1o0028moyxib8hesjc"},{"post_id":"cj49cbm1m0021moyxhj40xmps","tag_id":"cj49cbm1n0025moyxm8qt0r1u","_id":"cj49cbm1o0029moyxqk7usmtl"},{"post_id":"cj49cbm1p002amoyxwbmslbx5","tag_id":"cj49cbm0q000dmoyxmrqe4cr0","_id":"cj49cbm1q002cmoyxea1zlhir"},{"post_id":"cj49cbm1t002dmoyx9q4r3br6","tag_id":"cj49cbm0x000smoyxagqmz7ck","_id":"cj49cbm1u002fmoyxxdeovxiw"},{"post_id":"cj49cbm1t002dmoyx9q4r3br6","tag_id":"cj49cbm0x000rmoyxzs8c2g7p","_id":"cj49cbm1v002hmoyx4rd4z4r3"},{"post_id":"cj49cbm1x002imoyx2t4pxplo","tag_id":"cj49cbm1y002kmoyxahdaxl2v","_id":"cj49cbm1z002lmoyxo4pwtqg7"},{"post_id":"cj49cbm24002pmoyxtkvoiyb9","tag_id":"cj49cbm25002rmoyxqan4kcku","_id":"cj49cbm25002smoyxlhhbrl5o"},{"post_id":"cj49cbm27002tmoyxrh24uzko","tag_id":"cj49cbm29002vmoyxgwtq3csx","_id":"cj49cbm29002wmoyxjcoxd024"},{"post_id":"cj49cbm2b002ymoyxwsslb9cs","tag_id":"cj49cbm0k0006moyxl1yvoies","_id":"cj49cbm2d0030moyx5twe7h76"},{"post_id":"cj49cbm2h0032moyx8v030xb1","tag_id":"cj49cbm29002vmoyxgwtq3csx","_id":"cj49cbm2i0034moyx1ne46e7g"},{"post_id":"cj49cbm2j0035moyxmyawhsrg","tag_id":"cj49cbm0k0006moyxl1yvoies","_id":"cj49cbm2l0039moyx4ua9rf75"},{"post_id":"cj49cbm2j0035moyxmyawhsrg","tag_id":"cj49cbm2k0037moyxr2r2ywyg","_id":"cj49cbm2l003amoyxtqk6vy8w"},{"post_id":"cj49cbm2j0035moyxmyawhsrg","tag_id":"cj49cbm1g001rmoyx0hraubh1","_id":"cj49cbm2l003bmoyxcib9wr6i"},{"post_id":"cj49cbm2m003cmoyxpkr8ne1d","tag_id":"cj49cbm2n003emoyx5v950zco","_id":"cj49cbm2n003hmoyxod332l18"},{"post_id":"cj49cbm2m003cmoyxpkr8ne1d","tag_id":"cj49cbm2n003fmoyxodhtq7vm","_id":"cj49cbm2n003imoyxbxvlhnvd"},{"post_id":"cj49cbm2o003jmoyx64dv0zee","tag_id":"cj49cbm2n003emoyx5v950zco","_id":"cj49cbm2p003lmoyxzkadh0rg"},{"post_id":"cj49cbm2q003mmoyx0jm0rpxp","tag_id":"cj49cbm2n003emoyx5v950zco","_id":"cj49cbm2r003pmoyxml64tl45"},{"post_id":"cj49cbm2q003mmoyx0jm0rpxp","tag_id":"cj49cbm2r003omoyx3ygn6z25","_id":"cj49cbm2r003qmoyxx2hu7gnm"},{"post_id":"cj49cbm2s003rmoyxpb95efeo","tag_id":"cj49cbm2n003emoyx5v950zco","_id":"cj49cbm2u003tmoyxk7u6n6xr"},{"post_id":"cj49cbm2s003rmoyxpb95efeo","tag_id":"cj49cbm2r003omoyx3ygn6z25","_id":"cj49cbm2u003umoyxtq5q2sss"},{"post_id":"cj49cbm2v003vmoyxhr9uf4if","tag_id":"cj49cbm2n003emoyx5v950zco","_id":"cj49cbm2x003xmoyxsnf23ks1"},{"post_id":"cj49cbm2y003ymoyxrv9thhfv","tag_id":"cj49cbm2n003emoyx5v950zco","_id":"cj49cbm2z0040moyxo7nlimlz"},{"post_id":"cj49cbm300041moyxn4sptqfu","tag_id":"cj49cbm310042moyxxfx30frq","_id":"cj49cbm310043moyxitsxlpn1"},{"post_id":"cj49cbm330044moyx3ot2ki9l","tag_id":"cj49cbm0k0006moyxl1yvoies","_id":"cj49cbm350046moyx6cqo0gnb"},{"post_id":"cj49cbm360047moyxf5qj3qgj","tag_id":"cj49cbm0q000dmoyxmrqe4cr0","_id":"cj49cbm3t0048moyxmnkxd062"}],"Tag":[{"name":"Android","_id":"cj49cbm0k0006moyxl1yvoies"},{"name":"随笔","_id":"cj49cbm0q000dmoyxmrqe4cr0"},{"name":"GitHub","_id":"cj49cbm0w000lmoyxrno4n4c6"},{"name":"Blog","_id":"cj49cbm0w000mmoyxkf7c5v88"},{"name":"Hexo","_id":"cj49cbm0x000omoyxr9gf8yg0"},{"name":"个人博客","_id":"cj49cbm0x000rmoyxzs8c2g7p"},{"name":"一天变cool","_id":"cj49cbm0x000smoyxagqmz7ck"},{"name":"cool","_id":"cj49cbm17001bmoyxxv5etzd9"},{"name":"动效","_id":"cj49cbm18001cmoyxd2xou9mo"},{"name":"Goodbye2015 Hi 2016","_id":"cj49cbm1a001jmoyxcgv7nyi8"},{"name":"带你学开源项目","_id":"cj49cbm1g001rmoyx0hraubh1"},{"name":"内存泄漏","_id":"cj49cbm1n0023moyxcircsm92"},{"name":"性能优化","_id":"cj49cbm1n0025moyxm8qt0r1u"},{"name":"React Native","_id":"cj49cbm1y002kmoyxahdaxl2v"},{"name":"学习计划","_id":"cj49cbm25002rmoyxqan4kcku"},{"name":"摄影","_id":"cj49cbm29002vmoyxgwtq3csx"},{"name":"RxJava","_id":"cj49cbm2k0037moyxr2r2ywyg"},{"name":"Java","_id":"cj49cbm2n003emoyx5v950zco"},{"name":"多线程","_id":"cj49cbm2n003fmoyxodhtq7vm"},{"name":"Annotation","_id":"cj49cbm2r003omoyx3ygn6z25"},{"name":"welcome","_id":"cj49cbm310042moyxxfx30frq"}]}}